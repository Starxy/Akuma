<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>互联网中常用的密码学场景</title>
    <url>/2019/07/22/%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>对称加密中，通话双方使用同一个密钥，发送消息和接收消息均使用该密钥进行加密和解密。<br>该加密方式项比与非对称加密来说加密解密速度快，但建立在双方均知道密钥的条件下，密钥在传输的过程中可能会被窃取。</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密是指通信双方手持密钥不同，一方为公钥一方为私钥。通信开始时，消息的接受方需要先将公钥发送给消息发送方，然后发送方使用公钥来对消息进行加密，密文发送给接收方来使用私钥解密，完成通信。</p>
<p>在加密通信的过程中，<strong>公钥负责加密，私钥负责解密</strong>，数据即便在传输过程中被截取，因没有私钥，消息也不会被破解。</p>
<p>RSA 为常用的非对称加密算法，其原理为：</p>
<ul>
<li>单向函数正向求解容易，逆向求解很难。</li>
<li>1.对两个质数相乘容易，而将相乘结果分解很难的特征进行加密。n=p1*p2，已知 p1、p2 求 n 简单，已知 n 求 p1、p2 困难。</li>
<li>2.(m^e) mod n=c，已知 m、e、n 求 c 简单，已知 e、n、c 求 m 很难。</li>
</ul>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>以上所说的为消息的加密算法，是用来保证第三方不会窃取到未加密消息。</p>
<p>而数字签名的作用主要有两个：</p>
<ul>
<li>证明消息来源</li>
<li>证明消息完整</li>
</ul>
<p>与上述非对称加密相同，数字签名也是需要一个公钥和一个私钥，不同的是，数字签名中，私钥用来生成签名，公钥用来对签名进行校验。</p>
<p>考虑以下场景：<br>你发布了一个公告，需要一个手段来证明该消息是由你发布的，你只需要用自己的私钥来加密一段话并且附在公告的结尾，收到通知的一方使用公钥对结尾处的密文进行解密，成功解密的话就证明消息是由你本人发送的。这样就证明了消息来源。再次基础之上，想要证明消息完整的话，只需要将公告的原文全文做一次哈希，然后将得到的哈希值用私钥加密作为结尾的签名。收到公告的一方对结尾签名解密之后得到发送时公告的哈希值，之后验证收到的公告哈希是否和原文相同就能判断消息是否完整。</p>
<p>因此，数字签名是利用了<strong>私钥来生成签名，公钥来进行校验</strong>。</p>
<h2 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h2><p>SSL/TLS 就是综合利用了非对称加密，对称加密，数字签名来保证消息在互联网上传播的保密性。最终目的：</p>
<ul>
<li>所有消息<strong>加密传播</strong>，第三方无法窃听</li>
<li>具有<strong>校验机制</strong>，一旦被修改，通信方立刻会发现</li>
<li>配备<strong>身份证书</strong>，防止身份被冒充</li>
</ul>
<p>SSL/TLS 基本过程：</p>
<ul>
<li>客户端向服务器端索要并验证公钥。</li>
<li>双方协商生成”对话密钥”。</li>
<li>双方采用”对话密钥”进行加密通信。</li>
</ul>
<p>上述过程中前两部分称为握手阶段，通过非对称加密来交换信息从而生成密钥来实现对称加密通信。</p>
<p>SSL/TLS 握手过程：</p>
<ol>
<li>首先客户端给出协议版本号，一个客户端生成的随机数 (Client random)，以及客户端支持的加密方法。</li>
<li>服务端确认双方使用的加密方法，并给出数字证书，以及一个服务端生成的随机数 (Server random)。</li>
<li>客户端确认证书有效，然后生成一个新的随机数 (Premaster secret)，并使用证书中的公钥进行加密，发送给服务端。</li>
<li>服务端使用私钥解密获取客户端发来的随机数 (Premaster secret)。</li>
<li>客户端和服务端根据约定的加密方式，使用 Client random、Premaster secret、Premaster secret 三种随机数生成会话密钥 (session key)，来加密接下来的通信完成握手阶段。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>使用 Git 进行有效的项目管理</title>
    <url>/2018/12/14/%E4%BD%BF%E7%94%A8-Git-%E8%BF%9B%E8%A1%8C%E6%9C%89%E6%95%88%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h1><blockquote>
<p>首先理解以下概念对之后的版本和分支管理有很大的帮助<br>该部分内容来自 <a href="https://git-scm.com/book/zh" target="_blank" rel="noopener">git-scm 中文手册</a></p>
</blockquote>
<h2 id="直接记录快照，而非差异比较"><a href="#直接记录快照，而非差异比较" class="headerlink" title="直接记录快照，而非差异比较"></a>直接记录快照，而非差异比较</h2><p>Git 与其他版本管理软件相比，Git 始终在记录快照，而非记录文件的差异。<br>除了 Git 之外的大部分版本控制系统，都是以文件变更列表的方式来存储信息。这类系统（CVS、Subversion、Perforce、Bazaar 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</p>
<p><img src="http://app.starxy.cc:8877/ea/2a1199be85c89f8a86cfd733ee3d34860a4f08.png" alt="deltas"></p>
<p>Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个<strong>快照流</strong>。</p>
<p><img src="http://app.starxy.cc:8877/76/3aba1b1a7a2c99593984efcefa583d36d22f34.png" alt="snapshots"></p>
<p>在之后讨论分支管理的时候，就能体会到这种管理方式带来的益处</p>
<a id="more"></a>
<h2 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h2><p>Git 有三种状态，：已提交（committed）、已修改（modified）和已暂存（staged）。 已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p>
<p>由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域。</p>
<p>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。是中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。<br>你可以试着复制一个项目的 .git 文件夹到一个空文件夹中，执行 <code>git checkout *</code> 你就能发现 git 的版本控制带来的便利</p>
<p>工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p>
<p>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’’，不过一般说法还是叫暂存区域。</p>
<h2 id="Git-的分支"><a href="#Git-的分支" class="headerlink" title="Git 的分支"></a>Git 的分支</h2><p>上面提到了 Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。在提交时，Git 会保存一个提交对象（commit object），该提交对象会存放一个指向暂存内容的指针。当然该对象还包含了作者信息、commit 信息、以及指向其父对象的指针。在经过了多次提交之后，每次的提交对象会根据其父对象指针链在一起形成一个链表结构。<br><img src="http://app.starxy.cc:8877/95/4aea124f740ea4d0bc286e801a9af1a2de3094.png" alt="commits-and-parents"></p>
<p>而我们所用创建的新的分支其实就是创建了一个指向当前提交状态的指针。具体我们在哪个分支上。是由一个叫做 <code>HEAD</code> 的特殊指针来指向对应当前分支的分支指针。<br><img src="http://app.starxy.cc:8877/00/3902474161650bcc984fa3965bfeba20398634.png" alt="branch-and-history"></p>
<p>当在两个不同的分支上进行工作时，当前的分支指针和 <code>HEAD</code> 指针会向前移动，而相对应的，其他分支（指针）会落后于该分支（指针）。在此时当我们进行 <code>merge</code> 合并操作时，实际上是把要合并的分支指针指向要对应的分支指针即可。</p>
<p>而进行检出操作时，也同样是将当前指针指向对应的分支，然后将工作区恢复成对应分支所指向的快照内容<br>所以说，由于 Git 的分支本质上是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？</p>
<h1 id="Git-的分支管理最佳实践"><a href="#Git-的分支管理最佳实践" class="headerlink" title="Git 的分支管理最佳实践"></a>Git 的分支管理最佳实践</h1><h2 id="主干分支"><a href="#主干分支" class="headerlink" title="主干分支"></a>主干分支</h2><blockquote>
<p>此部分内容来自于 <a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a></p>
</blockquote>
<p>中心库要保证至少有两个伴随代码库整个生命流程的主要分支</p>
<ul>
<li>main</li>
<li>develop</li>
</ul>
<p>我们始终将 origin/master 分支作为一个主干分支，并且将他的 HEAD 指针始终指向可发布的生产状态（production-ready state）<br>origin/develop 分支作为另一主干分支，而它的 HEAD 指针始终指向为下一发版而做的最新开发改动。有人把这成为 integration 分支。通常这就是 nightly 版本发布的出处。<br>因此，每次把改动合并到 master 分支上后，就生成了一个新的可发布的生产状态。我们对合并到 master 分支的行为把控严格，所以理论上，每当 master 分支上有 commit 操作时，我们可以通过 Git hook 脚本实现自动构建并把应用推送到生产服务器上。</p>
<h2 id="辅助分支"><a href="#辅助分支" class="headerlink" title="辅助分支"></a>辅助分支</h2><p>主干分支之外，我们的开发模型使用了很多辅助分支来帮助团队成员间的并行开发，减轻功能跟踪的成本，预备新版的发布，协助快速修复已发布版本的问题。和主干分支不同，这些辅助分支只有有限的生命期，最终会被移除。<br>我们可能会用到的辅助分支有：</p>
<ul>
<li>Feature 分支</li>
<li>Release 分支</li>
<li>Hotfix 分支</li>
</ul>
<h3 id="Feature-分支"><a href="#Feature-分支" class="headerlink" title="Feature 分支"></a>Feature 分支</h3><p>从 develop 分支派生，且必须 merge 回 develop 分支<br>是用来为未来的发版而开发新 features 的分支。当开始 feature 的开发时，feature 将在那个版本被合并还是未知的。但是只要该功能处在开发状态 feature 分支就会存在，如果要将 feature 添加到新版本中，那么就将该分支合并到 develop 分支，否则丢弃。</p>
<p>Feature 分支通常只存在于开发者的 repo 中，而不会在中心库 origin repo 中。</p>
<h3 id="Release-分支"><a href="#Release-分支" class="headerlink" title="Release 分支"></a>Release 分支</h3><h1 id="Github-最佳实践"><a href="#Github-最佳实践" class="headerlink" title="Github 最佳实践"></a>Github 最佳实践</h1>]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>APScheduler 用户指南</title>
    <url>/2018/12/12/APScheduler-User-guide/</url>
    <content><![CDATA[<blockquote>
<p>全文译自 APScheduler 官方文档<br>原文地址：<a href="https://apscheduler.readthedocs.io/en/latest/userguide.html" target="_blank" rel="noopener">https://apscheduler.readthedocs.io/en/latest/userguide.html</a></p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首选安装方式为通过 <code>pip</code> 安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install apscheduler</span><br></pre></td></tr></table></figure>
<p>你可以下载并运行 <a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="noopener">get-pip.py</a> 来轻易的安装 <code>pip</code></p>
<p>某些原因下，<code>pip</code> 不能工作，你可以从 PypI 手动下载 <a href="https://pypi.python.org/pypi/APScheduler/" target="_blank" rel="noopener">APScheduler 包文件</a>，然后完成安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>包文件中包含了名为 <code>example</code> 的文件夹，可以在该文件夹下找到 APScheduler 的多种使用样例。样例同样也可以 <a href="https://github.com/agronholm/apscheduler/tree/master/examples/?at=master" target="_blank" rel="noopener">在线浏览</a></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>APSchedule 有四种基本的组件</p>
<ul>
<li>触发器（triggers）</li>
<li>作业存储器（job stores）</li>
<li>执行器（executors）</li>
<li>调度器（schedulers）</li>
</ul>
<a id="more"></a>
<p><strong>触发器</strong> 包含调度逻辑。每一个任务有自己的调度器来确定何时运行作业。除了初始配置之外，触发器是完全无状态的（stateless）</p>
<p><strong>作业存储器</strong> 存储被调度的作业。默认的任务存储器只将作业保存在内存中，其他的任务存储器可以将作业保存在多种数据库中。作业的数据在保存到持久性的数据存储器中时都会被序列化，从中加载时将会被反序列化。除了默认的存储器外，作业存储器不会将作业存储在内存中，而是在扮演一个中间人从后端进行保存，加载，更新，查询等工作。绝对不能在调度器之间共享任务存储器</p>
<p><strong>执行器</strong> 处理作业的运行。通常通过将作业中可调用对象提交给线程或者进程池来完成此操作。作业完成后执行器将会通知调度器，调度器随后发出相应的事件</p>
<p><strong>调度器</strong> 是剩余的部分。通常来说你只有一个调度器运行在一个应用实例中。开发者一般不会直接处理触发器、作业存储器和执行器，而是通过调度器来提供相应的接口来处理。配置作业存储器和执行器通过调度器来完成，比如添加，修改，删除作业</p>
<h2 id="选择合适的调度器、作业存储器、执行器和触发器"><a href="#选择合适的调度器、作业存储器、执行器和触发器" class="headerlink" title="选择合适的调度器、作业存储器、执行器和触发器"></a>选择合适的调度器、作业存储器、执行器和触发器</h2><p>选择的调度器主要取决于您的开发环境和使用 APScheduler 的目的，以下是选择调度器的快速说明：</p>
<ul>
<li><a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/blocking.html#apscheduler.schedulers.blocking.BlockingScheduler" target="_blank" rel="noopener"><code>BlockingScheduler</code></a>：当调度器是应用进程中唯一的运行事项时使用</li>
<li><a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/background.html#apscheduler.schedulers.background.BackgroundScheduler" target="_blank" rel="noopener"><code>BackgroundScheduler</code></a>：当您没有使用以下框架，并希望调度程序运行在应用内部时使用</li>
<li><a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/asyncio.html#apscheduler.schedulers.asyncio.AsyncIOScheduler" target="_blank" rel="noopener"><code>AsyncIOScheduler</code></a>：当应用使用异步 io 模块时使用</li>
<li><a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/gevent.html#apscheduler.schedulers.gevent.GeventScheduler" target="_blank" rel="noopener"><code>GeventScheduler</code></a>：当应用使用 gevent 时使用</li>
<li><a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/tornado.html#apscheduler.schedulers.tornado.TornadoScheduler" target="_blank" rel="noopener"><code>TornadoScheduler</code></a>：当你构建一个 Tornado 应用是使用</li>
<li><a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/twisted.html#apscheduler.schedulers.twisted.TwistedScheduler" target="_blank" rel="noopener"><code>TwistedScheduler</code></a>：当你构建一个 Twisted 应用时使用</li>
<li><a href="."><code>QtScheduler</code></a>：当你构建一个 Qt 应用时使用</li>
</ul>
<p>为了选择合适的作业存储器，你需要确定是否需要持久化作业，如果程序启动时作业总是被重新创建，你可以使用默认值（<code>MemoryJobStore</code>）。但是如果你需要你的作业在应用重启或者崩溃时保留作业调度程序，那么您可以选择您工作环境中最常用的工具。由于 <code>PostgreSQL</code> 强大的数据完整性保护，使用 <a href="https://apscheduler.readthedocs.io/en/latest/modules/jobstores/sqlalchemy.html#apscheduler.jobstores.sqlalchemy.SQLAlchemyJobStore" target="_blank" rel="noopener"><code>SQLAlchemyJobStore</code></a> 和 <code>PostgreSQL</code> 是比较好的选择</p>
<p>如果你使用调度器选择部分所述框架之一，执行器通常会给你选定。否则的话，默认的 <a href="https://apscheduler.readthedocs.io/en/latest/modules/executors/pool.html#apscheduler.executors.pool.ThreadPoolExecutor" target="_blank" rel="noopener"><code>ThreadPoolExecutor</code></a> 应该足以应付大多数情况。如果你的工作负载涉及 CPU 密集操作。则应该考虑 <a href="https://apscheduler.readthedocs.io/en/latest/modules/executors/pool.html#apscheduler.executors.pool.ProcessPoolExecutor" target="_blank" rel="noopener"><code>ProcessPoolExecutor</code></a> 来使用多个 CPU 核心。你也可以同时使用这两者。将 ProcessPoolExecutor 添加为第二执行器</p>
<p>当你调度一个作业时，你需要为它选择一个触发器。触发器决定了作业触发的时间逻辑。APScheduler 有三种内建的触发器类型：</p>
<ul>
<li><a href="https://apscheduler.readthedocs.io/en/latest/modules/triggers/date.html#module-apscheduler.triggers.date" target="_blank" rel="noopener"><code>data</code></a>：当你想要在某个特定时间点运行任务时使用</li>
<li><a href="https://apscheduler.readthedocs.io/en/latest/modules/triggers/interval.html#module-apscheduler.triggers.interval" target="_blank" rel="noopener"><code>interval</code></a>：当你想要以固定的时间间隔运行作业时使用</li>
<li><a href="https://apscheduler.readthedocs.io/en/latest/modules/triggers/cron.html#module-apscheduler.triggers.cron" target="_blank" rel="noopener"><code>cron</code></a>：当你想要在一天中的某个特定时间运行作业时使用</li>
</ul>
<p>也可以将多个触发器组合成一个触发器，该触发器将在所有参与触发器的约定时间内出发。也可以在任何触发器触发时触发。更多文档请看 <a href="https://apscheduler.readthedocs.io/en/latest/modules/triggers/combining.html#module-apscheduler.triggers.combining" target="_blank" rel="noopener"><code>combining triggers</code></a></p>
<p>你可以在各自的 API 文档页面上找到每个作业存储，执行器，触发器类型的插件名称。</p>
<h2 id="配置调度器"><a href="#配置调度器" class="headerlink" title="配置调度器"></a>配置调度器</h2><p>APScheduler 提供了多种方式来配置调度器。你可以使用配置字典，也可以将选项作为关键在参数传递，也可以先实例化调度器，然后再添加作业并配置调度器。这样你就可以在任何环境下的最大灵活性</p>
<p>可以在 <a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/base.html#apscheduler.schedulers.base.BaseScheduler" target="_blank" rel="noopener"><code>BaseScheduler</code></a> 类的 API 参考上找到调度器级别配置选线的完整列表。调度器子类还包含额外的选项，在相关的 API 文档中已经给出。每个作业存储器和执行器的配置选项也可以在各自相关的 API 文档中找到</p>
<p>假设你希望在你的应用中运行一个默认的作业存储器和执行器的 BackgroundScheduler</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> apscheduler.schedulers.background <span class="keyword">import</span> BackgroundScheduler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">scheduler = BackgroundScheduler()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the rest of the application here, or before the scheduler initialization</span></span><br></pre></td></tr></table></figure>
<p>这将为您提供一个 BackgroundScheduler，其 MemoryJobStore 名为“default”，ThreadPoolExecutor 名为“default”，默认最大线程数为 10。</p>
<p>现在假设你需要两个作业存储器使用两个执行器。并且你希望调整新作业的默认值并且设置不同的时区。以下三个示例完全等效，并且提供：</p>
<ul>
<li>一个名为 mongo 的 MongoDBJobStore</li>
<li>一个名为 default 的 SQLAlchemyJobStore (使用 SQLite)</li>
<li>一个名为 default 的 ThreadPoolExecutor 最大线程为 20</li>
<li>一个名为 processpool 的 ProcessPoolExecutor 最大线程为 5</li>
<li>UTC 作为调度器的时区</li>
<li>默认新作业的 coalescing 关闭</li>
<li>新作业的默认最大实例限制为 3</li>
</ul>
<p>示例 1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pytz <span class="keyword">import</span> utc</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.background <span class="keyword">import</span> BackgroundScheduler</span><br><span class="line"><span class="keyword">from</span> apscheduler.jobstores.mongodb <span class="keyword">import</span> MongoDBJobStore</span><br><span class="line"><span class="keyword">from</span> apscheduler.jobstores.sqlalchemy <span class="keyword">import</span> SQLAlchemyJobStore</span><br><span class="line"><span class="keyword">from</span> apscheduler.executors.pool <span class="keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jobstores = &#123;</span><br><span class="line">    <span class="string">'mongo'</span>: MongoDBJobStore(),</span><br><span class="line">    <span class="string">'default'</span>: SQLAlchemyJobStore(url=<span class="string">'sqlite:///jobs.sqlite'</span>)</span><br><span class="line">&#125;</span><br><span class="line">executors = &#123;</span><br><span class="line">    <span class="string">'default'</span>: ThreadPoolExecutor(<span class="number">20</span>),</span><br><span class="line">    <span class="string">'processpool'</span>: ProcessPoolExecutor(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line">job_defaults = &#123;</span><br><span class="line">    <span class="string">'coalesce'</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">'max_instances'</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">scheduler = BackgroundScheduler(jobstores=jobstores, executors=executors, job_defaults=job_defaults, timezone=utc)</span><br></pre></td></tr></table></figure>
<p>示例 2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> apscheduler.schedulers.background <span class="keyword">import</span> BackgroundScheduler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># The "apscheduler." prefix is hard coded</span></span><br><span class="line">scheduler = BackgroundScheduler(&#123;</span><br><span class="line">    <span class="string">'apscheduler.jobstores.mongo'</span>: &#123;</span><br><span class="line">         <span class="string">'type'</span>: <span class="string">'mongodb'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'apscheduler.jobstores.default'</span>: &#123;</span><br><span class="line">        <span class="string">'type'</span>: <span class="string">'sqlalchemy'</span>,</span><br><span class="line">        <span class="string">'url'</span>: <span class="string">'sqlite:///jobs.sqlite'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'apscheduler.executors.default'</span>: &#123;</span><br><span class="line">        <span class="string">'class'</span>: <span class="string">'apscheduler.executors.pool:ThreadPoolExecutor'</span>,</span><br><span class="line">        <span class="string">'max_workers'</span>: <span class="string">'20'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'apscheduler.executors.processpool'</span>: &#123;</span><br><span class="line">        <span class="string">'type'</span>: <span class="string">'processpool'</span>,</span><br><span class="line">        <span class="string">'max_workers'</span>: <span class="string">'5'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'apscheduler.job_defaults.coalesce'</span>: <span class="string">'false'</span>,</span><br><span class="line">    <span class="string">'apscheduler.job_defaults.max_instances'</span>: <span class="string">'3'</span>,</span><br><span class="line">    <span class="string">'apscheduler.timezone'</span>: <span class="string">'UTC'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>示例 3</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pytz <span class="keyword">import</span> utc</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> apscheduler.schedulers.background <span class="keyword">import</span> BackgroundScheduler</span><br><span class="line"><span class="keyword">from</span> apscheduler.jobstores.sqlalchemy <span class="keyword">import</span> SQLAlchemyJobStore</span><br><span class="line"><span class="keyword">from</span> apscheduler.executors.pool <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jobstores = &#123;</span><br><span class="line">    <span class="string">'mongo'</span>: &#123;<span class="string">'type'</span>: <span class="string">'mongodb'</span>&#125;,</span><br><span class="line">    <span class="string">'default'</span>: SQLAlchemyJobStore(url=<span class="string">'sqlite:///jobs.sqlite'</span>)</span><br><span class="line">&#125;</span><br><span class="line">executors = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;<span class="string">'type'</span>: <span class="string">'threadpool'</span>, <span class="string">'max_workers'</span>: <span class="number">20</span>&#125;,</span><br><span class="line">    <span class="string">'processpool'</span>: ProcessPoolExecutor(max_workers=<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line">job_defaults = &#123;</span><br><span class="line">    <span class="string">'coalesce'</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">'max_instances'</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">scheduler = BackgroundScheduler()</span><br><span class="line"></span><br><span class="line"><span class="comment"># .. do something else here, maybe add jobs etc.</span></span><br><span class="line"></span><br><span class="line">scheduler.configure(jobstores=jobstores, executors=executors, job_defaults=job_defaults, timezone=utc)</span><br></pre></td></tr></table></figure>
<h2 id="启动调度器"><a href="#启动调度器" class="headerlink" title="启动调度器"></a>启动调度器</h2><p>通过调用 <a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/base.html#apscheduler.schedulers.base.BaseScheduler.start" target="_blank" rel="noopener"><code>start()</code></a> 可以很简单的启动调度器。对于 <code>BlockingScheduler</code> 以外的调度器，此调用程序将立刻返回，你可以继续应用程序的初始化过程。</p>
<p>对于 <code>BlockingScheduler</code>，你只能在完成所有初始化步骤之后再调用 <code>start()</code></p>
<blockquote>
<p>注意: 在调度器启动后，你不能再更改任何设置</p>
</blockquote>
<h2 id="添加作业"><a href="#添加作业" class="headerlink" title="添加作业"></a>添加作业</h2><p>有两种方式添加作业到调度器</p>
<ol>
<li>调用 <a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/base.html#apscheduler.schedulers.base.BaseScheduler.add_job" target="_blank" rel="noopener"><code>add_job()</code></a></li>
<li>使用 <a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/base.html#apscheduler.schedulers.base.BaseScheduler.scheduled_job" target="_blank" rel="noopener"><code>scheduled_job()</code></a> 装饰函数</li>
</ol>
<p>第一种方式是最常用的方式。第二种方法主要是方便的声明那些在应用运行时不会更改的作业。 <code>add_job()</code> 方法返回一个 <a href="https://apscheduler.readthedocs.io/en/latest/modules/job.html#apscheduler.job.Job" target="_blank" rel="noopener"><code>apscheduler.job.Job</code></a> 实例，可以稍后用来修改或删除作业</p>
<p>你可以在<strong>任何时间</strong>在调度器上安排作业。如果添加作业时调度器尚未运行。作业将会被暂时调度，当调度器启动时，该作业的第一个运行时间（触发器触发的时间点）才会被计算</p>
<p>必须注意到的是，如果你使用序列化的执行器和作业存储器。它会给你的作业添加一下要求：</p>
<ol>
<li>可调用的目标必须是可以全局访问的</li>
<li>对可调用目标的任何参数必须是可序列化的</li>
</ol>
<p>内置作业存储器中，只有 MemoryJobStore 不会序列化作业；内置执行器中，只有 ProcessPoolExecutor 会序列化作业</p>
<blockquote>
<p>重要：在初始化阶段如果你在持久化作业存储器中调度作业，则必须为作业定义显式 ID 并且使用 <code>replace_existing = True</code> 否则每次应用重启都会获得作业的新副本<br>技巧：要立即运行作业，在添加作业时忽略 <code>trigger</code> 参数</p>
</blockquote>
<h2 id="移除作业"><a href="#移除作业" class="headerlink" title="移除作业"></a>移除作业</h2><p>当你从调度器移除一个作业时，他将会从关联的作业存储器中移除，并且不会再执行。有两种方式可以删除作业：</p>
<ol>
<li>调用 <a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/base.html#apscheduler.schedulers.base.BaseScheduler.remove_job" target="_blank" rel="noopener"><code>remove_job()</code></a> 带有作业的 ID 和作业存储器的别名</li>
<li>通过由 <code>add_job()</code> 返回的作业实例调用 <a href="https://apscheduler.readthedocs.io/en/latest/modules/job.html#apscheduler.job.Job.remove" target="_blank" rel="noopener"><code>remove()</code></a></li>
</ol>
<p>后一个方法更方便，但是需要你在某处存储添加作业时返回的对象实例，对于通过<code>scheduled_job()</code>调度的作业，仅能通过第一个方法来删除</p>
<p>当某个作业调度结束（例如：它的触发器再也不会触发），该作业将会自动移除</p>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">job = scheduler.add_job(myfunc, <span class="string">'interval'</span>, minutes=<span class="number">2</span>)</span><br><span class="line">job.remove()</span><br></pre></td></tr></table></figure>
<p>同样的，使用显式的作业 ID</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scheduler.add_job(myfunc, <span class="string">'interval'</span>, minutes=<span class="number">2</span>, id=<span class="string">'my_job_id'</span>)</span><br><span class="line">scheduler.remove_job(<span class="string">'my_job_id'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="暂停和恢复作业"><a href="#暂停和恢复作业" class="headerlink" title="暂停和恢复作业"></a>暂停和恢复作业</h2><p>你可以很轻易的通过一个 <code>Job</code> 实例或调度器来暂停和恢复作业。当一个作业被暂停时，下一次的触发时间将会被清楚，并且不再进行计算之后的触发时间，直到该作业被恢复。要暂停一个作业，可以使用以下方法：</p>
<ul>
<li><a href="https://apscheduler.readthedocs.io/en/latest/modules/job.html#apscheduler.job.Job.pause" target="_blank" rel="noopener"><code>apscheduler.job.Job.pause()</code></a></li>
<li><a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/base.html#apscheduler.schedulers.base.BaseScheduler.pause_job" target="_blank" rel="noopener"><code>apscheduler.schedulers.base.BaseScheduler.pause_job()</code></a></li>
</ul>
<p>要恢复一个作业：</p>
<ul>
<li><a href="https://apscheduler.readthedocs.io/en/latest/modules/job.html#apscheduler.job.Job.resume" target="_blank" rel="noopener"><code>apscheduler.job.Job.resume()</code></a></li>
<li><a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/base.html#apscheduler.schedulers.base.BaseScheduler.resume_job" target="_blank" rel="noopener"><code>apscheduler.schedulers.base.BaseScheduler.resume_job()</code></a></li>
</ul>
<h2 id="获取作业调度列表"><a href="#获取作业调度列表" class="headerlink" title="获取作业调度列表"></a>获取作业调度列表</h2><p>要获得可处理的计划作业列表，可以使用 <a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/base.html#apscheduler.schedulers.base.BaseScheduler.get_jobs" target="_blank" rel="noopener"><code>get_jobs()</code></a> 方法。该方法会返回一个 <code>Job</code> 实例列表。如果你只想关心某个特定作业存储器中的作业，可以将作业存储器的别名当作参数传入</p>
<p>方便起见，你可以使用 <a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/base.html#apscheduler.schedulers.base.BaseScheduler.print_jobs" target="_blank" rel="noopener"><code>print_jobs</code></a> 方法，该方法将打印格式化的作业列表，其触发器和下次运行时间</p>
<h2 id="修改作业"><a href="#修改作业" class="headerlink" title="修改作业"></a>修改作业</h2><p>你可以通过调用 <a href="https://apscheduler.readthedocs.io/en/latest/modules/job.html#apscheduler.job.Job.modify" target="_blank" rel="noopener"><code>apscheduler.job.Job.modify()</code></a> 或 <a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/base.html#apscheduler.schedulers.base.BaseScheduler.modify_job" target="_blank" rel="noopener"><code>modify_job()</code></a> 来修改任何一个作业的除了 <code>id</code> 之外的任何属性属性</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">job.modify(max_instances=<span class="number">6</span>, name=<span class="string">'Alternate name'</span>)</span><br></pre></td></tr></table></figure>
<p>如果你想要重新调度一个作业，即改变触发器可以使用 <a href="https://apscheduler.readthedocs.io/en/latest/modules/job.html#apscheduler.job.Job.reschedule" target="_blank" rel="noopener"><code>apscheduler.job.Job.reschedule()</code></a> 或 <a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/base.html#apscheduler.schedulers.base.BaseScheduler.reschedule_job" target="_blank" rel="noopener"><code>reschedule_job()</code></a>。这两个方法会为作业构造一个新的触发器，并且会根据新的触发器重新计算下一个运行时间</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scheduler.reschedule_job(<span class="string">'my_job_id'</span>, trigger=<span class="string">'cron'</span>, minute=<span class="string">'*/5'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="停止调度器"><a href="#停止调度器" class="headerlink" title="停止调度器"></a>停止调度器</h2><p>为了停止调度器，可以执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scheduler.shutdown()</span><br></pre></td></tr></table></figure>
<p>默认情况下，调度器关闭其作业存储器和执行器，并等待所有当前正在执行的作业完成。如果你不想等待你可以：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scheduler.shutdown(wait=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>这样将会关闭作业存储器和执行器但是不会等到任何运行的作业完成</p>
<h2 id="暂停和恢复作业处理（调度器暂停）"><a href="#暂停和恢复作业处理（调度器暂停）" class="headerlink" title="暂停和恢复作业处理（调度器暂停）"></a>暂停和恢复作业处理（调度器暂停）</h2><p>暂停作业处理是可能的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scheduler.pause()</span><br></pre></td></tr></table></figure>
<p>这会造成调度器在恢复处理之前不在会唤醒</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scheduler.resume()</span><br></pre></td></tr></table></figure>
<p>也可以在暂停状态下启用调度器，即没有第一个唤醒调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scheduler.start(paused=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>如果你需要删除以一些你不需要的但是有机会运行的作业这会非常有用</p>
<h2 id="限制并发执行的作业实例数量"><a href="#限制并发执行的作业实例数量" class="headerlink" title="限制并发执行的作业实例数量"></a>限制并发执行的作业实例数量</h2><p>默认情况下，一个作业只能有一个实例在一个时间点运行。这意味着，如果作业即将运行但是前一个时间点运行的还没有完成，则最新的作业运行时将会视为失败。在添加作业时指定 <code>max_instances</code> 关键字参数，可以是设定调度器将允许并发运行的该作业实例数量</p>
<h2 id="丢失的作业执行器和合并（coalescing）"><a href="#丢失的作业执行器和合并（coalescing）" class="headerlink" title="丢失的作业执行器和合并（coalescing）"></a>丢失的作业执行器和合并（coalescing）</h2><p>有些时候，调度器可能不能在计划运行时执行调度作业，最常见的情况是当作业被在序列化作业存储中调用时，调度器在该作业应该执行后关闭并重启。发生这种情况时，该作业被认为是“失火”，调度器将会根据 <code>misfire_grace_time</code> 选项（可按作业设置或者全局调度器选项设置）来检查每个错过的执行时间，以查看是否仍需要出发作业，这可能导致多次连续执行作业</p>
<p>如果你的用例不希望出现这种情况，则可以使用 <code>coalescing</code> 来将所有的错过执行合并为一个。总而言之，如果 <code>coalescing</code> 选项为开启的，并且调度器看到了一个或多个队列中的作业执行，那么触发器将会执行一次</p>
<blockquote>
<p>注意：如果由于可用池中没有可用的线程或者进程而延迟作业，则执行器可能会因为它运行得太晚而挑过它（与最初的运行时间相比）。如果您的应用程序中可能发生这种情况，你可能希望增加执行器的线程/进程数，或者将 <code>misfire_grace_time</code> 的值调整的更高</p>
</blockquote>
<h2 id="调度器事件"><a href="#调度器事件" class="headerlink" title="调度器事件"></a>调度器事件</h2><p>可以将事件监听器附加到调度器上。调度器在某些情况下被触发，并且可能携带该特定事件的详细附加信息。通过给定合适的 <code>mask</code> 参数到 <a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/base.html#apscheduler.schedulers.base.BaseScheduler.add_listener" target="_blank" rel="noopener"><code>add_listener()</code></a> 方法或者将不同的常量放在一起，可以只监听某种特定类型的事件。可调用的接收器可以被带着一个 event 对象调用</p>
<p>有关可用事件及其属性的详细信息，请查看关于 <a href="https://apscheduler.readthedocs.io/en/latest/modules/events.html#module-apscheduler.events" target="_blank" rel="noopener"><code>events</code></a> 模块的文档</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_listener</span><span class="params">(event)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> event.exception:</span><br><span class="line">        print(<span class="string">'The job crashed :('</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'The job worked :)'</span>)</span><br><span class="line"></span><br><span class="line">scheduler.add_listener(my_listener, EVENT_JOB_EXECUTED | EVENT_JOB_ERROR)</span><br></pre></td></tr></table></figure>
<h2 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h2><p>如果调度器没有按照预想来工作，提高 <code>apscheduler</code> logger 的日志级别为 <code>DEBUG</code> 会很有帮助</p>
<p>如果尚未开启日志记录，可以执行以下操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig()</span><br><span class="line">logging.getLogger(<span class="string">'apscheduler'</span>).setLevel(logging.DEBUG)</span><br></pre></td></tr></table></figure>
<p>这应该提供许多关于调度程序内部发生的有用信息。</p>
<p>另外，请确保查看 <a href="https://apscheduler.readthedocs.io/en/latest/faq.html" target="_blank" rel="noopener">常见问题</a> 部分，以查看问题是否已解决。</p>
<h2 id="Reporting-bugs"><a href="#Reporting-bugs" class="headerlink" title="Reporting bugs"></a>Reporting bugs</h2><p>A bug tracker is provided by Github.</p>
<h2 id="Getting-help"><a href="#Getting-help" class="headerlink" title="Getting help"></a>Getting help</h2><p>If you have problems or other questions, you can either:</p>
<ul>
<li>Ask in the <a href="https://gitter.im/apscheduler/Lobby" target="_blank" rel="noopener">apscheduler</a> room on Gitter</li>
<li>Ask on the <a href="http://groups.google.com/group/apscheduler" target="_blank" rel="noopener">APScheduler Google group</a>, or</li>
<li>Ask on <a href="http://stackoverflow.com/questions/tagged/apscheduler" target="_blank" rel="noopener">StackOverflow</a> and tag your question with the <code>apscheduler</code> tag</li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>弱类型 强类型 动态类型 静态类型 之间的区别</title>
    <url>/2018/11/27/%E5%BC%B1%E7%B1%BB%E5%9E%8B-%E5%BC%BA%E7%B1%BB%E5%9E%8B-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="通俗解释"><a href="#通俗解释" class="headerlink" title="通俗解释"></a>通俗解释</h1><ul>
<li><strong>编译时知道变量类型的是静态类型，反之为动态类型。</strong></li>
<li>静态类型在处理类型错误时是运行错误，而动态类型为运行时错误</li>
<li><p>比如 JavaScript 中 <code>var a = b.getName()</code> 是动态类型的，运行时才能根据 <code>getName()</code> 的返回值确定<code>a</code>的变量类型</p>
</li>
<li><p><strong>不允许隐式类型转换的为强类型，反之为弱类型</strong></p>
</li>
<li>比如 C++ 中 int 可以和 double 之间进行隐式的类型转换，haskell 的 int 就不能变成 double</li>
</ul>
<p>但是根据这两种定义我们会发现有这种情况的产生：<br>一般来说我们认为：Python 为强类型语言，C/C++为弱类型语言，但是 Python 中同样支持 int 与 double 之间的隐式类型转换，根据定义 Python 反而为弱类型语言。<br>在这种情况下引入下一节的定义更为的妥善。而对 Python 语言类型的解释可以参看下面的链接</p>
<ul>
<li><a href="https://www.zhihu.com/question/20224705" target="_blank" rel="noopener">如何理解编程语言（例如 Python）的强类型和动态连编？</a></li>
<li><a href="https://www.zhihu.com/question/43498005" target="_blank" rel="noopener">为什么说 Python 是强类型语言？</a></li>
</ul>
<h1 id="与编译器行为有关的定义"><a href="#与编译器行为有关的定义" class="headerlink" title="与编译器行为有关的定义"></a>与编译器行为有关的定义</h1><p>在描述更为科学的类型顶一下让我们先引入这些概念</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><strong>Program Errors</strong><ul>
<li><strong>trapped errors</strong> ： 导致程序终止执行。如除 0、Java 中数组越界访问</li>
<li><strong>untrapped errors</strong>： 出错后继续执行，但可能出现任意行为。如 C 里的缓冲区溢出、Jump 到错误地址</li>
</ul>
</li>
<li><strong>Forbidden Behaviors</strong>： 语言设计时，可以定义一组 forbidden behaviors. 必须包括所有 untrapped errors, 可能包含 trapped errors.</li>
<li><strong>Well behaved</strong>： 如果程序执行不可能出现 forbidden behaviors, 则为 well behaved。</li>
<li><strong>ill behaved</strong>：否则为 ill behaved</li>
</ul>
<p>这几个概念之间的关系如下：<br><img src="http://app.starxy.cc:8877/41/2d22e1622866e2acfc6f0fdee8b540cd2cb6df.jpg" alt="基本概念关系"></p>
<h2 id="具体定义"><a href="#具体定义" class="headerlink" title="具体定义"></a>具体定义</h2><ul>
<li><strong>强、弱类型</strong></li>
<li>如果一个语言的所有程序都为 well behaved，即不可能出现 forbidden behaviors，则该语言为强类型</li>
<li><p>如果一个语言出现了 ill behaved，比如 C 语言的缓冲区溢出，属于 trapped errors，则该语言为弱类型</p>
</li>
<li><p><strong>静态、动态类型</strong></p>
</li>
<li>如果在编译期间拒绝了 ill behaved 程序，则为静态类型</li>
<li>如果在运行期间拒绝 ill behaved 程序，则为动态类型</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，目前在网络上能查到的相关定义大体来说就是如上所说，当然显而易见的是，如果存在一个程序有 untrapeed errors 行为，那么也就是说编译器没有阻止这种行为的发生，也就是没有在编译期间拒绝ill behaved程序，所以弱类型静态语言是怎么产生的呢。<br>这个问题之后再看吧。</p>
<p>常见的语言类型划分</p>
<p><img src="http://app.starxy.cc:8877/e6/2463fe3f45ade40ae6ddc52a9b1113e778cb20.jpg" alt="常见语言类型划分"></p>
]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理</title>
    <url>/2018/09/26/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>该文章为计算机图形图像处理选修课笔记</p>
</blockquote>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li>数字图像处理为使用<strong>像素</strong>作为基本构成单位</li>
<li>图像处理可以分为三个层级<ul>
<li>低级处理：输入输出均为图像；比如图像降噪，对比度增强，锐化等</li>
<li>中级处理：输入为图像但输出为图像的特征；比如图像边缘提取，使计算机更方便的对图像进行处理</li>
<li>高级处理：对图像内容的理解：人脸识别，指纹识别</li>
</ul>
</li>
<li>各类图像都是由<strong>照射源</strong>和形成图像的<strong>场景</strong>元素 对光能的反射或吸收相结合而产生</li>
<li>数字图像以像素对应的灰度值，反应对应像素的颜色， 一个数值表示一个颜色</li>
<li>灰度值的典型取值范围是 2 的整数次幂，目前最常用的值是 256 即 0-255</li>
<li>黑白图像采用单通道即可描述，而彩色图像需要三通道构成，最常见的为 RGB 图，即图像三原色</li>
</ul>
<h2 id="BMP-文件格式"><a href="#BMP-文件格式" class="headerlink" title="BMP 文件格式"></a>BMP 文件格式</h2><ul>
<li>BMP 文件由文件头和数据区域构成，其中文件头保存文件信息，图像信息，调色板数据。数据区域保存图像数据</li>
<li>文件信息<ul>
<li>WORD BMPid BMP 文件标志，其固定值为 0x4d42 即 BM</li>
<li>DWORD FileSize 文件大小，以字节为单位。</li>
<li>WORD Reserved1； BMP 文件保留字，必须为 0</li>
<li>WORD Reserved2； BMP 文件保留字，必须为 0</li>
<li>DWORD ImageOﬀset； 图像数据的起始位置相对于 文件开头的偏移量</li>
</ul>
</li>
<li>图像信息<ul>
<li>DWORD HeaderSize； BMP 图像信息大小 (40 或 12)， 以字节为单位</li>
<li>DWORD ImageWidth； BMP 图像宽度，以像素为单位</li>
<li>DWORD ImageHeight； BMP 图像高度，以像素为单位</li>
<li>WORD EquipLevel； 目标设备的级别 (色彩平面数)， 固定为 1</li>
<li>WORD BitsPerPixel； 每个像素所需要的位数，1，4， 8，24</li>
<li>DWORD EncodeType； 压 缩 类 型， 0(不 压 缩)， 1(BI RLE8)，2(BI RLE4)</li>
<li>DWORD ImageSize； BMP 位图大小，以字节为单位</li>
</ul>
</li>
<li>调色板数据<ul>
<li>BYTE rgbBlue； 蓝色的亮度值，此值 0-255</li>
<li>BYTE rgbGreen； 绿色的亮度值。此值 0-255</li>
<li>BYTE rgbRed； 红色的亮度值。此值 0-255</li>
<li>BYTE rgbReserved； 此值必须 0</li>
</ul>
</li>
<li>调色板数据紧跟在图像信息之后，用于说明位图颜色，每个结构体是由四个域组成</li>
<li>若不是真彩色图像，表项的个数与图像使用的颜色个数相同。每一项代表了一个颜色</li>
<li>若图像为真彩色，每个像素所占的位数 BitPerPixel=24 则图像数据每三个字节代表了一个像素，这三个字节分别定义了 RGB 的亮度，所以省去了调色板</li>
<li>图像数据<ul>
<li>当 biBitCount=1 时，图像数据中的每个字节代表 8 个 像素</li>
<li>当 biBitCount=4 时，图像数据中的每个字节代表 2 个 像素</li>
<li>当 biBitCount=8 时，图像数据中的每个字节代表 1 个 像素</li>
<li>当 biBitCount=24 时，图像数据中的每 3 个字节代 表 1 个像素</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h1 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h1><ul>
<li>图像增强技术分为两大类：<strong>频域处理法</strong>和<strong>空域处理法</strong><ul>
<li>频域处理采用修改<strong>傅里叶变换</strong>的方式来实现对图像的增强</li>
<li>空域处理法是直接对<strong>图像中的像素</strong>进行处理，基本上是以灰度映射变换为基础的</li>
</ul>
</li>
</ul>
<h2 id="空域处理法"><a href="#空域处理法" class="headerlink" title="空域处理法"></a>空域处理法</h2><h3 id="用图像对比度处理方法增强图像"><a href="#用图像对比度处理方法增强图像" class="headerlink" title="用图像对比度处理方法增强图像"></a>用图像对比度处理方法增强图像</h3><p>由于图像的亮度不足或者非线性会造成的图像对比度不足。可以用重新分配像素幅值的方法来改善图像的对比度<br>基本思想是，输入图像 $f(x)$ 与输出图像 $g(x)$ 对应像素点坐标不变，但是灰度值是 $f(x,y)$ 按照某一个函数 $Φ(x,y)$ 所做的映射<br>根据 Φ(x,y) 的类型我们可以进行讨论：</p>
<ul>
<li>线性变化： $Φ(f) = αf+β$：可以将某个区间的灰度值进行处理。可以进行二值化处理（非 0 即 255）。或单独拉伸高（低）灰度区。或进行反色</li>
<li>分段线性变换</li>
<li>非线性变换：大部分像素处于低灰度区时进行对数变换；大部分像素处于高灰度区时进行指数变换</li>
<li>灰度切分</li>
</ul>
<p>总的来说可以将 $Φ(x,y)$ 归为一个幂次变换 $y=cx^{r}+b$</p>
<ul>
<li>当 r = 1 时函数为线性变换</li>
<li>当 r &lt; 1 时变换曲线在正比函数上方。此时扩展低灰度级，压缩高灰度级，使图像变亮。这一点与对数变换十分相似。</li>
<li>当 r &gt; 0 时，变换函数曲线在正比函数下方。此时扩展高灰度级，压缩低灰度级，使图像变暗。</li>
</ul>
<h3 id="用直方图修改技术进行图像增强"><a href="#用直方图修改技术进行图像增强" class="headerlink" title="用直方图修改技术进行图像增强"></a>用直方图修改技术进行图像增强</h3><h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><ul>
<li><p>直方图（Histogram） ：灰度直方图是灰度级的函数，它表示图像中具有某种灰度级的像素的个数，反映了图像中每种灰度出现的频率， 灰度直方图的横坐标是灰度级，纵坐标是该灰度级出现的频度，它是图像最基本的统计特征。</p>
</li>
<li><p>直方图的性质：</p>
<ul>
<li>直方图仅保留了图像中各个像素灰度的出现次数，而未反应某一像素灰度所在的位置，只包含了某一灰度的出现概率而丢失了位置信息</li>
<li>任一幅图像，都能惟一地确定出一幅与它对应的直方图</li>
<li>一张图的子分割图直方图之和等于总的直方图</li>
</ul>
</li>
<li>直方图的计算：设图像中某种灰度 $f<em>{j}$ 的像素数为 $n</em>{j}$，$n$ 是图像中像素的总数，则灰度级 $f_{j}$ 所对应的频数为：</li>
</ul>
<script type="math/tex; mode=display">P_{f}(f_{j}) = \frac{n_{j}}{n}, j = 0,1,2,...,l-1</script><ul>
<li>具体算法<ol>
<li>建立一个数组具有 l(如，256) 个元素，每个元素的初始值为 0</li>
<li>从图像中逐点取灰度值 $f(x,y)$ 若 $f(x,y) = k$ 则令 <code>l[k] += 1</code></li>
<li>求频数，<code>b[k] = (float)l[k]/像素总数</code></li>
<li>画出直方图</li>
</ol>
</li>
</ul>
<p>用横坐标表示灰度级，纵坐标表示频数，就可以看出图像中灰度的分布情况</p>
<h4 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h4><p>直方图反映了图像中各灰度的含量，它并不反映图像的空间位置信息，只展示具有一定灰度级的像素的数目或频数，通过对图像对应的直方图进行改变可以改善图像的质量</p>
<ul>
<li>直方图均衡化的基本算法<ol>
<li>求出图像中所包含的灰度级 $f_{j}$ ,可以定为 0 ~ L-1,(0 ~ 255)</li>
<li>统计各灰度级的像素数目 $n_{j} (j=0,1,2,…L-1)$</li>
<li>计算图像直方图 $ P<em>{f}(f</em>{j}) = \frac{n_{j}}{n}$</li>
<li>计算累计分布函数 $C(f) = \sum<em>{j=0}^{k} p</em>{f}(f_{i}), j=0,1,2,..,L-1$</li>
<li>用转换函数计算映射后输出的灰度级 $g_{i} ( i=0,1,2,…P-1)$<ul>
<li>要进行直方图均衡化处理的转换函数为：$g = [g<em>{max} - g</em>{min}]C(f) +g<em>{min} $。 $g</em>{max}$ , $g_{min}$ 分别为输出图像的最大和最小灰度级， $C(f)$为输入图像的累积分布函数。</li>
</ul>
</li>
<li>统计映射后各灰度级的像素数目 $n_{i} (i=0,1,..,P-1)$</li>
<li>计算输出图像的直方图 $P<em>{g}(g</em>{i}) = \frac{n_{i}}{n} (i=0,1,2,..,P-1)$</li>
<li>用 $f<em>{i}$ 和 $g</em>{i}$ 的映射关系，修改原始图像的灰度级，获得新的输出图像</li>
</ol>
</li>
</ul>
<p><img src="http://app.starxy.cc:8877/6a/cb07c4fea5deded0b5416d9be47c7cd8689d93.png" alt="直方图均衡化"></p>
<h4 id="直方图规定化"><a href="#直方图规定化" class="headerlink" title="直方图规定化"></a>直方图规定化</h4><p>变换直方图使之具有特定图像。也称作直方图匹配<br>基本思想：选择性的增强某个范围内的对比度<br>关键步骤：建立新旧直方图/灰度概率密度函数 p(s) 和 p(u) 之间的联系</p>
<h3 id="图像平滑处理-——-消除高频噪声的增强算法"><a href="#图像平滑处理-——-消除高频噪声的增强算法" class="headerlink" title="图像平滑处理 —— 消除高频噪声的增强算法"></a>图像平滑处理 —— 消除高频噪声的增强算法</h3><h4 id="图像间运算"><a href="#图像间运算" class="headerlink" title="图像间运算"></a>图像间运算</h4><p>有些图像增强技术是靠对多幅图进行图像间的运算而实现的。图像间可以进行算术运算和逻辑运算，逻辑运算只用于二值图像，所以，我们只讨论算术运算，常用的算术运算有：</p>
<ul>
<li>加法：主要用于图像平均以减少噪声；</li>
<li>减法：主要用于医学图像中的成像；</li>
<li>乘法和除法：主要用于校正由于照明或传感器的非均匀性造成的图像灰度阴影。</li>
</ul>
<p>在图像处理中，图像运算最经常的应用是图像平均，一般用于图像采集中去除噪声。<br>设有 1 幅含有噪声的图 $g(x,y)$ ，它由原图像信息 $f(x,y)$ 和噪声信息 $e(x,y)$ 叠加而成，即：</p>
<script type="math/tex; mode=display">g(x,y) = f(x,y)+e(x,y)</script><p>如果各点的噪声是互不相关的 (随机的)，且均值为 0，我们就可以对相同的目标采集多幅图像 $ {g_{i}(x,y), i=1,2,3…M } $ ，并将它们相加来消除噪声，即</p>
<script type="math/tex; mode=display">\bar g(x,y) = \frac{1}{M} \sum_{i=1}^{M}g_{i}(x,y)</script><p>则可以证明它的期望值为：</p>
<script type="math/tex; mode=display">E (\bar g(x,y))  = f(x,y)</script><h4 id="邻域平均法"><a href="#邻域平均法" class="headerlink" title="邻域平均法"></a>邻域平均法</h4><p>邻域平均法是简单的<strong>空域</strong>处理方法。这种方法的基本思想是用几个像素灰度的平均来代替一个像素原来的灰度值，实现图像的平滑。<br>常见的方法有</p>
<h5 id="简单平均法"><a href="#简单平均法" class="headerlink" title="简单平均法"></a>简单平均法</h5><p>设图像像素的灰度值为 f(x,y) 取其为中心的 M*N 大小的窗口，用窗口各像素灰度平均值代替 f(x,y)<br>此种方法 M N 值要求不能过大，一个是影响速度，一个是过大后影响图像清晰度</p>
<h5 id="阈值平均法"><a href="#阈值平均法" class="headerlink" title="阈值平均法"></a>阈值平均法</h5><p>对图像像素点 f(x,y) 同样取其为中心的 M*N 大小的窗口计算平均值，但是根据计算的平均值与原像素点值进行对比，超过一定阈值再进行替换</p>
<h5 id="K——近邻平均法"><a href="#K——近邻平均法" class="headerlink" title="K——近邻平均法"></a>K——近邻平均法</h5><p>在一个 M*N 的窗口中，属于同一物体的像素，它们的灰度变化应是渐变的或者说是相关的。因此，窗口中心像素的灰度值可用窗口内与中心点灰度最接近的 K 个邻点的平均灰度来代替。工作步骤如下：</p>
<ol>
<li>读取窗口内各对应像素的灰度值；</li>
<li>从这些灰度值中挑出与中心点灰度最接近的 K 个邻点 (不包括中心点)；</li>
<li>求出这 K 个邻点的均值，并代替原中心点的值；</li>
</ol>
<h5 id="邻域加权平均法"><a href="#邻域加权平均法" class="headerlink" title="邻域加权平均法"></a>邻域加权平均法</h5><p>邻域加权平均法和前面几种平均法一样，都属于空域滤波增强算法，它是利用模板卷积的方法实现对原图的滤波，可表示为：</p>
<p>$g(x,y) = W \dot f(u,v) $ 其中，$W$ 称为模板</p>
<script type="math/tex; mode=display">
W  = \frac{1}{21}
 \\begin{bmatrix}
   1 & 4 & 1 \\\\
   4 & 1 & 4 \\\\
   1 & 4 & 1
  \\end{bmatrix}</script><p>基本步骤：</p>
<ol>
<li>将模板在图中漫游，并将模板中心与图中某像素点重合</li>
<li>将模板上系数与模板下对应像素的灰度值相乘；</li>
<li>将所有乘积相加，并除以系数总和</li>
<li>用所得结果代替原中心点的值</li>
</ol>
<h5 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h5><p>以上使用的邻域平均法属于低通滤波 (模板系数都为正数) 的处理方法，它在抑制噪声的同时使图像变得模糊，即图像的细节 (例如边缘信息) 被削弱，<strong>如果既要抑制噪声又要保持细节可以使用中值滤波</strong>，工作步骤如下：</p>
<ol>
<li>将窗口在图中移动；</li>
<li>读取窗口内各对应像素的灰度值；</li>
<li>将这些灰度值从小到大排成 1 列；</li>
<li>找出这些值里排在中间的 1 个；</li>
<li>将这个中间值赋给对应窗口中心位置的像素。</li>
</ol>
<h3 id="图像锐化处理——消除低频噪声的增强算法"><a href="#图像锐化处理——消除低频噪声的增强算法" class="headerlink" title="图像锐化处理——消除低频噪声的增强算法"></a>图像锐化处理——消除低频噪声的增强算法</h3><p>与平滑处理类似，锐化处理也可以利用模板卷积的方法实现。所不同的是滤波器模板的中心系数应为正数，而周围的系数为负，例如</p>
<script type="math/tex; mode=display">
W  = \frac{1}{21}
 \\begin{bmatrix}
   -1 & -1 & -1 \\\\
   -1 & 8 & -1 \\\\
   -1 & -1 & -1
  \\end{bmatrix}</script><p>这样，所有的系数之和为 0，当这样的模板与图像中灰度值不变或变化很小的区域时，其输出为 0 或很小，即原图像中变化小 (低频) 的分量被去除了。<br>经过卷积运算后，输出图中的灰度值有正有负，而在图像处理中我们只考虑正的灰度值，所以还需将输出图像的灰度值变换到正常范围 <code>[0,L-1]</code> 之内。</p>
<h3 id="锐化滤波"><a href="#锐化滤波" class="headerlink" title="锐化滤波"></a>锐化滤波</h3><p>锐化滤波的目的是：突出图像中的细节或增强被模糊了的细节<br><img src="http://app.starxy.cc:8877/1c/41138970a1eb06ccfe553fdd901815c3773501.png" alt="梯度.png"><br><img src="http://app.starxy.cc:8877/e4/c25a21b7072201bfdda47f6fbbe192595f6f52.png" alt="梯度（二维离散）.png"></p>
<p>锐化算子是基于图像微分/梯度定义的模板，通过与图像的模板卷积运算实现对图像边缘的增强或提取（因此也称为边缘检测算子）<br>不同的锐化算子使用了<strong>不同的近似梯度计算</strong>方法</p>
<ul>
<li>Prewitt 算子</li>
<li>Sobel 算子</li>
<li>Roberts 算子</li>
</ul>
<p><img src="http://app.starxy.cc:8877/69/110a969f0f69d4ef7d74559ed8d37898f5246e.png" alt="Prewitt.png"><br><img src="http://app.starxy.cc:8877/de/c400d07b880bb0dc5bbe3bd79ae882b2666acf.png" alt="sobel.png"></p>
<p>拉普拉斯算子</p>
<ul>
<li>二阶差分算子</li>
<li>模版元素和等于 1 ： 能保留原能保留原图中平滑区域的灰度，适合于去噪、保留原图低频部分的增强</li>
<li>模板元素和等于 0 ：原图中的平滑区域灰度在滤波后接近 0，边缘等⾼频部分则被突出，适合边缘提取、抑制原图低频部分的增强</li>
</ul>
<h2 id="频域变换"><a href="#频域变换" class="headerlink" title="频域变换"></a>频域变换</h2><h3 id="图像频率的基本概念"><a href="#图像频率的基本概念" class="headerlink" title="图像频率的基本概念"></a>图像频率的基本概念</h3><p>灰度或色彩的空间分布形成的<strong>边缘、轮廓、结构</strong>使我们能够感知到图像中的物体<br><strong>灰度变化较大</strong>的地方会生成边缘<br>图像的空间频率反映了图象的灰度或色彩随着空间坐标变化而变化的快慢</p>
<ul>
<li>变化平缓的图像频带窄、变化剧烈的图像频带宽</li>
<li>图像中的高频部分：边缘和细节部分</li>
<li>图像中的低频部分：背景和缓慢变化的部分</li>
</ul>
<p>通过频域变换可以将图像中的不同对象按照高频和低频分量进行分别处理</p>
<ul>
<li>比如通过增强高频分量来提取图像的边缘信息</li>
</ul>
<p><img src="http://app.starxy.cc:8877/ef/1845ba6532b6d4f9b5f3c0b09259f6dc5fd34c.png" alt="图像频域变化的一般形式"></p>
<p>在频率/变换域中进行图像处理的优势</p>
<ul>
<li>可以使某些特征更突出，便于分析和识别</li>
<li>可以更有效地表示图像，实现压缩和编码</li>
<li>可以简化计算，如通过频率域的乘积实现空间域的卷积</li>
</ul>
<h3 id="图像的滤波与卷积"><a href="#图像的滤波与卷积" class="headerlink" title="图像的滤波与卷积"></a>图像的滤波与卷积</h3><blockquote>
<p>关于图像与波的关系可以看 <a href="http://www.ruanyifeng.com/blog/2017/12/image-and-wave-filters.html" target="_blank" rel="noopener">阮一峰大大的文章</a></p>
</blockquote>
<p>所谓图像滤波在频域就是仅保留指定频段的信号，而去除其余信号；低通、高通、带通滤波</p>
<p>根据线性系统理论，用一个二维函数对另一个二维函数（图像）进行滤波的结果是这两个二维函数的卷积</p>
<h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><p>Fourier 变换频谱图上的每个点和空间域的原始空间图像之间没有一一对应的关系<br>Fourier 变换具有如下性质：</p>
<ul>
<li>平移不变性</li>
<li>旋转不变性</li>
<li>卷积定理<ul>
<li>f 与 g 的乘积等于 F 与 G 的卷积</li>
<li>f 与 g 的卷积等于 F 与 G 的乘积</li>
<li>时域卷积 = 频域相乘</li>
</ul>
</li>
</ul>
<p>快速傅里叶变换：空间域的卷积可以通过傅里叶频率域的乘积实现，从而降低计算的复杂度</p>
<h3 id="离散余弦变换"><a href="#离散余弦变换" class="headerlink" title="离散余弦变换"></a>离散余弦变换</h3><ul>
<li>离散余弦变换 (Discrete Cosine Transform-简称 DCT) 是 Fourier 变换的一种特殊情况</li>
<li>其变换核是为实数的余弦函数，因而 DCT 的计算速度比 DFT 快得多</li>
<li>DCT 计算复杂性适中，又具有可分离特性，还有快速算法，所以被广泛地用在图象数据压缩编码算法中，如 JPEG、MPEG-1、MPEG-2 及 H.261 等压缩编码国际标准都采用了离散余弦变换编码算法</li>
</ul>
<p>傅里叶变换中间亮四周暗。DCT 变换左上亮右下黑</p>
<h3 id="频域增强"><a href="#频域增强" class="headerlink" title="频域增强"></a>频域增强</h3><p>频域滤波的基本步骤</p>
<ol>
<li>计算所需增强图的傅立叶变换</li>
<li>将其与根据需要设计的转移函数相乘</li>
<li>再将结果傅立叶反变换，以得到增强的图</li>
</ol>
<p>频域增强方法：低通高通带通</p>
<h4 id="低通滤波"><a href="#低通滤波" class="headerlink" title="低通滤波"></a>低通滤波</h4><p>用于减弱图像中高频的部分：部分图像的边缘和噪声</p>
<p>理想低通滤波器</p>
<ul>
<li>以截止频率 $D_{0}$ 为半径的圆内的所有频率都能无损通过，而在截频之外的频率分量完全被衰减</li>
<li>理想低通滤波器平滑处理过程中会产生较严重的模糊和振铃现象 (Ringing Artifacts)。 $D_{0}$ 越小，这种现象越严重</li>
</ul>
<p>巴特沃兹低通滤波器（最大平坦滤波器）</p>
<ul>
<li>通带和阻带之间有一个平滑的过渡带（把 $H(u,v)$ 下降到某一值的那点定为截止频率 $D_{0}$）</li>
<li>图像模糊程度减少，没有振铃现象。同样的指数低通滤波器、梯形低通滤波器也没有振铃现象</li>
</ul>
<h4 id="高通滤波"><a href="#高通滤波" class="headerlink" title="高通滤波"></a>高通滤波</h4><p>理想高通滤波器</p>
<ul>
<li>理想高通滤波把以 $D_{0}$ 为半径的圆内的频率成分衰减掉</li>
</ul>
<p>巴特沃斯高通滤波处理的结果比用理想高通滤波处理的结果要平滑</p>
<h4 id="带通滤波"><a href="#带通滤波" class="headerlink" title="带通滤波"></a>带通滤波</h4><ul>
<li>带通滤波器允许一定频率范围内的信号通过而阻止其它频率范围内的信号通过</li>
<li>带阻滤波器阻止一定频率范围内的信号通过而允许其它频率范围内的信号通过</li>
</ul>
<h4 id="同态滤波"><a href="#同态滤波" class="headerlink" title="同态滤波"></a>同态滤波</h4><p>同态滤波的基本思想是将入射光（照明分量）和反射光（反射分量）分开，然后分别对它们施加不同的影响，从而使反映物体性质的反射光得到增强，而压缩不必要的入射光成分</p>
<h2 id="彩色图像增强"><a href="#彩色图像增强" class="headerlink" title="彩色图像增强"></a>彩色图像增强</h2><p>伪彩色增强的基本方法：</p>
<ul>
<li>实质是一个着色的过程</li>
<li>典型方法：亮度划分；将灰度值分割成不同区间，每个区间赋予不同的颜色</li>
</ul>
<p>HSI：色调、饱和度、亮度</p>
<p>真彩色增强的基本方法：</p>
<ul>
<li>将 R、G、B 分量图转化为 H、S、I 分量图</li>
<li>利用对灰度图增强的方法增强 I 分量</li>
<li>再将结果转换为 RGB 图</li>
</ul>
<h1 id="数字图像的几何变换"><a href="#数字图像的几何变换" class="headerlink" title="数字图像的几何变换"></a>数字图像的几何变换</h1><p>数字图像的数学表示：</p>
<ul>
<li>定义域 $\Omega$ 定义了像素点的空间位置，又称为空间域</li>
<li>值域 $G$ 定义了像素的灰度值，又称为灰度域</li>
</ul>
<p>图像的几何变换在空间域上进行计算，可以看成将物体在图像内进行移动、变形。可以改变图像中各物体之间的空间关系<br>图像的几何变换包括两部分。</p>
<ul>
<li>空间变换<ul>
<li>描述每个像素如何从其初始位置移动到终止位置</li>
<li>$g(x,y) = f(x’,y’) = f[a(x,y), b(x,y)]$</li>
</ul>
</li>
<li>灰度插值<ul>
<li>应对非整数坐标系。用来处理当输入像素坐标为某值，进行几何变换后像素的坐标值可能为非整数。灰度插值的目的就是要计算这些像素的灰度值</li>
</ul>
</li>
</ul>
<p>几何变换不改变像素值，而是改变像素所在的位置</p>
<h2 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h2><p>假设 $X$ 和 $Y$ 方向上的平移量分别为 $x<em>{0}$ $y</em>{0}$ 则</p>
<script type="math/tex; mode=display">a(x,y) = x + x_{0}, b(x,y) = y+y_{0}</script><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>假设 $X$ 和 $Y$ 方向上的缩放比例分别为 $c$ $d$ 则</p>
<script type="math/tex; mode=display">a(x,y) = \frac{x}{c} , b(x,y) = \frac{y}{d}</script><p>由于放大 $c,d &lt; 1$ 算子运算不是一一映射，只是简单的重复放大。因此将产生所谓的方块效应。为了改善这种可视效果，需要进行插值运算。</p>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>图像大小为 M<em>N 的<em>*水平镜像</em></em>公式：</p>
<script type="math/tex; mode=display">
\\begin{cases}
    x' = x \\\\
    y' = -y
\\end{cases}</script><p>平移使坐标为正</p>
<script type="math/tex; mode=display">
\\begin{cases}
    x'' = x' = x \\\\
    y'' = y'+N+1 = N+1-y
\\end{cases}</script><p>图像大小为 M<em>N 的<em>*垂直镜像</em></em>公式：</p>
<script type="math/tex; mode=display">
\\begin{cases}
    x' = -x \\\\
    y' = y
\\end{cases}</script><p>平移使坐标为正</p>
<script type="math/tex; mode=display">
\\begin{cases}
    x'' = x' +M +1 =M+1-x \\\\
    y'' = y = y
\\end{cases}</script><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>假设图像绕原坐标旋转 顺时针旋转 $\theta$ 角度</p>
<script type="math/tex; mode=display">a(x,y) = xcos(\theta) - ysin(\theta)</script><script type="math/tex; mode=display">b(x,y) = xsin(\theta) + ycos(\theta)</script><p>但是经过旋转后的图像会出现两种问题：</p>
<ul>
<li>像素的排列不是完全按照原有的相邻关系</li>
<li>会出现空洞点</li>
</ul>
<p>出现这两种问题的本质是因为：<strong>像素的填充是不连续的</strong>。这种问题可以用<strong>插值</strong>来解决</p>
<h2 id="灰度插值"><a href="#灰度插值" class="headerlink" title="灰度插值"></a>灰度插值</h2><script type="math/tex; mode=display">g(x,y) = f(x',y') = f[a(x,y), b(x,y)]</script><p>$g(x,y)$ 的值一般由<strong>非整数坐标</strong>上的 $f(x,y)$ 的值确定。<br>输入图像中，灰度值仅在整数位置处被定义<br>灰度插值就是要根据 f 中整数位置的灰度值来估算 g 中像素的灰度值<br>如果把几何变换看成是一个从 f 到 g 的映射，则 f 中的一个像素会映射到 g 中的几个像素之间的位置</p>
<h3 id="最近邻插值"><a href="#最近邻插值" class="headerlink" title="最近邻插值"></a>最近邻插值</h3><ul>
<li>最简单的插值方法</li>
<li>选择距离它所映射的位置最近的输入像素的灰度值作为结果</li>
</ul>
<h3 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h3><ul>
<li>对最近邻插值的改进</li>
<li>用线性内插方法，根据点的四个相邻点的灰度值，分别在 $x$ 和 $y$ 方向上进行两次插值，计算出插值点的值</li>
</ul>
<p><img src="http://app.starxy.cc:8877/b2/514307db8c38c1966488e33b4eaea385f6c424.png" alt="双线性插值 1"><br><img src="http://app.starxy.cc:8877/aa/6622d44bf3eaf1bf14b602e387cb1760ff02ec.png" alt="双线性插值 2"><br><img src="http://app.starxy.cc:8877/0e/e7fde362ea2353047ad67f19097177113062a6.png" alt="双线性插值 3"></p>
<h3 id="双三次插值"><a href="#双三次插值" class="headerlink" title="双三次插值"></a>双三次插值</h3><h1 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a>图像压缩</h1><p>图像压缩的可能性：数据中存在冗余或不相干的信息</p>
<p>数据冗余的不同类型：</p>
<ul>
<li>编码冗余</li>
<li>空间和时间冗余</li>
<li>心理视觉冗余（即不相关信息）</li>
</ul>
<h2 id="编码冗余"><a href="#编码冗余" class="headerlink" title="编码冗余"></a>编码冗余</h2><p>码本：用来表达一定量的信息或一组事件所需的一系列符号（如字母、数字等）<br>码字：对每个信息或事件所赋的码符号序列；每个码字里的符号个数，称为码字的长度（码长）<br>编码：建立码本以及表达数据的过程<br>自然码：对单个信息（如灰度级）赋的码是从 $2^{m}$ 个 $m$ 比特的<strong>二元码</strong>中选出的一个；对出现概率不同的各灰度级都赋予<strong>相同长度（定长）</strong>的比特数<br>图像中灰度级出现的概率:</p>
<script type="math/tex; mode=display">p_{s}(s_{k}) = \frac{n_{k}}{n},k=0,1,2,...,L-1</script><p>其中 $n<em>{k}$ 为灰度等级 $s</em>{k}$ 出现的次数， $n$ 为像素总数<br>图像编码的平均比特数：</p>
<script type="math/tex; mode=display">\bar L = \sum_{k=0}^{L-1}l(s_{k})p_{s}(s_{k})</script><p>其中 $l(s<em>{k})$ 表示灰度级 $s</em>{k}$ 使用的比特数<br>如何编码才能减小平均比特数：</p>
<ul>
<li>用较少的比特数表示出现概率较大的灰度级</li>
<li>用较多的比特数表示出现概率较小的灰度级</li>
</ul>
<p>自然码的平均比特数一般高于上述编码方案，所以存在编码冗余</p>
<h2 id="空间、时间和心理冗余"><a href="#空间、时间和心理冗余" class="headerlink" title="空间、时间和心理冗余"></a>空间、时间和心理冗余</h2><p>空间冗余：一幅图像的像素间存在相关性，相关性越强空间冗余度越高<br>时间冗余：视频（图像序列）中连续帧之间的相关性很强<br>心理视觉冗余：因人而异，与人类观察图像的方式有关，消除非重点信息；消除心理视觉冗余的损失是不可逆的</p>
<h2 id="压缩图像质量的评价"><a href="#压缩图像质量的评价" class="headerlink" title="压缩图像质量的评价"></a>压缩图像质量的评价</h2><ul>
<li>图像保真度<ul>
<li>描述解码图像相对于原始图像的偏离程度</li>
<li>对信息损失的测度</li>
</ul>
</li>
<li>客观保真度准则<ul>
<li>用编码输入图与解码输出图的某个确定函数表示损失的信息量，便于计算或测量</li>
</ul>
</li>
<li>主管保真度准则<ul>
<li>主观测量图像的质量，因人而异，应用不方便</li>
</ul>
</li>
</ul>
<p>图像熵：<br>设图像像素灰度级的集合为 $\{r<em>{1},r</em>{2},…,r<em>{N} \}$ 其对应的概率分别为 $P</em>{1},P<em>{2},…,P</em>{N}$ 则图像熵的定义为：</p>
<script type="math/tex; mode=display">H = - \sum_{i=1}^{N}P_{i}\log_{2}P_{i}</script><p>单位为 比特/字符</p>
<ul>
<li>反映了图像的<strong>平均自信息量</strong></li>
<li>单值（全黑全白）图像的熵为 0</li>
<li>一半黑一半白的图像熵为 1</li>
</ul>
<p>平均码字长度</p>
<script type="math/tex; mode=display">\bar N = \sum_{i=1}^{N}\beta_{i}P_{i}</script><p>其中 $\beta<em>{i}$ 为灰度级 $r</em>{i}$ 所对应的码字长度</p>
<ul>
<li>度量某种特定的编码性能</li>
<li>单位为 比特/字符 越小说明效率越高</li>
</ul>
<h2 id="图像压缩的分类"><a href="#图像压缩的分类" class="headerlink" title="图像压缩的分类"></a>图像压缩的分类</h2><p>根据解压缩后图像和原始图像是否有偏差进行分类：</p>
<ul>
<li>无损压缩<ul>
<li>霍夫曼编码</li>
<li>行程编码</li>
<li>算术编码</li>
</ul>
</li>
<li>有损编码<ul>
<li>预测编码</li>
<li>变换编码</li>
<li>其他编码</li>
</ul>
</li>
</ul>
<p>依据压缩过程中编码是否利用信息的语义进行分类：</p>
<ul>
<li>熵编码<ul>
<li>泛指那些不考虑被压缩信息的性质的无损编码</li>
<li>基于平均信息量的技术把所有的数据当作比特序列，而不根据压缩信息的类型优化压缩</li>
<li>包括霍夫曼编码、行程编码等</li>
</ul>
</li>
<li>源编码<ul>
<li>利用信号原数据在时间域和频率域中的相关性和冗余进行压缩的有语义编码</li>
<li>源编码比严格的平均信息量编码的压缩率更高</li>
<li>包括预测编码、变换编码等</li>
</ul>
</li>
<li>混合编码<ul>
<li>即“熵编码 + 源编码”</li>
<li>大多数压缩标准都采用混合编码的方法进行数据压缩，一般是先利用源编码进行有损压缩，再利用熵编码做进一步的无损压缩</li>
</ul>
</li>
</ul>
<h3 id="霍夫曼编码"><a href="#霍夫曼编码" class="headerlink" title="霍夫曼编码"></a>霍夫曼编码</h3><p>基础理论：变长最佳编码原理：出现概率大的给短码字，出现概率小的给长码字；这样的话平均码字会最小<br>步骤：</p>
<ol>
<li>首先求出图像中灰度分布的灰度直方图</li>
<li>根据该直方图，对其按照分布概率从大到小的顺序进行排列</li>
<li>每一次从中选择出两个概率为最小的节点相加，形成一个新的节点，重复这一步骤，直到只有一个节点，构造一个称为“Huffman 树”的二叉树</li>
<li>对这个二叉树进行编码，就获得了 Huffman 编码码字</li>
</ol>
<p>相应的可以发现：<br>对全局进行求灰度直方图求霍夫曼编码会因为灰度过多导致编码越来越长；<br>对全局进行分块然后对每块进行处理会更好；<br>考虑到传输和存储编码的代价需要在分块和压缩效率之间找到一个平衡</p>
<h3 id="行程编码"><a href="#行程编码" class="headerlink" title="行程编码"></a>行程编码</h3><p>形成编码（Run-Length Coding，RLC）是通过<strong>改变图片的描述方式</strong>实现图像的压缩<br>基本思想是将图像中灰度值相同的相邻像素用一个计数值（行程长度）和该灰度值来代替<br>应用：适用于二值化的图像；传真件中白色较多而黑色较少<br>二维转一维扫描方法：逐行逐列或者蛇形扫描<br>对于有大面积色块的图像，压缩效果很好；<br>对于复杂的图像，压缩效果不好，最坏情况下 （图像中每两个相邻点的颜色都不同），会使数据量加倍，所以现在单纯采用行程编码的压缩算法用得并不多</p>
<h3 id="预测编码"><a href="#预测编码" class="headerlink" title="预测编码"></a>预测编码</h3><p>基本思想：图像相邻像素间存在很强的相关性，通过观察其相邻像素取值，可预测一像素的大概情况；</p>
<p>无损预测：不对误差进行处理，无损传输<br>有损预测：对误差进行再量化用更少的位数来表达误差达到压缩的目的</p>
<h3 id="变换编码"><a href="#变换编码" class="headerlink" title="变换编码"></a>变换编码</h3><p>基本原理：利用正交变换的能量集中性,即图像经正交变换后能量集中在低频部分,高频部分能量较少,可以用较少的位数来表达.对变换系数进行再量化,可以达到压缩目的<br>常用的正交变换：DFT、DCT、小波变换</p>
<h2 id="静止图像压缩标准"><a href="#静止图像压缩标准" class="headerlink" title="静止图像压缩标准"></a>静止图像压缩标准</h2><h3 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h3><p>适用于静止灰度图或彩色图的压缩<br>包含了三种编码系统：</p>
<ul>
<li>基于 DCT 的有损压缩编码基本系统，可用于绝大多数压缩应用场合</li>
<li>用于高压缩比、高精度或渐进重建应用的扩展编码系统</li>
<li>基于预测编码中 DPCM 方法的无损系统，用于无失真应用场合</li>
</ul>
<p>JPEG 编码步骤：分块；DCT；量化；Z 形扫描（DCT 后左上角较大右下角较小）；行程编码；霍夫曼编码</p>
<h3 id="JPEG2000"><a href="#JPEG2000" class="headerlink" title="JPEG2000"></a>JPEG2000</h3><p>采用小波子带编码作为核心编码方案</p>
<p>相对于 JPEG：</p>
<ul>
<li>能提高对图像的压缩质量，尤其是低码率时的压缩质量</li>
<li>根据图像质量、视觉感受和分辨率进行渐进传输</li>
<li>对码流的随机存取和处理</li>
<li>开放结构、向下兼容等</li>
</ul>
<h2 id="序列图像压缩标准"><a href="#序列图像压缩标准" class="headerlink" title="序列图像压缩标准"></a>序列图像压缩标准</h2><ul>
<li>H.26X 系列<ul>
<li>H.261 最初标准</li>
<li>H.263:比 H.261 有重大改进</li>
<li>H.264:目前编码最复杂但效果最好的标准</li>
</ul>
</li>
<li>MPEG-X 系列<ul>
<li>MPEG1:最初的 VCD 标准</li>
<li>MPEG2:DVD 和数字电视</li>
<li>MPEG4:低码率活动图像压缩</li>
<li>MPEG7:高效活动图像压缩</li>
</ul>
</li>
<li>VAS<ul>
<li>中国的音视频编解码标准</li>
</ul>
</li>
</ul>
<h1 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h1><p>将图像分成各具特色的区域，并提取出感兴趣的目标的技术和过程</p>
<ul>
<li>特性：灰度、颜色、纹理等</li>
<li>目标：对应单个或者多个区域，反映了感兴趣对象在图像中的位置和范围</li>
</ul>
<p>基本策略：利用图像中像素灰度值（色彩/纹理）的两个特征：相似性、不连续性</p>
<p>像素的相似性：</p>
<ul>
<li>空间上相邻</li>
<li>灰度（色彩/纹理）接近</li>
<li>相似像素构成的区域轮廓就是对象的边</li>
</ul>
<p>像素的不连续性：</p>
<ul>
<li>空间上相邻</li>
<li>灰度（色彩/纹理）相差明显</li>
<li>检测图像的不连续像素，找到点、线、边、再根据边确定区域</li>
</ul>
<p>图像分隔方法的分类：</p>
<ul>
<li>基于阈值的分割<ul>
<li>通过合适的灰度（色彩/纹理）阈值对不同物体进行分割</li>
</ul>
</li>
<li>基于边缘的分割<br>  – 先确定边缘像素，并把它们连接在一起，以构成所需的边界</li>
<li>基于区域的分割<ul>
<li>把各像素划归到各个物体或区域中</li>
</ul>
</li>
<li>基于运动的分割<ul>
<li>通过视频物体运动进行分割</li>
</ul>
</li>
</ul>
<h2 id="基于阈值的分割"><a href="#基于阈值的分割" class="headerlink" title="基于阈值的分割"></a>基于阈值的分割</h2><p>假设：图像由目标和背景两部分组成；目标和背景有不同的灰度级<br>步骤：确定合适的分割阈值；将像素值和分割阈值进行比较以划分像素为目的目标或背景<br>阈值分割的关键是选取<strong>合适的阈值</strong></p>
<p>直方图阈值分割法：</p>
<ul>
<li>基于如下的图像模型：<ul>
<li>图像中的背景和目标均为单峰灰度分布</li>
<li>目标或背景内部相邻像素的灰度值高度相关</li>
<li>目标和背景交界处两边的像素灰度值相差很大</li>
</ul>
</li>
<li>上世纪 60 年代中期，Prewitt 提出直方图双峰法<ul>
<li>如果灰度级直方图呈明显的双峰状，则选取两峰之间的谷底所对应的灰度级作为阈值</li>
<li>直方图双峰法不适合直方图中双峰差别很大或双峰间的谷比较宽广而平坦的图像，以及单峰直方图的情况</li>
</ul>
</li>
<li>可以通过直方图变换改善图像的直方图以方便阈值分割</li>
</ul>
<p>类间方差阈值分割法：</p>
<ul>
<li>又称作最大类间方差法</li>
<li>基本思想：一幅图像被一个阈值分为目标与背景两部分，当两部分之间的方差最大时，分割效果最好</li>
</ul>
<p>全局阈值 vs.自适应阈值：</p>
<ul>
<li>全局阈值<ul>
<li>整幅图像使用同一个固定阈值</li>
<li>不能合理地处理目标和背景在不同区域的变化</li>
</ul>
</li>
<li>自适应阈值<ul>
<li>根据图像的局部特征分别采用不同的阈值进行分割</li>
</ul>
</li>
</ul>
<h2 id="基于边缘的分割"><a href="#基于边缘的分割" class="headerlink" title="基于边缘的分割"></a>基于边缘的分割</h2><p>边缘可定义为在局部区域内图象的差别，表现为图象上的不连续性 (如灰度级的突变、纹理结构的突变、颜色的变化)</p>
<p>不连续性检测的类型：</p>
<ul>
<li>点检测</li>
<li>线检测</li>
<li>边缘检测</li>
</ul>
<p>边界的确定：可以通过先检测不连续的点，然后再将这些点连城边界<br>不连续的检测可以通过模板卷积来实现</p>
<p>线检测：</p>
<p>四种在水平垂直 45 度方向上的模板同时对同一图像进行卷积<br>最终结果是四种相应结果中的最大值</p>
<h3 id="Hough-变换直线检测"><a href="#Hough-变换直线检测" class="headerlink" title="Hough 变换直线检测"></a>Hough 变换直线检测</h3><p>直线的数学模型：点线对偶性模型</p>
<p>参数空间（斜率-截距）中的一条直线对应的是图像空间中的一个点<br>图像空间中共线的一组点对应参数空间中的是一簇相交于同一点的直线</p>
<p>基本思想：</p>
<ul>
<li>给定图像空间中的一些边缘点，连接这些点的直线（如果存在的话）在参数（斜率-截距）空间中将形成一簇直线的交点</li>
<li>参数空间中，过某个交点的直线越多，表明图像空间中越多的边缘点位于该交点所对应的直线上</li>
</ul>
<p>Hough（哈夫）变换就是把在图像空间中的线检测问题转换到参数空间中对峰值点的检测问题，通过在参数空间中进行简单的累加统计完成检测任务</p>
<h3 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h3><p>由图像增强中锐化一节可以得知，图像的边缘存在于不同灰度值的相邻区域之间。<br>边缘是灰度值不连续的体现</p>
<p>边缘的导数特征，在图像的边缘处：</p>
<ul>
<li>一阶导数的幅值取得局部最大值</li>
<li>二阶导数过零点附近的符号反映了边缘附近的像素在明区域还是暗区域</li>
<li>利用一阶二阶导数特点可以检测边缘</li>
</ul>
<p>边缘检测所用的是图像的梯度算子，梯度的计算方法在图像增强锐化一节中已经给出<br>常用的梯度算子为 Roberts 算子、Prewitt 算子、Sobel 算子<br>Sobel 算子比较常用，它先进行加权然后再计算分差，其效果比其他两种算子要好</p>
<p>图像的拉普拉斯算子为图像的二阶导数<br>该算子是一个标量而非矢量，具有旋转不变性即各向同性的性质</p>
<ul>
<li>优点<ul>
<li>无方向性算子，只需一个模板，计算量小</li>
<li>过零点可以对边缘进行精确定位</li>
<li>过零点两侧的符号可以辅助判断像素在边缘的暗侧还是亮侧</li>
</ul>
</li>
<li>缺点<ul>
<li>卷积结果的幅值产生双边缘</li>
<li>不能检测边缘的方向</li>
<li>对噪音非常敏感（如对孤立点响应很强）</li>
</ul>
</li>
</ul>
<p>如何降低拉普拉斯算法对噪音的敏感性：</p>
<ul>
<li>先对图像进行平滑处理然后再计算二阶导数</li>
<li>LoG:Laplacian of Gaussian</li>
</ul>
<h2 id="二值图像的形态学处理"><a href="#二值图像的形态学处理" class="headerlink" title="二值图像的形态学处理"></a>二值图像的形态学处理</h2><p>分割后的结果常常以二值图像给出，即前景目标像素为 1 而背景像素用 0 表示<br>对这类二值图像可以通过<strong>数学形态学</strong>的方法进行后处理</p>
<ul>
<li>数学形态学是分析几何形状和结构的数学方法，是建立在集合代数基础上，用集合论方法定量描述几何结构的科学</li>
<li>一般以 A 表示二值图像，B 表示结构元素</li>
<li>基本形态学算子包括<strong>膨胀和腐蚀</strong></li>
</ul>
<p><img src="http://app.starxy.cc:8877/4e/e7fa435fba52e62da194799f0c413fdce702f6.png" alt="腐蚀.png"><br><img src="http://app.starxy.cc:8877/66/d7702dc56988ab87c18278b8db13a8c9c05b7a.png" alt="膨胀.png"><br><img src="http://app.starxy.cc:8877/91/f704eaa4f5c16b3abbb26c08613e08361a5a35.png" alt="组合运算"></p>
<h1 id="图像分析"><a href="#图像分析" class="headerlink" title="图像分析"></a>图像分析</h1><p>图像分析的主要任务：</p>
<ul>
<li>图像分割将目标从图像中分割出来，而分析的主要任务则是根据分割结果进一步<strong>从图像中获得目标特征的量值</strong></li>
<li>图像分割之后，为了进一步对图像作分析和识别，就必须通过对图像中的物体 (目标) 作<strong>定性或定量的分析</strong>来作出正确的结论</li>
</ul>
<p>图像分析建立在图像物体（目标）描述的基础上<br>图像描述即是指用一组数量或符号 (描述子) 来表征图像中被描述物体的某些特征<br>图像分析的两个关键问题：</p>
<ul>
<li>选用什么特征来描述目标</li>
<li>如何精确地测量这些特征</li>
</ul>
<p>图像的特征用于区分图像的最基本属性：</p>
<ul>
<li>自然特征：颜色亮度等</li>
<li>人工特征：通知直方图等</li>
</ul>
<p>图像特征一般具有以下几个特点</p>
<ul>
<li>可区分性</li>
<li>可靠性</li>
<li>独立性</li>
<li>数量要少</li>
</ul>
<p>图像中的区域（目标）可以用其内部像素的特征或者其边界像素的特征表示</p>
<ul>
<li><strong>内部像素特征</strong>刻画区域的反射性质，如灰度、颜 色、纹理等</li>
<li><strong>边界像素特征</strong>刻画区域的形状等</li>
</ul>
<p>选定了表达方法，还需要对目标进行描述，使计算机能充分利用所能获得的分割结果</p>
<ul>
<li>表达是<strong>直接具体地</strong>表示目标。好的表达方法应具有节省存储空间、易于特征计算等优点</li>
<li>描述是<strong>较抽象地</strong>表示目标。好的描述应在尽可能区别不同目标的基础上对目标的尺度、平移、旋转等不敏感</li>
</ul>
<h2 id="图像的表达方法"><a href="#图像的表达方法" class="headerlink" title="图像的表达方法"></a>图像的表达方法</h2><ul>
<li>图像<strong>边界</strong>的表达<ul>
<li>链码（Chain Code）</li>
<li>边界段</li>
<li>多边形</li>
<li>标记</li>
</ul>
</li>
<li>图像<strong>区域</strong>的表达<ul>
<li>骨架</li>
</ul>
</li>
</ul>
<h3 id="链码"><a href="#链码" class="headerlink" title="链码"></a>链码</h3><p>链码是对<strong>边界点</strong>的一种表示方法<br>链码对边界的表达式<strong>逐点</strong>进行的<br>利用一系列具有特定长度和方向的相连的直线段来表示目标的边界</p>
<ul>
<li>每个线段的长度固定，而方向数目取为有限<ul>
<li>只有四个方向的为 4-链码，八个方向的为 8-链码</li>
</ul>
</li>
<li>边界的起点用（绝对）坐标表示，而其余点只用方向来代表偏移量</li>
</ul>
<p>链码的计算方法：</p>
<ul>
<li>给边界上的每一个线段一个方向编码</li>
<li>从起点开始，沿边界按 4-链码或 8-链码编码，直到起点被重新碰到，结束一个对象的编码</li>
</ul>
<p><img src="http://app.starxy.cc:8877/4e/72de017c0243c13301fddeb738a5abda7fe27b.png" alt="链码编码"></p>
<p>链码表达可以大大减少边界表示所需的数据量</p>
<ul>
<li>表示 1 个方向数比表示 1 个坐标值所需的比特数少</li>
<li>对每 1 个点又只需 1 个方向数就可以代替 2 个坐标值</li>
</ul>
<p>直接对分割所得的目标边界进行链码编码存在两个潜在问题</p>
<ul>
<li>链码相当长</li>
<li>噪声等干扰会导致小的边界变化，而使链码发生与目标整体形状无关的较大变动</li>
</ul>
<p>改进方案</p>
<ul>
<li>对原边界以较大的网格重新采样，并把与原边界点最接近的大网格点定为新的边界点</li>
<li>这样获得的新边界具有较少的边界点，而且其形状受噪声等干扰的影响也较小</li>
</ul>
<p>起点归一化：对于相同的边界，选择不同的起点会产生不同的编码结果。为此需要同一个起点</p>
<ul>
<li>给定一个从任意点开始而产生的链码，把它看作一个由各个方向数构成的自然数</li>
<li>将这些方向数依一个方向循环以使它们所构成的自然数的值最小，将这样转换后所对应的链码起点作为这个边界的归一化链码的起点</li>
</ul>
<p>旋转归一化：边界旋转后编码也会不同</p>
<ul>
<li>用链码的一阶差分来重新构造一个新序列</li>
<li>首先将最右一个方向数循环到左边<ul>
<li>然后用后一个元素减去前一个元素，如果结果是负数，则按 4 或者 8 取模（分别对应 4-链码或 8-链码）</li>
<li>新序列表示原链码各段之间的方向变化</li>
</ul>
</li>
<li>该序列称为<strong>差分码</strong>，不会因目标旋转而改变</li>
</ul>
<h3 id="边界段"><a href="#边界段" class="headerlink" title="边界段"></a>边界段</h3><p>边界段（Boundary Segments）方法把<strong>边界分解成若干段</strong>分别表示。可减少边界的复杂度，并简化描述过程</p>
<p>一般借助<strong>凸包</strong>的概念将边界分为若干段<br><img src="http://app.starxy.cc:8877/fd/683ed5a12d71e8db5c75d2d713784fc541a6fc.png" alt="凸包"></p>
<ul>
<li>跟踪 H 的边界，每个进入 D 或从 D 出去的点就是一个分段点</li>
<li>当把 S 的边界分解为边界段时，能分开 D 的各部分的点就是合适的边界分段点</li>
<li>这些分段点可借助 D 来唯一确定，且不受目标区域的尺度和方向影响</li>
</ul>
<h3 id="多边形近似"><a href="#多边形近似" class="headerlink" title="多边形近似"></a>多边形近似</h3><p>目标区域的边界很容易受噪音、采样等的影响，而产生很多较小的不规则处<br>这些不规则处常对链码和边界段表达产生较明显得干扰<br>多边形近似（PolygonApproximations）就是用多边形去近似逼近边界，以提高抗干扰性、节省表达所需数据量</p>
<p>常用的多边形表达方法</p>
<ul>
<li>基于收缩的最小周长多边形法</li>
<li>基于聚合 (Merge) 的最小均方差线段逼近法</li>
<li>基于分裂 (Split) 的最小均方差线段逼近法</li>
</ul>
<h3 id="标记法"><a href="#标记法" class="headerlink" title="标记法"></a>标记法</h3><p>标记（Signature）法的基本思想是把2-D的边界用1-D的较易描述的函数形式来表达</p>
<h3 id="区域的骨架表达"><a href="#区域的骨架表达" class="headerlink" title="区域的骨架表达"></a>区域的骨架表达</h3><h2 id="图像的描述方法"><a href="#图像的描述方法" class="headerlink" title="图像的描述方法"></a>图像的描述方法</h2><ul>
<li>边界描述：<ul>
<li>简单描述</li>
<li>形状数</li>
<li>傅立叶描述</li>
</ul>
</li>
<li>区域描述：<ul>
<li>简单描述</li>
<li>拓扑描述</li>
<li>纹理描述</li>
<li>不变矩</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark 学习笔记</title>
    <url>/2018/05/15/Spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Spark-概述"><a href="#Spark-概述" class="headerlink" title="Spark 概述"></a>Spark 概述</h1><blockquote>
<p>本文为在学习厦门大学 MOOC 课程《大数据技术原理与应用》时所记重点笔记，顺序按照课程顺序<br>文章内大部分图片和文字描述均来自该课程，侵删</p>
</blockquote>
<h2 id="Spark-与-Scala"><a href="#Spark-与-Scala" class="headerlink" title="Spark 与 Scala"></a>Spark 与 Scala</h2><p>Spark 为一门用 Scala 开发的大数据框架，成名类似于 Hadoop，Spark 在 2014 年刷新了 Hadoop 之前保持的 1TB 数据基准排序的记录，到现在成为了一个基于内存计算的大数据并行计算框架，可用于构建大型的、低延迟的数据分析应用。</p>
<p>Spark 特点</p>
<ul>
<li>运行速度快：使用 DAG 执行引擎来进行作业调度，效率要比 MapReduce 高效的多</li>
<li>容易使用：支持多种编程方式</li>
<li>通用性：Spark 提供了完整而强大的技术栈<ul>
<li>内存计算 Spark Core</li>
<li>包括 SQL 查询分析 Spark SQL</li>
<li>流式计算 Spark Streaming</li>
<li>机器学习 Spark MLib</li>
<li>图算法 GraphX</li>
</ul>
</li>
<li>运行模式多样</li>
</ul>
<p>Scala 语言是一门现代的多范式编程语言（比如函数式、面向对象、过程式），平滑的集成了面向对象和函数式编程两种风格可以运行于 Java 平台（JVM）之上。</p>
<p>Scala 特性</p>
<ul>
<li>强大的并发性，支持函数式编程，支持分布式系统</li>
<li>语法简洁，提供优雅 API</li>
<li>Scala 兼容 Java，且能融入到 Hadoop 生态圈</li>
<li>提供 REPL（交互式解释器），提高开发效率</li>
</ul>
<h2 id="Spark-与-Hadoop-的对比"><a href="#Spark-与-Hadoop-的对比" class="headerlink" title="Spark 与 Hadoop 的对比"></a>Spark 与 Hadoop 的对比</h2><p>Hadoop 的缺点</p>
<ul>
<li>表达能力有限：不是所有应用都能用 Map 和 Reduce 表达</li>
<li>磁盘 IO 开销较大</li>
<li>延迟高</li>
<li>任务之间衔接涉及到 IO 开销</li>
<li>前一个任务完成前其他任务无法开始。难以胜任复杂、多阶段的任务计算</li>
</ul>
<p>Spark 相比 Hadoop MapReduce 的优点</p>
<ul>
<li>计算模式属于 MapReduce 但提供多种数据集操作类型是编程模型更灵活</li>
<li>Spark 提供内存计算，迭代计算不需要读写磁盘</li>
<li>Spark 基于 DAG 任务调度机制</li>
</ul>
<a id="more"></a>
<h1 id="Spark-生态系统"><a href="#Spark-生态系统" class="headerlink" title="Spark 生态系统"></a>Spark 生态系统</h1><p>在实际应用中，大数据处理包括三个类型：</p>
<ul>
<li>复杂的批量处理，数十分钟到几小时。MapReduce</li>
<li>基于历史数据的交互式查询，数十秒到数分钟。Cloudera Impala</li>
<li>基于实时数据流处理，毫秒到数秒之间。Storm</li>
</ul>
<p>由此带来的问题：</p>
<ul>
<li>不同场景输入输出数据无法做到无缝共享</li>
<li>不同软件需要不同的开发和维护，较高的使用成本</li>
<li>比较难对同一个集群中的各个系统进行统一的资源协调分配</li>
</ul>
<p>Spark 设计遵循“一个软件栈满足不同应用场景”的理念，逐渐形成了一整套生态系统<br>Spark 可以部署在 YARN 之上，提供一站式的数据解决方案<br>Spark 所提供的生态系统足以应对上述三种场景<br>Spark 生态系统已成为 BDAS（伯克利大学数据实验室软件栈） 的重要组成<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEly1frcdm5xejsj310a0hwgq1.jpg" alt="BDAS 架构"><br><img src="http://ww1.sinaimg.cn/large/006Ka4GEly1frcdo2ki92j319s0dm7b9.jpg" alt="Spark 组件应用场景"></p>
<h1 id="Spark-运行架构"><a href="#Spark-运行架构" class="headerlink" title="Spark 运行架构"></a>Spark 运行架构</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>弹性分布式数据集（RDD，Resillient Distributed Dataset）是分布式内存的抽象概念，提供了一种高度受限的共享内存模型</li>
<li>有向无环图（DAG）反映了 RDD 之间的依赖关系</li>
<li>Executor，是运行在工作节点的一个进程，负责运行 Task</li>
<li>Application，用户编写的 Spark 应用程序</li>
<li>Task，运行在 Executor 之上的工作单元</li>
<li>Job，一般一个 Application 包含多个 Job，一个 Job 包含多个 RDD 及作用于相应 RDD 上的各种操作</li>
<li>Stage，是 Job 调用的基本单位，一个 Job 会分为多组 Task，每组 Task 被称为 Stage，或者称为 TaskSet，代表了一组关联的、相互之间没有 Shuffle 依赖关系的任务组成的任务集</li>
</ul>
<h2 id="Spark-基本架构设计"><a href="#Spark-基本架构设计" class="headerlink" title="Spark 基本架构设计"></a>Spark 基本架构设计</h2><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEly1frcdwx95t6j31an0j0q76.jpg" alt="Spark 基本架构图"></p>
<ul>
<li>Cluster Manager，集群资源管理器，负责对整个 Spark 应用程序来进行集群资源管理分配和调度。可以自带或 Mesos 或 YARN</li>
<li>Work Node，运行作业任务的工作节点</li>
<li>Driver Program，每个应用的任务控制节点，生成 DAG，对 DAG 进行分成多个阶段，对阶段进行拆解，吧任务分给相关具体的 Executor 执行都是由 Driver 执行</li>
<li>Executor，负责每个工作节点上具体任务执行的进程</li>
</ul>
<p>该架构设计与 Hadoop MapReduce 相比优点</p>
<ul>
<li>利用多线程来执行具体的任务减少任务的启动开销</li>
<li>Executor 中有一个 BlockManager，会将内存和磁盘共同视为存储设备，有效减少 IO 开销</li>
</ul>
<h2 id="Spark-中各种概念之间的相互关系"><a href="#Spark-中各种概念之间的相互关系" class="headerlink" title="Spark 中各种概念之间的相互关系"></a>Spark 中各种概念之间的相互关系</h2><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEly1frce8kgonhj31780fedke.jpg" alt="Spark 中各种概念之间的相互关系"><br><img src="http://ww1.sinaimg.cn/large/006Ka4GEly1frce9w876sj31cx0f3gs2.jpg" alt="Spark 中各种概念之间的相互关系"></p>
<h2 id="Spark-运行基本流程"><a href="#Spark-运行基本流程" class="headerlink" title="Spark 运行基本流程"></a>Spark 运行基本流程</h2><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEly1frcedfda71j30vl0k242k.jpg" alt="Spark 运行基本流程"></p>
<ol>
<li>为应用构建起基本的运行环境，即由 Driver 创建一个 SparkContext 进行资源的申请、任务的分配和监控</li>
<li>资源管理器为 Executor 分配资源，并启动 Executor 进程，进程会汇报资源的使用情况</li>
<li>SparkContext 根据 RDD 的依赖关系构建 DAG 图，DAG 图提交给 DAG Scheduler 解析成 Stage，然后吧一个个 TaskSet 提交给底层调度器 Task Scheduler 处理；Executor 主动向 SparkContext 申请 Task，Task Scheduler 将 Task 发放给 Executor 运行并提供应用程序代码</li>
<li>Task 在 Executor 上运行把执行结果反馈给 TaskScheduler，然后反馈给 DAGScheduler，运行完毕后写入数据并释放所有资源</li>
</ol>
<h2 id="Spark-运行架构特点"><a href="#Spark-运行架构特点" class="headerlink" title="Spark 运行架构特点"></a>Spark 运行架构特点</h2><ul>
<li>每个 AppIication 都有自己专属的 Executor 进程，并且该进程在 AppIication 运行期间一直驻留。Executor 进程以多线程的方式运行 Task</li>
<li>Spark 运行过程与资源管理器无关，只要能够获取 Executor 进程并保持通信即可</li>
<li>Task 采用了数据本地性和推测执行等优化机制</li>
</ul>
<h2 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h2><h3 id="RDD-基本概念"><a href="#RDD-基本概念" class="headerlink" title="RDD 基本概念"></a>RDD 基本概念</h3><p>设计背景：许多迭代式算法（比如机器学习）和交互式数据挖掘工具，共同之处是，不同计算阶段之间会重用中间结果，目前 MapReduce 框架都是吧中间结果写入到磁盘中带来非常大的磁盘 IO 开销和序列化的开销。RDD 就是为了满足这种需求而出现，它提供了一个抽象的数据结构，将应用逻辑表达式进行一些列的转换。不同的 RDD 之间的转换操作形成以依赖关系（DAG 图），可以实现管道化，一个 RDD 的结果可以作为下一个 RDD 的输入，避免中间数据存储</p>
<p>RDD 概念：一个 RDD 就是一个分布式对象集合，本质上是一个只读的分区记录集合，毎个 RDO 可分成多个分区，毎个分区就是一个数据集片段，并且一个 RDD 的不同分区可以被保存到集群中不同的节点上，从而可以在集群中的不同节点上进行并行计算。<br>RDD 提供了一种高度受限的内存共享模型，即 RDD 是只读的记录分区的集合，不能直接修改，只能基于稳定的物理存储中的数据集创建 RDD，或者通过在其他 RDD 上执行确定的转换操作（如 map、join、group by）而创建得到新的 RDD</p>
<p>RDD 提供了两种操作来支持常见的数据运算：</p>
<ul>
<li>转换（Transformation）：转换接口非常简单，类似 map、filter 这种粗粒度的数据转换，而不能对某个数据项进行修改（不适合网页爬虫）</li>
<li>动作（Action）</li>
</ul>
<h3 id="RDD-典型执行过程"><a href="#RDD-典型执行过程" class="headerlink" title="RDD 典型执行过程"></a>RDD 典型执行过程</h3><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEly1frcxa5tsg1j317l0cuwh5.jpg" alt="RDD 执行实例"></p>
<ol>
<li>RDD 读入外部数据源进行创建数据，根据数据大小创建不同分区，不同分区放到不同数据节点上</li>
<li>RDD 经过一系列转换操作，每一次都会产生不同的 RDD 供给下一个转换使用，不计算结果，只记录轨迹</li>
<li>最后一个 RDD 经过动作操作计算产生结果</li>
<li>这一系列处理成为一个 Lineage（血缘关系）反映了不同 RDD 之间的依赖关系，即 DAG 拓扑排序的结果</li>
</ol>
<h3 id="RDD-特性"><a href="#RDD-特性" class="headerlink" title="RDD 特性"></a>RDD 特性</h3><ul>
<li>高效的容错性。容错机制：血缘关系的设计方式使得 RDD 天生具有容错性，当一个 RDD 分区出现错误，只需要往上层节点追溯并再次转换即可</li>
<li>中间结果持久化到内存：数据在内存中的多个 RDD 操作之间进行传递，降低磁盘开销</li>
<li>存放的数据可以是 Java 对象，避免了不必要的对象序列化和反序列化</li>
</ul>
<h3 id="RDD-的依赖关系和运行过程"><a href="#RDD-的依赖关系和运行过程" class="headerlink" title="RDD 的依赖关系和运行过程"></a>RDD 的依赖关系和运行过程</h3><p>Spark 通过分析各个 RDD 的依赖关系生成了 DAG 图再通过分析各个 RDD 中的分区之间的依赖关系（宽依赖、窄依赖）来决定如何划分 Stage</p>
<ul>
<li>窄依赖：表现为一个父 RDD 的分区对应于一个子 RDD 的分区或者多个父 RDD 的分区对应于一个子 RDD 的分区</li>
<li>宽依赖：一个父 RDD 的一个分区对应于一个子 RDD 的多个分区</li>
</ul>
<p>具体划分方法</p>
<ul>
<li>在 DAG 中进行反向解析，遇到宽依赖就断开（存在 Shuffle）</li>
<li>遇到窄依赖酒把当前的 RDD 加入 Stage</li>
<li>将窄依赖尽量划分在同一个 Stage 中，可以实现流水线计算从而使得数据可以直接在内存中进行交换</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006Ka4GEly1frcxvq743rj30yx0llafm.jpg" alt="Stage 划分过程"><br>如图可以看出，RDD A 和 B 之间是宽依赖，所以 A 被单独划分为一个 Stage 1，CDFE 之间都是窄依赖，可以直接划分成一个 Stage 2 构成流水化作业，之后 B 到 G 是窄依赖，F 到 G 为宽依赖，所以最后根据划分方法总共划分为三个 Stage</p>
<p>Stage 的类型</p>
<ul>
<li>ShuffleMapStage：不是最终的 Stage，在他之后还有其他的 Stage，所以它的输出一定要经过 Shuffle 过程，并作为后续 Stage 的输入。这种 Stage 是以 Shuffle 为输出边界（存在宽依赖断开），其输入边界可以是从外部获取数据，也可以使另一个 ShuffleMapStage 的输出其输出可以使另一个 Stage 的开始</li>
<li>ResultStage：没有输出，而是直接产生结果或存储。zhezhongStage 是直接输出结果，其输入边界可以是从外部获取数据也可以是另一个 ShuffleMapStage 的输出。一个 Job 必定会有至少一个 ResultStage</li>
</ul>
<h1 id="Spark-SQL"><a href="#Spark-SQL" class="headerlink" title="Spark SQL"></a>Spark SQL</h1><p>SparkSQL 在 Hive 兼容层面仅依赖 HiveQL 解析、Hive 元数据也就是说，从 HQL 被解析成抽象语法树（AST) 起，就全部由 SparkSQL 接管了。SparkSQL 执行计划生成和优化都由 Catalyst(函数式关系查询优化框架）负责</p>
<p>SparkSQL 增加了 SchemaRDD(即带有 Schema 信息的 RDD) 使用户可以在 SparkSQL 中执行 SQL 语句</p>
<p>备注：SchemaRDD 在后来的 SparkSQL 版本中演化为 DataFrame</p>
<h1 id="Spark-部署和应用"><a href="#Spark-部署和应用" class="headerlink" title="Spark 部署和应用"></a>Spark 部署和应用</h1><p>Spark 三种部署方式</p>
<ul>
<li>Standalone：自带的资源管理框架。类似 MapReduce1.0，slot 为资源分配单位，但是不进行 map slot 和 reduce slot 切分</li>
<li>Spark on Mesos：Spark 和 Mesos 相互支持比较充分</li>
<li>Spark on YARN</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006Ka4GEly1frcyrrx9lyj316d0jaad5.jpg" alt="统一部署"></p>
<p>不同计算框架统一运行在YARN中的优势：</p>
<ul>
<li>计算资源按需伸缩</li>
<li>不用付在应用混搭、集群利用率高</li>
<li>共享底层存储，避免数据库跨集群迁移</li>
</ul>
<h1 id="Spark-编程实践"><a href="#Spark-编程实践" class="headerlink" title="Spark 编程实践"></a>Spark 编程实践</h1><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEly1frcyyh7pufj311i0djjyy.jpg" alt="ActionAPI"><br><img src="http://ww1.sinaimg.cn/large/006Ka4GEly1frcyz34w18j318p0egaji.jpg" alt="TransformationAPI"></p>
]]></content>
      <categories>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据相关学习笔记</title>
    <url>/2018/05/15/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="大数据技术原理与应用学习笔记"><a href="#大数据技术原理与应用学习笔记" class="headerlink" title="大数据技术原理与应用学习笔记"></a>大数据技术原理与应用学习笔记</h1><blockquote>
<p>本文为在学习厦门大学 MOOC 课程《大数据技术原理与应用》时所记重点笔记，顺序按照课程顺序<br>文章内大部分图片和文字描述均来自该课程，侵删</p>
</blockquote>
<h1 id="大数据概述"><a href="#大数据概述" class="headerlink" title="大数据概述"></a>大数据概述</h1><h2 id="大数据时代"><a href="#大数据时代" class="headerlink" title="大数据时代"></a>大数据时代</h2><p>第三次信息浪潮是大数据、物联网、云计算三种新技术为代表的<br>这次信息浪潮的基础技术支撑是：存储、计算、网络<br>数据产生方式也经历了三个阶段的发展：</p>
<ul>
<li>运营师系统阶段——由运营式系统生成</li>
<li>用户原创内容阶段——博客微博</li>
<li>感知式系统阶段——物联网时代各种传感器设备</li>
</ul>
<h2 id="大数据概念"><a href="#大数据概念" class="headerlink" title="大数据概念"></a>大数据概念</h2><p>大数据的 4V：</p>
<ul>
<li>Volume 大量化：数据爆炸</li>
<li>Veloity 多样化：结构化数据（关系数据库）10%、非结构化数据（图形图像）90%</li>
<li>Variety 快速化：从数据生成到消耗，时间窗口非常小，可用于生成决策的时间非常短</li>
<li>Value 价值密度低</li>
</ul>
<p>到现在科学理论的四种范式：实验、理论、计算、数据驱动<br>思维方式发生了三种改变：全样而非抽样、效率而非精确（因为全样分析误差不会被放大导致不需要追求精度、追求时效性）、相关而非因果</p>
<h2 id="大数据的关键技术"><a href="#大数据的关键技术" class="headerlink" title="大数据的关键技术"></a>大数据的关键技术</h2><p>大数据的技术层次：数据采集、数据存储与管理、数据处理与分析、数据隐私与安全<br>数据存储与管理、数据处理与分析代表了最核心的两大技术：分布式存储和分布式处理</p>
<p>分布式数据库：BigTable<br>分布式文件系统：GFS<br>分布式并行处理技术：MapReduce </p>
<p>计算模式：</p>
<ul>
<li>批处理计算：同时处理大量数据进行批量处理，不可能实现秒级相应与交互式计算——MapReduce（典型代表）、Spark（实时性比 MapReduce 更好，能更好的执行迭代运算)</li>
<li>流计算：专门对流数据进行的计算，实现秒级响应——S4、Storm、Flume</li>
<li>图计算：高效处理图结构——Google Pregel</li>
<li>查询分析计算：交互式查询分析高时效性——Dremel、Hive、Cassandra </li>
</ul>
<h2 id="大数据与云计算、物联网"><a href="#大数据与云计算、物联网" class="headerlink" title="大数据与云计算、物联网"></a>大数据与云计算、物联网</h2><p>一切云计算解决了两个问题：分布式存储和分布式处理<br>云计算典型特征：虚拟化、多租户<br>云计算分类：共有云、混合云、私有云<br>IaaS：基础设施即服务、PaaS：平台即服务、SaaS：软件即服务</p>
<p>物联网（IoT：The Internet of Things）万物互联</p>
<ul>
<li>应用层：物联网应用</li>
<li>处理层：业务支撑平台。数据处理</li>
<li>网络层：电信网、互联网等等，起到了信息传输的作用</li>
<li>感知层：传感器、RFID网络。数据收集</li>
</ul>
<p>关键技术：</p>
<ul>
<li>识别技术</li>
<li>感知技术</li>
</ul>
<h1 id="大数据处理架构"><a href="#大数据处理架构" class="headerlink" title="大数据处理架构"></a>大数据处理架构</h1><h2 id="Hadoop-概述"><a href="#Hadoop-概述" class="headerlink" title="Hadoop 概述"></a>Hadoop 概述</h2><p>HDFS 是 GFS 的开源实现。<br>Hadoop 把谷歌提出的两大框架融入到自己平台.<br>具有高可靠性，部分机器故障可继续提供服务（冗余副本机制）<br>高效型<br>可扩展性,可不断在集群中添加机器<br>成本低</p>
<h2 id="Hadoop-项目结构"><a href="#Hadoop-项目结构" class="headerlink" title="Hadoop 项目结构"></a>Hadoop 项目结构</h2><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEly1frc3rl031sj30xv0l3tf5.jpg" alt="Hadoop2.0 项目结构"><br>HDFS：分布式文件系统<br>YARN：资源管理和调度框架。负责调度内存 CPU 带宽等计算资源<br>MapReduce：2.0 以前做实时计算，2.0 以后做离线计算和批处理<br>Tez：运行在 YARN 之上的下一代 Hadoop 查询处理框架。把很多 MapReduce 作业进行分析优化，构成 DAG（保证获得最好的处理效率，分清先后顺序）<br>Sprak：类似于 MapReduce 的通用并行框架。但是 Spark 是基于内存的运算，而 MapReduce 是基于磁盘的<br>Hive：Hadoop 上的数据仓库，专门用于企业决策分析，可以把大量的历史数据存在数据仓库中来进行多维度分析。用 SQL 语句书写，但是会转换成 MapReduce 作业来执行<br>Pig：流数据处理，轻量级分析、基于 Hadoop 的大规模数据分析平台，提供类似 SQL 的查询语言 Pig Latin<br>Oozie：作业调度系统<br>ZooKeeper：分布式协调一致性服务，提供分布式锁机群管理<br>HBase：分关系型分布式数据库，面向列存储，执行随即读写和实时应用<br>Flume：日志收集分析框架<br>Sqoop：用于在 Hadoop 与传统数据库之间进行数据传递完成数据导入和导出</p>
<h2 id="Hadoop-集群的部署和使用"><a href="#Hadoop-集群的部署和使用" class="headerlink" title="Hadoop 集群的部署和使用"></a>Hadoop 集群的部署和使用</h2><p>HDFS 两大组件：</p>
<ul>
<li>集群节点：NameNode</li>
<li>数据节点：DataNode</li>
</ul>
<p>一个 NameNode 和多个 DataNode 构成一个分布式文件系统</p>
<p>MapReduce 计算框架两大组件（2.0 以后改用为 YARN，不存在两种 Tracker）：</p>
<ul>
<li>JobTracker：负责对 MapReduce 作业进行管理，将一个作业拆分成多个小作业分发</li>
<li>TaskTracker：部署在不同的机器上，负责跟踪执行部分小作业</li>
</ul>
<p>SecondaryNameNode 冷备份</p>
<a id="more"></a>
<h1 id="分布式文件系统-HDFS"><a href="#分布式文件系统-HDFS" class="headerlink" title="分布式文件系统 HDFS"></a>分布式文件系统 HDFS</h1><p>HDFS 是 Hadoop 平台的分布式文件系统，是用来解决大数据的两大核心问题中的海量数据分布式存储问题<br>本章就是着重介绍了 HDFS 的体系结构、存储原理以及读写过程。</p>
<h2 id="HDFS-简介"><a href="#HDFS-简介" class="headerlink" title="HDFS 简介"></a>HDFS 简介</h2><p>对于分布式文件系统（DFS），在集群中把一个整个的大文件分布的存储到多台机器上面去。采用主从架构，其中一个为主节点来存储元数据，其余为从节点存储相关数据。</p>
<p>HDFS 实现目标：</p>
<ul>
<li>兼容廉价硬件设备</li>
<li>实现流数据读写</li>
<li>支持大数据集：小则几百 M 多则几 TB</li>
<li>支持简单的文件模型：对文件简化，快速批量处理数据，只允许追加不允许修改</li>
<li>强大的跨平台特性</li>
</ul>
<p>HDFS 局限性</p>
<ul>
<li>不适合低延迟数据访问：大量数据不能满足实时处理需求（HBase 补足）</li>
<li>无法高效存储大量小文件：元数据中会出现大量索引结构拖垮性能</li>
<li>不支持多用户写入及任意修改文件</li>
</ul>
<h2 id="HDFS-相关概念"><a href="#HDFS-相关概念" class="headerlink" title="HDFS 相关概念"></a>HDFS 相关概念</h2><p>块（整个 HDFS 中最核心的概念）</p>
<ul>
<li>与普通 FS 类似用来降低寻址开销，但是 HDFS 中的块默认为 64MB，相比较大</li>
<li>MapReduce 以块为单位执行任务，如果块设置较大，则会导致 MapReduce 只有几个任务在执行，发挥不了分布并行的优势</li>
</ul>
<p>元数据：包括文件是什么，文件被分为多少块，每个快和文件是怎么映射的，每个块存储在哪个服务器上面</p>
<p>名称节点（主节点）：整个 HDFS 的集群管家，存储元数据</p>
<p>名称节点中保存的元数据有两大关键的数据结构</p>
<ul>
<li>FsImage：保存系统文件数以及文件树种所有文件和文件夹的元数据<ul>
<li>文件的复制等级、修改访问时间、访问权限、块大小以及组成文件的块</li>
<li>具体块在哪个节点上不是由 FsImage 维护的，而是在名称节点和数据节点在运行中实时维护信息，在内存中</li>
</ul>
</li>
<li>EditLog：整个运行过程中对数据进行了类似创建删除何种操作</li>
</ul>
<p>每次名称节点启动时，将 FsImage 文件从磁盘加载到内存中去，然后与 EditLog 中合并得到最新的元数据文件，然后替换掉旧版的 FsImage 同时创建一个空的 EditLog。这种添加 EditLog 的目的是 HDFS 非常庞大，运行过程中直接修改大量的 FsImage 会严重拖慢运行效率，而创建一个规模较小的 EditLog 可以优化这个过程。但是在长时间运行中，EditLog 也会不断变大，效率也会变慢，第二名称节点在这时也会发生作用</p>
<p>第二名称节点有冷备份的作用之外还可以对 EditLog 进行处理，具体做法为：第二名称节点定期的和名称节点进行通讯在某个阶段会请求名称节点停止使用 EditLog 文件，然后创建一个 edits.new 文件，暂时替代 EditLog 的作用。第二名称节点通过 HTTP Get 的方式从名称节点上从 FsImage 和 EditLog 下载到本地完成合并工作后将新的 FsImage 发回名称节点然后完成替换，同时将 edits.new 改为 EditLog。这个过程完成了合并工作和冷备份的效果</p>
<p>数据节点：具体存储实际数据</p>
<ul>
<li>名称节点拿到数据目录以后和数据节点通讯。</li>
<li>数据节点中的数据实际的被存储到数据节点本地所在的 Linux 文件系统中</li>
</ul>
<h2 id="HDFS-体系结构"><a href="#HDFS-体系结构" class="headerlink" title="HDFS 体系结构"></a>HDFS 体系结构</h2><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEly1frc55bir8tj313q0l5dnj.jpg" alt="HDFS 主从架构"></p>
<p>HDFS 命名空间：</p>
<ul>
<li>目录+文件+块</li>
<li>且整个 HDFS 只有一个命名空间</li>
<li>/ + 目录名称访问</li>
</ul>
<p>通信协议</p>
<ul>
<li>所有通信协议都是构建在 TCP/IP 基础之上</li>
<li>客户端向名称节点发起 TCP 连接</li>
<li>集群中名称节点和数据节点之间的交互是专门的数据节点协议进行交互的</li>
<li>客户端取数据与数据节点交互为远程调用 RPC 实现</li>
</ul>
<p>HDFS 架构的局限性</p>
<ul>
<li>命名空间限制：命名节点保存在内存中，容纳的对象个数会受限制</li>
<li>性能瓶颈：整个 DFS 吞吐量受单个名称节点吞吐量影响</li>
<li>隔离问题：只有一个命名空间导致不同应用之间无法安全隔离</li>
<li>集群可用性：一旦名称节点故障，整个集群不可用</li>
</ul>
<p>以上为 HDFS 1.0 的缺点，在发展过程中，2.0 会设置两个名称节点进行分区管理并支持热备份</p>
<h2 id="HDFS-存储原理"><a href="#HDFS-存储原理" class="headerlink" title="HDFS 存储原理"></a>HDFS 存储原理</h2><p>数据冗余保存：由于底层构建在廉价计算机上所以容易出故障，所以冗余数据机制要求每个数据都被冗余保存，默认为每个数据块保存 3 份（如果单机配置，冗余只能为 1）。在这种机制之下有几种优点</p>
<ul>
<li>加快数据传输速度，加快并行获取数据的速度</li>
<li>很容易检查错误</li>
<li>保证数据可靠性</li>
</ul>
<p>数据保存策略</p>
<ul>
<li>当发生数据块上传过程时冗余因子为 3，存在两个机架的过程。<ul>
<li>若该过程为内部数据结点发起，则第一副本存放在发起上传的机器，若为外部节点发起则随机挑选一个磁盘和 cpu 性能不满的节点放置第一个副本。</li>
<li>第二副本则会放到和第一副本不同机架的节点上</li>
<li>第三副本则放到和第一副本相同机架的节点上</li>
<li>若冗余因子更大，则剩余副本随机存储</li>
</ul>
</li>
<li>数据读取策略<ul>
<li>基本策略为就近读取</li>
<li>而获取距离依靠 HDFS 提供的一个 API 可以获取数据节点所在机架的 ID，客户端也可以调用来获取自己所属机架的 ID</li>
<li>判断到所有副本所在的数据节点所在的机架如果和客户端机架 ID 一致则选择该节点，否则随机读取</li>
</ul>
</li>
</ul>
<p>数据错误和恢复</p>
<ul>
<li>名称节点出错<ul>
<li>1.0 中第二名称节点做冷备份出错需要时间重启。2.0 之后热备。然后去得备份的 FsImage 和 EditLog</li>
</ul>
</li>
<li>数据节点出错<ul>
<li>在 HDFS 运行过程中数据节点会定期不断的向名称节点发送心跳信息，若周期接受不到信息，则标记该数据节点宕机，且将所有在该机器上的数据通过冗余备份发送到其他可用机器上去（负载不均衡的话也会去调整数据块保存位置）。</li>
</ul>
</li>
<li>数据本身出错<ul>
<li>客户端读取数据会对数据进行校验码校验，校验码在客户端创建数据时生成，当发生数据块校验码不一致时则进行冗余备份的再复制</li>
</ul>
</li>
</ul>
<h2 id="HDFS-数据读写过程"><a href="#HDFS-数据读写过程" class="headerlink" title="HDFS 数据读写过程"></a>HDFS 数据读写过程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Configuration conf = <span class="keyword">new</span> Configuration();   <span class="comment">//环境配置变量</span></span><br><span class="line">        FileSystem fs = FileSystem.get(conf);       <span class="comment">//FS 实例</span></span><br><span class="line">        Path filename = <span class="keyword">new</span> Path(<span class="string">"hdfs://localhost:9000/user/hadoop/test.txt"</span>);</span><br><span class="line">        FSDataInputStream is = fs.open(filename);</span><br><span class="line">        BufferedReader d = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">        String content = d.readLine();        <span class="comment">//读取文件一行</span></span><br><span class="line">        System.out.println(content);</span><br><span class="line">        d.close();        <span class="comment">//关闭文件</span></span><br><span class="line">        fs.close();        <span class="comment">//关闭 hdfs</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码可以访问到 HDFS，然后进行文件的读取。而上述代码的内部实现原理如下</p>
<p>Hadoop 中设置了一个 <code>FileSystem</code> 的通用文件系统抽象基类，可以继承来实现具体子类。例如 HDFS 继承实现的 <code>DistributedFileSystem</code><br><code>FileSystem</code> 提供了几种基本方法，其中包括 <code>open</code>、<code>read</code>、<code>close</code><br><code>open()</code> 返回文件输入流 <code>FSDataInputStream</code>，而对于 HDFS 来说会封装一个 <code>DFSDataInputStream</code> 对象。同理<br><code>create()</code> 返回文件输出流 <code>FSDataOutputStream</code> 而对于 HDFS 来说会封装一个 <code>DFSDataOutputStream</code> 对象</p>
<p>而代码第一行中 conf 环境配置变量的对象的构造方法会加载项目下两个配置文件 core-site.xml 和 hdfs-site.xml 从中获取两个重要参数 fs.defaultFS 用来告诉分布式文件系统的地址，从而知道读取数据的位置，从而 HDFS 内部将 <code>FileSystem</code> 继承为 <code>DistributedFileSystem</code></p>
<p>而对于用户来说，我们只能知道 Hadoop 提供的前面的类和方法如当发起一次数据块信息获取时调用的<code>FSDataInputStream</code>，而实际上直接与 HDFS 接触的是对象实例化时自动继承的<code>DFSDataInputStream</code>，由该对象内部发起远程过程调用来和名称节点沟通；通过该类的<code>ClientProtocol.getBlocklocations()</code>来询问名称节点数据保存在哪个节点，返回该文件的开始一部分根据距离远近排序的位置信息；获取到数据位置之后调用<code>read()</code>方法与数据节点建立连接读取数据；当结束数据在一个节点的数据读取之后关闭连接，继续调用<code>ClientProtocol.getBlocklocations()</code>查找下一个数据块的位置并返回，然后再次执行<code>read()</code>；直到完成所有数据块的读写；之后调用<code>close()</code>关闭输入流<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEly1frcc168maqj311m0jm43c.jpg" alt="HDFS数据读取过程"></p>
<h1 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h1><p>《大数据时代》维克托·迈尔-舍恩伯格</p>
]]></content>
      <tags>
        <tag>大数据</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>ESAIP Linux</title>
    <url>/2017/12/31/ESAIP-Linux/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章主要为 1 月 4 号的 linux 考试所准备的。因为内容不多，打算一个页面写完整个课程内容</p>
</blockquote>
<h1 id="Linux-Basis"><a href="#Linux-Basis" class="headerlink" title="Linux Basis"></a>Linux Basis</h1><!-- - basic command
    - `passwd`
    - `su`
    - sudo
    - id
    - nano
    - vim
    - gedit
    - whatis
    - --help
    - man



# File System

- personal
    - /home/username
- user executables
    - /bin
    - /usr/bin
    - /usr/local/bin
- system executables
    - /sbin
    - /usr/sbin
    - /usr/local/sbin
- configuration
    - /etc
- temporary files
    - /tmp
- core
    - /boot
- server data
    - /var
    - /srv
- server information
    - /proc
    - /sys
- shared libraries
    - /lib
    - /usr/lib
    - /usr/local/lib -->
<h2 id="Structure-of-Disk"><a href="#Structure-of-Disk" class="headerlink" title="Structure of Disk"></a>Structure of Disk</h2><p><code>硬盘的物理结构一般由磁头与碟片、电动机、主控芯片与排线等部件组成；当主电动机带动碟片旋转时，副电动机带动一组磁头到相对应的碟片上并确定读取正面还是反面的碟面，磁头悬浮在碟面上画出一个与碟片同心的圆形轨道（磁轨或称柱面），这时由磁头的磁感线圈感应碟面上的磁性与使用硬盘厂商指定的读取时间或数据间隔定位扇区，从而得到该扇区的数据内容；</code></p>
<p>A hard disk drive platter (or disk) is the circular disk on which magnetic data is stored in a hard disk drive. Platter is the most important thing on HDD.</p>
<ul>
<li>Sector<ul>
<li>a sector is a subdivision of a track on a magnetic disk or optical disc. Each sector stores a fixed amount of user-accessible data, traditionally 512 bytes for hard disk drives (HDDs) and 2048 bytes for CD-ROMs and DVD-ROMs. Newer HDDs use 4096-byte (4 KiB) sectors, which are known as the Advanced Format (AF).The sector is the minimum storage unit of a hard drive.</li>
</ul>
</li>
<li>Track<ul>
<li>The tracks are the thin concentric circular strips of sectors. At least one head is required to read a single track. With respect to disk geometries the terms track and cylinder are closely related. For a single or double sided floppy disk track is the common term; and for more than two heads cylinder is the common term. Strictly speaking a track is a given <code>CH</code> combination consisting of <code>SPT</code> sectors, while a cylinder consists of <code>SPT×H</code> sectors. Tracks are subdivided into blocks (or sectors, pages)</li>
</ul>
</li>
<li>Cylinders<ul>
<li>The concept is concentric, hollow, cylindrical slices through the physical disks (platters), collecting the respective circular tracks aligned through the stack of platters. As usually, cylinder is the minmum unit for File System.</li>
</ul>
</li>
</ul>
<p>In a word, Sector is the minmum unit, many sectors on the same circular make up a track, and many track on different radius make up a platter. Cylinder is a set of Tracks which on different platters but has the same radius.</p>
<h3 id="Partition-table"><a href="#Partition-table" class="headerlink" title="Partition table"></a>Partition table</h3><p>In fact, A new HDD is seems like a Log, you need to cut the log into different section to do next job, and you also remember which section is used for what. Partition table is the same reasion.</p>
<p>A partition is a fixed-size subset of a disk drive which is treated as a unit by the operating system.[1] A partition table is a table maintained on disk by the operating system describing the partitions on that disk.</p>
<p>The terms partition table and partition map are most commonly associated with the MBR partition table of a Master Boot Record (MBR) in IBM PC compatibles, but it may be used generically to refer to other “formats” that divide a disk drive into partitions, such as: GUID Partition Table (GPT)</p>
<p>Partitions can be created, resized, or deleted. This is called disk partitioning. It is usually done during the installation of an operating system, however it is sometimes possible to make changes to the partitions even after the operating system has been installed.</p>
<p>The organization of the partition table in the MBR limits the maximum addressable storage space of a disk to 2 TiB (232 × 512 bytes).</p>
<h4 id="MBR-Master-Boot-Record"><a href="#MBR-Master-Boot-Record" class="headerlink" title="MBR, Master Boot Record"></a>MBR, Master Boot Record</h4><p>A master boot record is a special type of boot sector at the very beginning of partitioned computer mass storage devices with IBM PC-compatible systems and beyond.</p>
<p>The MBR holds the information on how the logical partitions, containing filesystems, are organized on that medium.The MBR also contains executable code to function as a loader for the installed operating system—usually by passing control over to the loader’s second stage, or in conjunction with each partition’s volume boot record (VBR). This MBR code is usually referred to as a boot loader.</p>
<p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1fn2tt4vzh5j30fa0not9b.jpg" alt=""></p>
<p>For one disk :</p>
<ul>
<li>Only four Priamry partition.</li>
<li>Support one Extended partition, a special primary partition type used as a container to hold other partitions</li>
<li>Extended partition can create unlimited logical partition.</li>
</ul>
<a id="more"></a>
<h2 id="File-Nomenclature"><a href="#File-Nomenclature" class="headerlink" title="File Nomenclature"></a>File Nomenclature</h2><p>When using the default Ext2/Ext3 filesystem, the file name length limt is:</p>
<ul>
<li>For single file or directory, the maximum allowable file name is 255 characters.</li>
<li>For the full name, contains the full path name and directory, is 4096 characters.</li>
</ul>
<p>file name restrictions:</p>
<ul>
<li>the rule state that can use any character except <code>/</code></li>
<li>but, As a result of Linux in the text interface under some instruction operation, in general, it is best to avoid some special characters better! For example below these: <code>` * ? &gt; &lt; ; &amp; ! [ ] | \ &#39; &quot; ( ) { }</code>.</li>
</ul>
<p>Especially, if the file name begin with<code>.</code>means it’s a <strong>hidden file or hidden directory</strong>, which do not display by default when showing a directory listing.They are commonly used for storing user preferences or preserving the state of a utility, and are frequently created implicitly by using various utilities.</p>
<h2 id="PATHS-location-within-the-FS"><a href="#PATHS-location-within-the-FS" class="headerlink" title="PATHS, location within the FS"></a>PATHS, location within the FS</h2><ul>
<li>delimited by <code>/</code><ul>
<li><code>.</code> rep current directory</li>
<li><code>..</code> rep lower level directory</li>
<li><code>~</code> rep personal directory (<code>cd ~</code>)</li>
<li>Absolute and relative paths<ul>
<li>Absolute: <code>/usr/sbin/executable.bin</code></li>
<li>Relative: <code>../usr/sbin/executable.bin</code></li>
</ul>
</li>
</ul>
</li>
<li>hidden file begins with <code>.</code></li>
<li><code>$PATH</code> is an file location related environment variable. <ul>
<li><code>echo $PATH</code></li>
</ul>
</li>
<li><code>pwd</code> , show the current absolute path.</li>
<li><code>cd</code> , move command.</li>
</ul>
<h2 id="Different-File-System"><a href="#Different-File-System" class="headerlink" title="Different File System"></a>Different File System</h2><ul>
<li>ext 2<ul>
<li>Fast and requires less writing</li>
<li>No logging</li>
<li>File size: 2TB - score: 32TB</li>
</ul>
</li>
<li>ext 3<ul>
<li>Sucessor and ext 2 compatible</li>
<li>Logged</li>
<li>File size: 2TB - score: 32TB</li>
</ul>
</li>
<li>ext 4<ul>
<li>Sucessor and ext compatible 3</li>
<li>Pre-allocation of a contiguous zone for a file: minimizes fragmentation</li>
<li>Readable from Windows</li>
<li>Size - volume: 1,024 pbbytes</li>
</ul>
</li>
</ul>
<h2 id="File-System-Feature"><a href="#File-System-Feature" class="headerlink" title="File System Feature"></a>File System Feature</h2><p>At first, wee need to talk about some terms,</p>
<ul>
<li>Block<ul>
<li>basic unit of filesystem.</li>
<li>store the real file.</li>
<li>file alaways occupies an integer block<ul>
<li>this will cause a problem called Slack space. </li>
</ul>
</li>
<li>e.x.<ul>
<li>A file of 1000 byte.</li>
<li>if the block size is 4096byte, so the file occupies a block but 3096 byte didn’t used.</li>
</ul>
</li>
</ul>
</li>
<li>superblock<ul>
<li>A segment of metadata describing the filesystem on a block device.</li>
<li>include type, size, state of the filesystem and position of other superblock.</li>
</ul>
</li>
<li>inode<ul>
<li>inode, means index node, is a data structure in a Unix-style filesystem that describes a filesystem object such as a file or a directory.</li>
<li>Each inode stores the attributes and disk block location(s) of the object’s data.Filesystem object attributes may include metadata (times of last change, access, modification), as well as owner and permission data.</li>
</ul>
</li>
</ul>
<p>So, as we know now, each inode and block has the NUMBER, the location(s) in disk, and each file occupy an inode, inode has the metadata and the number of the file’s block. Therefore, if we can find the inode of the file, we will naturally konw the block number of the data in which the file placed, and of course, we can read the actual data of the file.</p>
<h2 id="SWAP"><a href="#SWAP" class="headerlink" title="SWAP"></a>SWAP</h2><h2 id="the-tools-of-handling-File-Systems"><a href="#the-tools-of-handling-File-Systems" class="headerlink" title="the tools of handling File Systems"></a>the tools of handling File Systems</h2><h3 id="Partitioning"><a href="#Partitioning" class="headerlink" title="Partitioning"></a>Partitioning</h3><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p>Start fdisk against your drive as root. In this example we are using <code>/dev/sda</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># fdisk &#x2F;dev&#x2F;sda</span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.27.1).</span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table.</span><br><span class="line">Created a new DOS disklabel with disk identifier 0x32f3d418.</span><br><span class="line"></span><br><span class="line">Command (m for help):</span><br></pre></td></tr></table></figure>
<p>This opens the <em>fdisk</em> dialogue where you can type in commands.</p>
<ul>
<li>Generic<ul>
<li>d   delete a partition</li>
<li>F   list free unpartitioned space</li>
<li>l   list known partition types</li>
<li>n   add a new partition</li>
<li>p   print the partition table</li>
<li>t   change a partition type</li>
<li>v   verify the partition table</li>
<li>i   print information about a partition</li>
</ul>
</li>
<li>Save &amp; Exit<ul>
<li>w   write table to disk and exit</li>
<li>q   quit without saving changes</li>
</ul>
</li>
<li>Create a new label<ul>
<li>g   create a new empty GPT partition table</li>
<li>G   create a new empty SGI (IRIX) partition table</li>
<li>o   create a new empty DOS partition table</li>
<li>s   create a new empty Sun partition table</li>
</ul>
</li>
</ul>
<h4 id="parted"><a href="#parted" class="headerlink" title="parted"></a>parted</h4><p>Parted has two modes: command line and interactive. Parted should always be started with:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># parted device</span><br><span class="line"></span><br><span class="line">GNU Parted 3.2</span><br><span class="line">Using &#x2F;dev&#x2F;sda</span><br><span class="line">Welcome to GNU Parted! Type &#39;help&#39; to view a list of commands.</span><br><span class="line">(parted) help</span><br><span class="line">  align-check TYPE N                        check partition N for TYPE(min|opt) alignment</span><br><span class="line">  help [COMMAND]                           print general help, or help on COMMAND</span><br><span class="line">  mklabel,mktable LABEL-TYPE               create a new disklabel (partition table)</span><br><span class="line">  mkpart PART-TYPE [FS-TYPE] START END     make a partition</span><br><span class="line">  name NUMBER NAME                         name partition NUMBER as NAME</span><br><span class="line">  print [devices|free|list,all|NUMBER]     display the partition table, available devices, free space, all found partitions, or a particular partition</span><br><span class="line">  quit                                     exit program</span><br><span class="line">  rescue START END                         rescue a lost partition near START and END</span><br><span class="line">  resizepart NUMBER END                    resize partition NUMBER</span><br><span class="line">  rm NUMBER                                delete partition NUMBER</span><br><span class="line">  select DEVICE                            choose the device to edit</span><br><span class="line">  disk_set FLAG STATE                      change the FLAG on selected device</span><br><span class="line">  disk_toggle [FLAG]                       toggle the state of FLAG on selected device</span><br><span class="line">  set NUMBER FLAG STATE                    change the FLAG on partition NUMBER</span><br><span class="line">  toggle [NUMBER [FLAG]]                   toggle the state of FLAG on partition NUMBER</span><br><span class="line">  unit UNIT                                set the default unit to UNIT</span><br><span class="line">  version                                  display the version number and copyright information of GNU Parted</span><br><span class="line">(parted)</span><br></pre></td></tr></table></figure>
<h3 id="Create-filesystem-mkfs"><a href="#Create-filesystem-mkfs" class="headerlink" title="Create filesystem - mkfs"></a>Create filesystem - mkfs</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line"> mkfs [options] [-t &lt;type&gt;] [fs-options] &lt;device&gt; [&lt;size&gt;]</span><br><span class="line"></span><br><span class="line">Make a Linux filesystem.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"> -t, --type&#x3D;&lt;type&gt;  filesystem type; when unspecified, ext2 is used</span><br><span class="line">     fs-options     parameters for the real filesystem builder</span><br><span class="line">     &lt;device&gt;       path to the device to be used</span><br><span class="line">     &lt;size&gt;         number of blocks to be used on the device</span><br><span class="line"> -V, --verbose      explain what is being done;</span><br><span class="line">                      specifying -V more than once will cause a dry-run</span><br><span class="line"> -V, --version      display version information and exit;</span><br><span class="line">                      -V as --version must be the only option</span><br><span class="line"> -h, --help         display this help text and exit</span><br></pre></td></tr></table></figure>
<h3 id="Access-the-filesystem"><a href="#Access-the-filesystem" class="headerlink" title="Access the filesystem"></a>Access the filesystem</h3><h4 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h4><ul>
<li>NAME<ul>
<li><code>mount</code> - mount a filesystem</li>
</ul>
</li>
<li>SYNOPSIS<ul>
<li><code>mount [-l|-h|-V]</code></li>
<li><code>mount -a [-fFnrsvw] [-t fstype] [-O optlist]</code></li>
<li><code>mount [-fnrsvw] [-o options] device|dir</code></li>
<li><code>mount [-fnrsvw] [-t fstype] [-o options] device dir</code></li>
</ul>
</li>
<li>OPTONS<ul>
<li>-V, —version<ul>
<li>output version information and exit</li>
</ul>
</li>
<li>-l, —show-labels<ul>
<li>show also filesystem labels</li>
</ul>
</li>
<li>-h, —help<ul>
<li>display this help and exit</li>
</ul>
</li>
<li>-v, —verbose<ul>
<li>say what is being done</li>
</ul>
</li>
<li>-n, —no-mtab<ul>
<li>don’t write to /etc/mtab</li>
</ul>
</li>
<li>-r, —read-only<ul>
<li>mount the filesystem read-only (same as -o ro)</li>
</ul>
</li>
<li>-a, —all<ul>
<li>mount all filesystems mentioned in fstab</li>
</ul>
</li>
</ul>
</li>
<li>EXAMPLE</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount -t udf &#x2F;dev&#x2F;sr0 &#x2F;media&#x2F;dvd        # mount dvd</span><br><span class="line"></span><br><span class="line">mount -o loop -t iso9660 image.iso &#x2F;mnt&#x2F;iso     # mount iso</span><br></pre></td></tr></table></figure>
<h4 id="unmount"><a href="#unmount" class="headerlink" title="unmount"></a>unmount</h4><h4 id="fstab"><a href="#fstab" class="headerlink" title="fstab"></a>fstab</h4><p>A simple /etc/fstab, using kernel name descriptors:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &lt;file system&gt;        &lt;dir&gt;         &lt;type&gt;    &lt;options&gt;             &lt;dump&gt; &lt;pass&gt;</span><br><span class="line">tmpfs                  &#x2F;tmp          tmpfs     nodev,nosuid          0      0</span><br><span class="line">&#x2F;dev&#x2F;sda1              &#x2F;             ext4      defaults,noatime      0      1</span><br><span class="line">&#x2F;dev&#x2F;sda2              none          swap      defaults              0      0</span><br><span class="line">&#x2F;dev&#x2F;sda3              &#x2F;home         ext4      defaults,noatime      0      2</span><br></pre></td></tr></table></figure>
<ul>
<li>a system configuration file</li>
<li>the fstab file can be used to define how disk partitions, various other block devices, or remote filesystems should be mounted into the filesystem.</li>
<li><code>mount</code> command will use fstab</li>
<li>contains six fields.<ul>
<li><code>&lt;file system&gt;</code>: describes the block special device or remote filesystem to be mounted;</li>
<li><code>&lt;dir&gt;</code>: describes the mount directory.</li>
<li><code>&lt;type&gt;</code>: the filesystem type</li>
<li><code>&lt;options&gt;</code>: the associated mount options<ul>
<li><code>auto</code> Can be mounted with the <code>mount -a</code> option.</li>
<li><code>noauto</code> Can only be mounted explicitly (i.e., the -a option will not cause the filesystem to be mounted).</li>
<li><code>exec</code> Permit execution of binaries.</li>
<li><code>noexec</code> Do not permit direct execution of any binaries on the mounted filesystem.</li>
<li><code>ro</code> Mount the filesystem read-only.</li>
<li><code>rw</code> Mount the filesystem read-write.</li>
<li><code>user</code> Allow an ordinary user to mount the filesystem. The name of the mounting user is written to the mtab file so that this same user can unmount the filesystem again. This option implies the options <code>noexec</code>, <code>nosuid</code>, and <code>nodev</code> .</li>
<li><code>nouser</code> Forbid an ordinary user to mount the filesystem.Only root user can mount the filesystem This is the default; it does not imply any other options.</li>
<li><code>users</code> Allow any user to mount and to unmount the filesystem, even when some other ordinary user mounted it. This option implies the options <code>noexec</code>, <code>nosuid</code>, and <code>nodev</code>.</li>
<li><code>owner</code> Allow an ordinary user to mount the filesystem if that user is the owner of the device. This option implies the options <code>nosuid</code> and <code>nodev</code></li>
<li><code>async</code> All I/O to the filesystem should be done asynchronously.</li>
<li><code>sync</code> All I/O to the filesystem should be done synchronously. In the case of media with a limited number of write cycles (e.g. some flash drives), sync may cause life-cycle shortening.</li>
<li><code>dev</code> Interpret character or block special devices on the filesystem.</li>
<li><code>nodev</code> Do not interpret character or block special devices on the file system.</li>
<li><code>suid</code> Allow set-user-ID or set-group-ID bits to take effect. this option can let an ordinary user elevated privileges temporarily</li>
<li><code>nosuid</code> Do not allow set-user-ID or set-group-ID bits to take effect.</li>
<li><code>atime</code> Do not use the <code>noatime</code> feature, so the inode access time is controlled by kernel defaults.</li>
<li><code>noatime</code> Do not update inode access times on this filesystem . This works for all inode types (directories too), so it implies <code>nodiratime</code>. can improve performance.</li>
<li><code>diratime</code> Update directory inode access times on this filesystem. This is the default. (This option is ignored when noatime is set.)</li>
<li><code>nodiratime</code> Do not update directory inode access times on this filesystem. (This option is implied when noatime is set.) can improve performance</li>
<li><code>relatime</code> Update inode access times relative to modify or change time. Access time is only updated if the previous access time was earlier than the current modify or change time. (Similar to noatime, but it doesn’t break mutt or other applications that need to know if a file has been read since the last time it was modified.) can improve performance</li>
<li><code>defaults</code> Use the default options: <code>rw</code>, <code>suid</code>, <code>dev</code>, <code>exec</code>, <code>auto</code>, <code>nouser</code>, and <code>async</code></li>
</ul>
</li>
<li><code>&lt;dump&gt;</code> is checked by the <code>dump</code> utility. This field is usually set to 0 becaus most users didn’t install the dump utility, which disables the check. Set to 1 means backup.</li>
<li><code>&lt;pass&gt;</code> sets the order for filesystem checks at boot time, use <code>fsck</code>. For the root device it should be 1. For other partitions it should be 2, or 0 to disable checking.</li>
</ul>
</li>
</ul>
<h4 id="File-Link"><a href="#File-Link" class="headerlink" title="File Link"></a>File Link</h4><h5 id="Hard-links"><a href="#Hard-links" class="headerlink" title="Hard links"></a>Hard links</h5><ul>
<li><code>ln test1 test2</code><ul>
<li>create a hard link to test1 called test2</li>
</ul>
</li>
<li>shares the same inode</li>
<li>point to same physical file(data block)</li>
<li>delete test1, test2 will be the physical file</li>
</ul>
<h5 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h5><h1 id="Pakcage-amp-install"><a href="#Pakcage-amp-install" class="headerlink" title="Pakcage &amp; install"></a>Pakcage &amp; install</h1><h1 id="Linux-Command"><a href="#Linux-Command" class="headerlink" title="Linux Command"></a>Linux Command</h1>]]></content>
      <categories>
        <category>ESAIP</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA Chapter 11: Build a Small Network</title>
    <url>/2017/12/20/CCNA-Chapter-11-Build-a-Small-Network/</url>
    <content><![CDATA[<p>本课程到目前为止，已经介绍了数据网络为以人为本的网络提供的服务，阐明了 OSI 模型各层的功能和 TCP/IP 协议的工作原理，并深入研究了常用 LAN 技术 — 以太网。接下来，我们要介绍如何将这些要素组合成能够正常运行的网络。</p>
<ul>
<li>Each application or network service uses protocols, which define the standards and data formats to be used. Without protocols, the data network would not have a common way to format and direct data.</li>
<li>To scale a network, several elements are required:<ul>
<li>Network documentation - physical and logical topology</li>
<li>Device Inventory - list of devices that use or make up the network </li>
<li>Budget - Itemized IT budget, including fiscal year equipment purchasing budget</li>
<li>Traffic analysis - protocols, applications, and services and their respective traffic requirements should be documented</li>
</ul>
</li>
<li>Executive timeouts allow the Cisco device to automatically disconnect users after they have been idle for the specified time. Console, vty, and aux ports can be configured with executive timeouts.</li>
<li><code>ipconfig /displaydns</code> show any cached DNS entries for this web page</li>
<li>Traceroute uses the ICMP (Internet Control Message Protocol) to send and receive echo-request and echo-reply messages.</li>
<li>A firewall is one of the most effective security tools for protecting internal network users from external threats.  A firewall resides between two or more networks, controls the traffic between them, and helps prevent unauthorized access. A host intrusion prevention system can help prevent outside intruders and should be used on all systems.</li>
<li>The <code>show file systems</code> command displays all of the available file systems on the device. If usbflash0: appears then the router recognizes the USB drive as a valid storage device. The <code>pwd</code> command shows the current directory being navigated, and the <code>cd</code> command is used to change the current directory. The <code>dir flash0:</code> command will show the contents of flash memory, not the USB drive.</li>
<li>When a Windows computer cannot communicate with an IPv4 DHCP server, the computer automatically assigns itself an IP address in the169.254.0.0/16 range. Linux and Apple computers do not automatically assign an IP address.​</li>
<li>Capturing traffic during low utilization time will not give a good representation of the different traffic types. Because some traffic could be local to a particular segment, the  capture must be done on different network segments.</li>
<li>Not all traffic should receive the same treatment or priority through a network. Some types of traffic, such as voice and video, require the highest priority because they are very sensitive to network latency and delay. Other types of traffic, such as FTP, which is not sensitive to latency and delay, should be given the lowest level of priority so that the higher priority traffic can get through.</li>
<li>The <code>tracert</code> command is used to initiate a trace from the command prompt on a Windows PC. The <code>traceroute</code>command is used to initiate a trace from a Cisco router or switch. Some other PC operating systems, such as Linux and Mac OS also use the traceroute command. The <code>ping</code> command does not display the network path to the remote host.</li>
<li>The most common indicators of a ping issued from the Cisco IOS are “!”, “.”, and “U”. The “!” indicates that the ping completed successfully, verifying connectivity at Layer 3. The “.” may indicate that a connectivity problem, routing problem, or device security issue exists along the path and that an ICMP destination unreachable message was not provided. The “U” indicates that a router along the path may not have had a route to the destination address, and that it responded with an ICMP unreachable message.</li>
<li>The correct syntax is RouterA(config)# <code>login block-for (number of seconds) attempts (number of attempts) within (number of seconds)</code>command will block login attempts on RouterA for a period .</li>
<li>Small networks generally have only one link to an ISP to establish a connection to the Internet. Problems can occur in the network, which can cause the disruption of this service. In order to keep connectivity, redundancy has to be provided. If the problem is in the router interface that is connected to the ISP, another interface can be activated on the router, so if one interface fails, traffic may be redirected toward the other interface. However, if the router itself fails, a second router that is connected to another ISP can be used as a backup.</li>
<li>Because worms take advantage of vulnerabilities in the system itself, the most effective way to mitigate worm attacks is to download security updates from the operating system vendor and patch all vulnerable systems.  </li>
<li>Whenever an administrator connects to the console port, the configuration applied under the line con 0 interface determines how the user is authenticated. The console port configuration has the login command with local as the keyword. That means the username and password are required before the administrator is even allowed to see the enable mode prompt. Because the correct username and password was typed, the administrator will be presented with the enable mode prompt.</li>
<li>Physical threats can be classified into four categories:<ul>
<li>Environmental threats -Temperature extremes (too hot or too cold) or humidity extremes (too wet or too dry)</li>
<li>Hardware threats - Physical damage to servers, routers, switches, cabling plant, and workstations</li>
<li>Electrical threats - Voltage spikes, insufficient supply voltage (brownouts), unconditioned power (noise), and total power loss</li>
<li>Maintenance threats - Poor handling of key electrical components (electrostatic discharge), lack of critical spare parts, poor cabling, and poor labeling</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ul>
<li><strong>device capacity</strong> - the port density, processing, and memory capacity of a device</li>
<li><strong>redundancy</strong> - the duplication of devices, links, or technologies to increase high availability</li>
<li><strong>modular</strong> - a feature that allows add-in capabilities/technologies to a device without the need to purchase a whole new device</li>
<li><strong>vulnerability</strong> - a weakness or flaw that can allow an attacker to gain access to a system</li>
<li><strong>malware</strong> - unwanted malicious software that can harm or disrupt a system operation</li>
<li><strong>virus</strong> - a type of malicious software that requires a user to spread the software through the network</li>
<li><strong>worm</strong> - a type of malicious software that uses the network to spread the software and infect vulnerable systems</li>
<li><strong>Trojan horse</strong> - hidden or disguised software that installs with another software package that a user requested</li>
<li><strong>AAA</strong> a framework that is used to implement authentication, authorization, and accounting functions into network operations</li>
<li><strong>packet filtering</strong> - the ability to perform packet inspection at Layer 3 based on the source and destination IP addresses and source and destination port numbers</li>
<li><strong>application filtering</strong> - the ability to filter traffic based on destination port numbers</li>
<li><strong>URL filtering</strong> - the ability to filter traffic based on a web address</li>
<li><strong>stateful packet inspection</strong> - the ability of a device to track TCP connections and only allow returning data to the inside connection</li>
</ul>
<!--
# 网络设计

## 小型网络的设备选择

为了满足用户需求，小型网络也要求规划和设计。规划可以确保所有要求、成本因素和部署选项得到适当考虑。

在实施小型网络时，最初设计的注意事项之一就是用于支持网络的中间设备类型。如图所示，在选择中间设备类型时，需要考虑诸多因素。

- 成本：交换机或路由器的购买成本取决于其性能和功能。设备的性能包括可用的端口数量和类型以及背板速度。影响成本的其他因素包括网络管理功能、内嵌的安全技术、可选的高级交换技术。还需要考虑连接网络中每台设备所需的电缆布线费用。影响成本考量的另一个关键因素是网络整合的冗余量。

- 端口/接口的速度和类型：路由器或交换机上端口数量和类型的选择是至关重要的。较新版本的计算机有内置的 1 Gb/s 网卡。一些工作站和服务器已经包含 10 Gb/s 端口。虽然比较昂贵，但是选用能够适应速度增长的第 2 层设备使网络能够进行扩展，而无需更换中心设备。

- 可扩展性：网络设备的物理配置有固定式和模块化两种。固定式配置具有固定的端口或接口数量和类型。模块化设备具有扩展槽，可以随着需求的提高而新增模块。交换机上有附加端口，供高速上行链路使用。路由器可用于连接不同类型的网络。必须慎重选择每种介质适用的相应模块和接口。

- 操作系统的功能和服务：根据操作系统的版本，网络设备可以支持特定的功能和服务，例如：安全、服务质量 (QoS)、IP 语音 VoIP)、第 3 层交换、网络地址转换 (NAT)、动态主机配置协议 (DHCP)

## 小型网络的 IP 编址

在实施小型网络时，需要规划 IP 编址空间。网际网络中的所有主机都必须有一个唯一地址。应当根据接收地址的设备类型规划、记录和维护 IP 编址方案。

影响 IP 设计的不同类型设备的示例如下：

- 用户使用的终端设备
- 服务器和外围设备
- 可以从 Internet 访问的主机
- 中间设备

IP 编址方案的规划和记录可以帮助管理员跟踪设备类型。例如，如果为所有服务器分配的主机地址范围为 50-100，则很容易通过 IP 地址来识别服务器流量。这在使用协议分析器对网络流量问题进行故障排除时非常有用。

此外，当使用确定性 IP 编址方案时，管理员可以根据 IP 地址更好地控制对网络资源的访问。这对于同时向内部网络和外部网络提供资源的主机尤为重要。Web 服务器或电子商务服务器扮演这样的角色。如果不规划和记录这些资源的地址，就不容易控制设备的安全和访问。如果一台服务器的地址是随机分配的，就难以阻止对此地址的访问，客户端可能也就无法定位此资源。

## 小型网络中的冗余

网络设计的另一个重要部分是可靠性。即使是小型企业，也常常非常依赖其网络以进行企业运营。网络故障的代价是非常大的。为了保持高可靠度，网络设计中要求冗余。冗余有助于避免单点故障。在网络中实现冗余有许多方法。可以通过安装重复设备实现冗余，但也可以通过为关键区域提供重复的网络链路来实现

小型网络通常通过一个或多个默认网关提供单个 Internet 出口点。如果路由器发生故障，则整个网络都会失去与 Internet 的连接。因此，建议小型企业通过另一个服务提供商购买备份产品。

## 小型网络的增长

不断扩展是许多小型企业必经的过程，而其网络也必须相应地扩展。理想情况是网络管理员有足够的时间根据公司发展做出关于网络发展的明智决策。

要扩展网络，要求有以下几个要素：

- 网络文档 - 物理和逻辑拓扑
- 设备清单 - 使用或构成网络的设备列表
- 预算 - 逐项记录的 IT 预算，包括财年设备的采购预算
- 流量分析 - 应当记录协议、应用程序和服务以及它们各自的流量要求

这些要素用于为有关小型网络扩展的决策提供信息。

-->]]></content>
      <categories>
        <category>ESAIP</category>
        <category>CCNA</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter 10: Application Layer</title>
    <url>/2017/12/20/Chapter-10-Application-Layer/</url>
    <content><![CDATA[<p>应用程序（例如 Web 浏览器、在线游戏、与朋友聊天和邮件往来）使我们发送和接收数据变得相对容易。通常我们可以访问和使用这些应用程序，而不必了解其工作原理。但是，对于网络工程师而言，就必须了解应用程序如何对网络中收发的信息进行格式化、传输和解释。</p>
<p>通过 OSI 模型的分层结构，我们可以更容易地理解网络通信原理。</p>
<p>在本章中，我们将探讨应用层的作用，以及应用层中的应用程序、服务和协议如何实现强大的数据网络通信。</p>
<p>对于TCP/IP模型来说，应用层就为一层。而对于OSI模型来说。分为三层，分别为应用层，表示层，会话层</p>
<h1 id="应用层，表示层，会话层"><a href="#应用层，表示层，会话层" class="headerlink" title="应用层，表示层，会话层"></a>应用层，表示层，会话层</h1><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层最接近最终用户。该层为用于通信的应用程序和用于消息传输的底层网络提供接口。应用层协议用于在源主机和目的主机上运行的程序之间进行数据交换。</p>
<p>目前已有很多种应用层协议，而且人们还在不断开发新的协议。某些最广为人知的应用层协议包括超文本传输协议(HTTP)、文件传输协议 (FTP)，简单文件传输协议 (TFTP)，互联网邮件访问协议 (IMAP) 和域名系统 (DNS) 协议。</p>
<h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><p>表示层具有三个主要功能：</p>
<ul>
<li>将来自源设备的数据格式化或表示成兼容形式，以便目的设备接收</li>
<li>采用可被目的设备解压缩的方式对数据进行压缩</li>
<li>加密数据以便传输，并在接收时解密。</li>
</ul>
<p>表示层为应用层格式化数据并制定文件格式标准。常见的视频标准包括 QuickTime 和活动图像专家组 (MPEG)。网络中使用的常见图形图像格式为图形交换格式 (GIF)、联合图像专家组 (JPEG) 和便携式网络图像 (PNG) 格式。</p>
<h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>顾名思义，会话层的功能就是创建并维护源应用程序和目的应用程序之间的对话。会话层用于处理信息交换，发起对话并使其处于活动状态，并在对话中断或长时间处于空闲状态时重启会话。</p>
<h1 id="应用程序交互"><a href="#应用程序交互" class="headerlink" title="应用程序交互"></a>应用程序交互</h1><h2 id="客户端-服务器模型"><a href="#客户端-服务器模型" class="headerlink" title="客户端-服务器模型"></a>客户端-服务器模型</h2><p>在客户端-服务器模型中，请求信息的设备称为客户端，而响应请求的设备称为服务器。<strong>客户端进程和服务器进程都处于应用层</strong>。客户端首先向服务器发送数据请求，服务器通过发送一个或多个数据流来响应客户端。应用层协议规定了客户端和服务器之间请求和响应的格式。除了实际数据传输外，数据交换过程还要求用户身份验证以及要传输的数据文件的标识。</p>
<p>客户端-服务器网络的一个示例是使用 ISP 的电子邮件服务发送、接收和存储电子邮件。家用计算机的电子邮件客户端向 ISP 的电子邮件服务器请求所有未读邮件。随后服务器向客户端发送被请求的邮件以示响应。</p>
<h2 id="对等网络"><a href="#对等网络" class="headerlink" title="对等网络"></a>对等网络</h2><p>在对等 (P2P) 网络模式中，可以从对等设备访问数据，而无需使用专用服务器。</p>
<p>P2P 网络模型包含两个部分：P2P 网络和 P2P 应用程序。这两个部分具有相似的特征，但实际工作过程却大不相同。</p>
<p>在 P2P 网络中，两台或多台计算机通过网络互连，它们共享资源(如打印机和文件)时可以不借助专用服务器。每台接入的终端设备（称为“对等点”）既可以作为服务器，也可以作为客户端。在某项事务中，作为服务器的计算机也可以同时成为其他服务器的客户端。于是，计算机的角色根据请求的不同在客户端和服务器之间切换。</p>
<h3 id="对等应用程序"><a href="#对等应用程序" class="headerlink" title="对等应用程序"></a>对等应用程序</h3><p>对等 (P2P) 应用程序允许设备在同一通信中同时充当客户端和服务器。在该模型中，每台客户端都是服务器，而每台服务器也同时是客户端。P2P <strong>应用程序要求每台终端设备提供用户界面并运行后台服务</strong>。</p>
<p>某些 P2P 应用程序中采用混合系统，即共享的资源是分散的，但指向资源位置的索引存储在集中目录中。在混合系统中，每台对等设备通过访问索引服务器获取存储在另一台对等设备中的资源位置。</p>
<h3 id="常见-P2P-应用程序"><a href="#常见-P2P-应用程序" class="headerlink" title="常见 P2P 应用程序"></a>常见 P2P 应用程序</h3><p>使用 P2P 应用程序时，网络中运行该应用程序的每台计算机都可以充当在网络中运行该应用程序的其他计算机的客户端或服务器。常见 P2P 网络包括:</p>
<ul>
<li>eDonkey</li>
<li>G2</li>
<li>BitTorrent</li>
<li>Bitcoin</li>
</ul>
<p>某些 <strong>P2P 应用程序基于 Gnutella 协议，允许每个用户与他人共享整个文件</strong>。如图所示，通过与 Gnutella 协议兼容的客户端软件，用户可以在 Internet 上连接 Gnutella 服务，然后定位并访问由其他 Gnutella 对等设备共享的资源。很多 Gnutella 客户端应用程序可用，包括 gtk-gnutella、WireShare、Shareaza 和 Bearshare。</p>
<p>许多 P2P 应用程序允许用户同时相互分享许多文件片段。客户端使用一个称作 torrent 文件的小型文件查找其他拥有其所需片段的用户，以便可以直接连接到他们。此文件也包含有关跟踪哪些用户有哪些文件的跟踪计算机的信息。客户端同时需要多个用户的文件片段，这被称为集群。该技术称为 BitTorrent。有许多 BitTorren 客户端，包括 BitTorrent、uTorrent、Frostwire 和 qBittorrent。</p>
<h1 id="常用应用层协议"><a href="#常用应用层协议" class="headerlink" title="常用应用层协议"></a>常用应用层协议</h1><h2 id="超文本传输协议和超文本标记语言"><a href="#超文本传输协议和超文本标记语言" class="headerlink" title="超文本传输协议和超文本标记语言"></a>超文本传输协议和超文本标记语言</h2><p>当在 Web 浏览器中输入一个 Web 地址或统一资源定位符 (URL) 时，Web 浏览器将通过 HTTP 协议建立与服务器上的 Web 服务之间的连接。一提到 Web 地址，大多数人往往想到 URL 以及统一资源标识符 (URI)。</p>
<p>为了更好地理解 Web 浏览器和 Web 客户端的交互原理，我们可以研究一下浏览器是如何打开网页的。例如<code>http://www.cisco.com/index.html</code> URL。</p>
<p>首先，浏览器对 URL 地址的三个组成部分进行分析：</p>
<ol>
<li><p>http（协议或方案）</p>
</li>
<li><p>www.cisco.com（服务器名称）</p>
</li>
<li><p>index.html（所要请求的文件名称）</p>
</li>
</ol>
<p>然后，浏览器将通过域名服务器将 www.cisco.com 转换成数字 IP 地址，用它连接到该服务器。根据 HTTP 协议的要求，浏览器向该服务器发送 GET 请求并请求 index.html 文件。服务器，将该网页的 HTML 代码发送到浏览器。最后，浏览器解密 HTML 代码并为浏览器窗口格式化页面。</p>
<h2 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h2><p>HTTP 是一种请求/响应协议。当客户端，尤其是 Web 浏览器，发送请求到 Web 服务器时，HTTP 将指定用于该通信的消息类型。常用的三种消息类型包括 GET、POST 和 PUT（如图所示）。</p>
<ul>
<li>GET - 一种客户端数据请求消息。客户端（Web 浏览器）向 Web 服务器发送 GET 消息以请求 HTML 页面。</li>
<li>POST - 上传数据文件到 Web 服务器，例如表单数据。</li>
<li>PUT - 用于向 Web 服务器上传资源或内容，例如图像。</li>
</ul>
<p>尽管 HTTP 灵活性相当高，但它不是一个安全协议。由于请求消息以明文形式向服务器发送信息，它非常容易被拦截和解读。服务器的响应（尤其是 HTML 页面）也不加密。</p>
<p>为了在 Internet 中进行安全通信，人们使用 HTTP 安全（HTTP Secure，HTTPS）协议。HTTPS 借助身份验证和加密来保护数据，使数据得以安全地在客户端与服务器之间传输。HTTPS 使用的客户端请求服务器响应过程与 HTTP 相同，但在数据流通过网络传输以前会使用安全套接字层 (Secure Socket Layer ，SSL) 加密。</p>
<h2 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h2><p>电子邮件客户端通过与邮件服务器通信来收发电子邮件。邮件服务器之间也会互相通信，以便将邮件从一个域发到另一个域中。也就是说，发送电子邮件时，电子邮件客户端并不会直接与另外一个电子邮件客户端通信。而是双方客户端均依靠邮件服务器来传输邮件。</p>
<p>电子邮件支持三种单独的协议以实现操作：简单邮件传输协议 (SMTP)、邮局协议 (POP) 和 Internet 邮件访问协议 (IMAP)。发送邮件的应用层进程会使用 SMTP。但是，客户端会使用以下两种应用层协议之一来检索电子邮件：POP 或 IMAP。</p>
<h3 id="SMTP-工作原理"><a href="#SMTP-工作原理" class="headerlink" title="SMTP 工作原理"></a>SMTP 工作原理</h3><p>SMTP 邮件格式要求邮件具有报头和正文。邮件正文没有长度限制，但邮件报头必须具有格式正确的收件人电子邮件地址和发件人地址。</p>
<p>当客户端发送电子邮件时，客户端 SMTP 进程会连接<strong>公认端口 25</strong>上的服务器 SMTP 进程。连接建立后，客户端将尝试通过此连接发送电子邮件到服务器。</p>
<p>发出电子邮件时，目的电子邮件服务器可能并不在线，或者正忙。因此，SMTP 将邮件转到后台处理，稍后再发送。服务器会定期检查邮件队列，然后尝试再次发送。经过预定义的过期时间后，如果仍然无法发送邮件，则会将其作为无法投递的邮件退回给发件人。</p>
<p>SMTP is used to send mail from the client to the server but POP3 is used to download mail from the server to the client</p>
<h3 id="POP-工作原理"><a href="#POP-工作原理" class="headerlink" title="POP 工作原理"></a>POP 工作原理</h3><p>应用程序使用 POP 从邮件服务器中检索邮件。根据 POP 的规定，邮件将从服务器下载到客户端，然后从服务器上删除。这就是默认情况下 POP 的运行方式。</p>
<p>服务器通过在 TCP <strong>端口 110</strong> 上被动侦听客户端连接请求来启动 POP 服务。当客户端要使用此服务时，它会发送一个请求来建立与服务器的 TCP 连接。一旦建立连接，POP 服务器即会发送问候语。然后客户端和 POP 服务器会交换命令和响应，直到连接关闭或中止。</p>
<p>根据 POP，<strong>由于电子邮件会下载到客户端并从服务器删除，因此电子邮件不会集中保存在某一特定的位置</strong>。因为 POP 不会存储邮件，因此不适于需要集中备份解决方案的小型企业。</p>
<h3 id="IMAP-工作原理"><a href="#IMAP-工作原理" class="headerlink" title="IMAP 工作原理"></a>IMAP 工作原理</h3><p>IMAP 是另外一种用于检索电子邮件消息的协议。与 POP 不同的是，当用户连接使用 IMAP 的服务器时，<strong>邮件的副本会下载到客户端应用程序。同时原始邮件会一直保留在服务器上，直到用户将它们手动删除</strong>。用户在自己的电子邮件客户端软件中查看邮件副本。</p>
<p>用户可以在服务器上创建文件层次结构来组织和保存邮件。该文件结构会照搬到电子邮件客户端。当用户决定删除邮件时，服务器会同步该操作，从服务器上删除对应的邮件。</p>
<h2 id="IP编址服务"><a href="#IP编址服务" class="headerlink" title="IP编址服务"></a>IP编址服务</h2><h3 id="域名服务"><a href="#域名服务" class="headerlink" title="域名服务"></a>域名服务</h3><p>在数据网络中，使用数字 IP 地址标记设备以便通过网络发送和接收数据。人们创建了可以将数字地址转换为简单易记名称的域名系统。</p>
<p>在 Internet 上，更便于人们记忆的是 <a href="http://www.cisco.com" target="_blank" rel="noopener">http://www.cisco.com</a> 这样的域名，而不是该服务器的实际数字地址 198.133.219.25。如果思科决定更改 www.cisco.com 的数字地址，那么更改对用户是透明的，因为域名将保持不变。公司只需要将新地址与现有域名链接起来即可保证连通性。</p>
<p>DNS 协议定义了一套自动化服务，该服务将资源名称与所需的数字网络地址匹配。协议涵盖了查询格式、响应格式及数据格式。DNS 协议通信采用单一格式，即消息格式。该格式用于所有类型的客户端查询和服务器响应、报错消息、以及服务器间的资源记录信息的传输。<br>DNS 服务器中存储不同类型的资源记录，用来解析域名。这些记录中包含域名、地址以及记录的类型。这些记录中有以下类型：</p>
<ul>
<li>A - 终端设备 IPv4 地址</li>
<li>NS - 权威域名服务器</li>
<li>AAAA - 终端设备 IPv6 地址（读作“四 A”）</li>
<li>MX - 邮件交换记录。</li>
</ul>
<h3 id="DHCP-工作原理"><a href="#DHCP-工作原理" class="headerlink" title="DHCP 工作原理"></a>DHCP 工作原理</h3><p>，配置了 DHCP 的 IPv4 设备在启动或连接到网络时，客户端将<strong>广播</strong>一条 DHCP 发现 (DHCPDISCOVER) 消息以确定网络上是否有可用 DHCP 服务器。DHCP 服务器回复 DHCP 服务 (DHCPOFFER) 消息，为客户端提供租赁服务。<strong>该服务消息包含为其分配的 IPv4 地址和子网掩码、DNS 服务器的 IPv4 地址和默认网关的 IPv4 地址。租赁服务还包括租用期限。</strong></p>
<p>如果本地网络中有超过一台 DHCP 服务器，客户端可能会收到多条 DHCPOFFER 消息。此时，客户端必须在这些服务器中进行选择，并且将包含服务器标识信息及客户端所接受的租赁服务的 DHCP 请求 (DHCPREQUEST) 消息发送出去。客户端还可选择向服务器请求分配以前分配过的地址。</p>
<p>如果客户端请求的 IPv4 地址（或者服务器提供的 IPv4 地址）仍然可用，服务器将返回 DHCP 确认 (DHCPACK) 消息，向客户端确认地址租赁。如果请求的地址不再有效，则所选服务器将回复一条 DHCP 否定确认 (DHCPNAK) 消息。一旦返回 DHCP NAK 消息，应重新启动选择进程，并重新发送新的 DHCP 发现消息。客户端租赁到地址后，应在租期结束前发送 DHCPREQUEST 消息进行续期。</p>
<p>DHCP 服务器确保每个 IP 地址都是唯一的（一个 IP 地址不能同时分配到不同的网络设备上）。因此，大多数 Internet 提供商往往使用 DHCP 为其客户分配地址。</p>
<p>DHCPv6 消息是 SOLICIT、ADVERTISE、INFORMATION REQUEST 和 REPLY</p>
<h2 id="文件共享服务"><a href="#文件共享服务" class="headerlink" title="文件共享服务"></a>文件共享服务</h2><h3 id="文件传输协议"><a href="#文件传输协议" class="headerlink" title="文件传输协议"></a>文件传输协议</h3><p>文件传输协议 (FTP) 也是一种常用的应用层协议。FTP 用于客户端和服务器之间的数据传输。FTP 客户端是一种在计算机上运行的应用，用于从 FTP 服务器中收发数据。</p>
<p>为了成功传输数据，FTP 要求客户端和服务器之间建立两个连接，一个用于命令和应答，另一个用于实际文件传输：</p>
<ul>
<li>客户端使用 <strong>TCP 端口 21</strong> 与服务器建立第一个连接用于控制流量，包含客户端命令和服务器应答。</li>
<li>客户端使用 <strong>TCP 端口 20</strong> 与服务器建立第二个连接用于实际数据传输。每当有数据需要传输时都会建立此连接。</li>
</ul>
<p>数据传输可以在任何一个方向进行。客户端可以从服务器下载（取）数据，也可以向服务器上传（放）数据。</p>
<h3 id="服务器消息块"><a href="#服务器消息块" class="headerlink" title="服务器消息块"></a>服务器消息块</h3><p>服务器消息块 (SMB) 是一种<strong>客户端/服务器文件共享协议</strong>，用于规范共享网络资源（如目录、文件、打印机以及串行端口）结构。这是一种请求-响应协议。所有的 SMB 消息都采用一种常用格式。该格式采用固定大小的文件头，后跟可变大小的参数以及数据组件。<br><strong>Microsoft 网络配置中主要采用 SMB 形式实现文件共享和打印服务。</strong></p>
<p>SMB 消息可以：</p>
<ul>
<li>启动、身份验证以及终止会话</li>
<li>控制文件和打印机的访问</li>
<li>允许应用程序向任何设备收发消息</li>
</ul>
<p>与 FTP 协议支持的文件共享不同，<strong>SMB 协议中的客户端要与服务器建立长期连接。</strong>一旦建立连接，客户端用户就可以访问服务器上的资源，就如同资源位于客户端主机上一样。</p>
<p>在 LINUX 和 UNIX 操作系统中，通过 SAMBA（SMB 的一个版本）可以实现与 Microsoft 网络的资源共享。在 Apple Macintosh 操作系统中，通过 SMB 协议也可以实现资源共享。</p>
<ul>
<li><strong>presentation layer</strong> - the layer in the OSI model that is responsible for formatting, compressing, and encrypting data</li>
<li><strong>peer-to-peer network</strong> - consists of peer machines that exchange data with each other without a dedicated server</li>
<li><strong>application layer</strong> - provides data exchange and the interface between the system and the network</li>
<li><strong>domain name</strong> - the name that is used to uniquely identify a website and is used instead of the IP address</li>
<li><strong>URL</strong> - Uniform Resource Locator - the “friendly” address that is used in a web browser bar and that corresponds to the IP address of the site</li>
<li><strong>nslookup</strong> - a tool used to query the DNS system to find the IP addresses for domain names, and vice versa</li>
<li><strong>session layer</strong> - used to arrange the communication between source and destination applications and responsible for the state of the conversation</li>
<li><strong>client-server network</strong> - an architecture that allows network clients to request services directly from network servers</li>
<li><strong>HTTP</strong> - Hypertext Transfer Protocol - used to request and transfer hypertext data between clients and servers</li>
<li><strong>POP</strong> - a protocol that is used to retrieve email from a server It deletes messages from the server by default.</li>
<li><strong>IMAP</strong> - a protocol that is used in email retrieval It leaves copy of messages on the server.</li>
<li><strong>SMTP</strong> - the protocol responsible for sending email</li>
<li><strong>DHCP</strong> - a service that is used in networks to automatically configure IP addresses on devices</li>
</ul>
]]></content>
      <categories>
        <category>ESAIP</category>
        <category>CCNA</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA Chapter 9: Transport Layer</title>
    <url>/2017/12/20/CCNA-Chapter-9-Transport-Layer/</url>
    <content><![CDATA[<p>数据网络和 Internet 通过提供可靠的人际通信来支持以人为本的网络。人们可以在一台设备上使用多种应用和服务来发送消息或者检索信息，例如电子邮件、Web 和即时消息等。这些应用程序发出的数据经过封装传输，最终送达目的设备上的相应应用程序。</p>
<p>我们之前曾介绍过，OSI 传输层的进程从应用层接收数据，然后进行相应处理以便用于网络层编址。源计算机与接收计算机通信，决定如何将数据划分为数据段，如何确保不会丢失任何数据段，以及如何验证所有数据段均已到达。我们可以把传输层想象成一个运输部门，负责准备一个订单的多个包裹以供运输。</p>
<p>传输层负责在两个应用程序之间建立临时通信会话和在它们之间传递数据。应用程序生成从源主机的应用程序发送到目的主机的应用程序的数据。这不考虑目的主机类型、数据必须通过的介质类型、数据使用的路径、链路拥塞情况或网络大小</p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>在计算机网络中，传输层（英语：transport layer）互联网协议包与开放系统互连（OSI）网络堆栈中协议的分层结构中的方法的一个概念划分。该层的协议为应用进程提供端到端的通信服务。 它提供面向连接的数据流支持、可靠性、流量控制、多路复用等服务。</p>
<p>传输层负责在两个应用程序之间建立临时通信会话和在它们之间传递数据。应用程序生成从源主机的应用程序发送到目的主机的应用程序的数据。这不考虑目的主机类型、数据必须通过的介质类型、数据使用的路径、链路拥塞情况或网络大小</p>
<h2 id="传输层的职责"><a href="#传输层的职责" class="headerlink" title="传输层的职责"></a>传输层的职责</h2><h3 id="跟踪各个会话（tracking-Individual-Conversations-）"><a href="#跟踪各个会话（tracking-Individual-Conversations-）" class="headerlink" title="跟踪各个会话（tracking Individual Conversations ）"></a>跟踪各个会话（tracking Individual Conversations ）</h3><p>在传输层中，源应用程序和目的应用程序之间传输的每个数据集称为会话。每台主机上都可以有多个应用程序同时在网络上通信。每个应用程序都与一台或多台远程主机上的一个或多个应用程序通信。传输层负责维护并跟踪这些会话。</p>
<h3 id="数据分段和数据段重组（Segmenting-Data-and-Reassembling-Segments）"><a href="#数据分段和数据段重组（Segmenting-Data-and-Reassembling-Segments）" class="headerlink" title="数据分段和数据段重组（Segmenting Data and Reassembling Segments）"></a>数据分段和数据段重组（Segmenting Data and Reassembling Segments）</h3><p>数据必须准备好用易管理的片段通过介质发送出去。大多数网络对单个数据包能承载的数据量都有限制。传输层协议的服务可将应用程序数据分为大小适中的数据块。该服务包括每段数据所需的封装功能。报头用于重组，每个数据块都会添加一个报头。此报头用于跟踪数据流。</p>
<p>数据片段到达目的设备后，传输层必须能将其重组为可用于应用层的完整数据流。传输层协议规定了如何使用传输层报头信息来重组要传送到应用层的数据片段。</p>
<h3 id="标识应用程序（Identifying-the-Applications）"><a href="#标识应用程序（Identifying-the-Applications）" class="headerlink" title="标识应用程序（Identifying the Applications）"></a>标识应用程序（Identifying the Applications）</h3><p>为了将数据流传送到适当的应用程序，传输层必须要标识目标应用程序。因此，传输层为每一个应用程序分配一个标识符，称为端口号。在每台主机中，每个需要访问网络的软件进程都将被分配一个唯一的端口号。</p>
<h3 id="会话多路复用-（Conversation-Multiplexing）"><a href="#会话多路复用-（Conversation-Multiplexing）" class="headerlink" title="会话多路复用 （Conversation Multiplexing）"></a>会话多路复用 （Conversation Multiplexing）</h3><p>将某些类型的数据（如视频流）作为完整的通信流在网络中发送，会使用所有可用带宽。这会阻止其他通信同时发生。而且也难以对损坏的数据开展错误恢复和重新传输的工作。</p>
<p>为了识别每段数据，传输层向几个字段添加包含二进制数据的报头。不同的传输层协议通过这些字段值在管理数据通信过程中执行各自的功能。</p>
<h3 id="传输层可靠性（Transport-Layer-Reliability）"><a href="#传输层可靠性（Transport-Layer-Reliability）" class="headerlink" title="传输层可靠性（Transport Layer Reliability）"></a>传输层可靠性（Transport Layer Reliability）</h3><p>传输层还负责管理会话的可靠性要求。不同的应用程序有不同的传输可靠性要求。</p>
<p>IP 只涉及数据包的结构、地址分配和路由。IP 不指定数据包的传送或传输方式。传输协议则指定在主机之间传输报文的方式。TCP/IP 提供两种传输层协议，即传输控制协议 (Transmission Control Protocol，TCP) 和用户数据报协议 (User Datagram Protocol，UDP)。IP 使用这些传输协议来实现主机的数据通信和传输。</p>
<p>TCP 被认为是可靠且功能齐全的传输层协议，用于确保所有数据到达目的设备。但是，这需要 TCP 报头中包含其他字段，这会增加数据包的大小，同时也会增加延迟。相反，UDP 是不提供可靠性的一个比较简单的传输层协议。因此，UDP 的字段较少而且比 TCP 更快。</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能</p>
<p>在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。</p>
<p>应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。</p>
<p>使用 TCP 的三项基本的可靠性操作：</p>
<ul>
<li>计算并跟踪从特定应用程序发送到特定主机的数据段的数量。</li>
<li>确认收到数据</li>
<li>在一定时间段后，重新发送任何未确认的数据。</li>
</ul>
<h2 id="TCP-功能"><a href="#TCP-功能" class="headerlink" title="TCP 功能"></a>TCP 功能</h2><p>要了解 TCP 和 UDP 的差异，就必须了解每种协议如何实现特定的可靠性功能，以及它们如何跟踪会话。除了支持数据分段和重组的基本功能之外，TCP 还提供以下服务：</p>
<ul>
<li><p>建立会话（Establishing a Session）：TCP 是一种面向连接的协议。面向连接的协议在转发任何流量之前，在源设备和目的设备之间协商并建立永久连接（或会话）。通过建立会话，设备可以协商特定时间能够转发的流量，而且两个设备之间的通信数据可得到严格管理。</p>
</li>
<li><p>可靠传输（Reliable Delivery）：在网络术语中，可靠性指确保从源设备发送的每个数据段都能够到达目的设备。由于多种原因，数据段在网络传输过程中可能会损坏或者完全丢失。</p>
</li>
<li><p>同序传输（Same-Order Delivery）：由于网络可能提供了多条路由，每条路由又有不同的传输速率，所以可能导致数据抵达的顺序错乱。通过对数据段编号和排序，TCP 可以确保按正确的顺序重组这些数据段。</p>
</li>
<li><p>流量控制（Flow Control）：网络主机的内存或处理能力等资源有限。当 TCP 发现这些资源超负荷运转时，它可以请求源应用程序降低数据流速。为此，TCP 会调整源设备传输的数据量。流量控制可避免当接收主机的资源不堪重负时，数据的重新传输。</p>
</li>
</ul>
<h2 id="TCP数据包结构"><a href="#TCP数据包结构" class="headerlink" title="TCP数据包结构"></a>TCP数据包结构</h2><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1fmndkzpfcsj30k00c8t94.jpg" alt=""></p>
<ol>
<li>来源连接端口（16位长）－辨识发送连接端口</li>
<li>目的连接端口（16位长）－辨识接收连接端口</li>
<li>序列号（seq，32位长）<ul>
<li>如果含有同步化旗标（SYN），则此为最初的序列号；第一个数据比特的序列码为本序列号加一。</li>
<li>如果没有同步化旗标（SYN），则此为第一个数据比特的序列码。</li>
</ul>
</li>
<li>确认号（ack，32位长）—期望收到的数据的开始序列号。也即已经收到的数据的字节长度加1。</li>
<li>报头长度（4位长）—以4字节为单位计算出的数据段开始地址的偏移值。</li>
<li>保留—须置0</li>
<li>标志符<ul>
<li>URG—为1表示高优先级数据包，紧急指针字段有效。</li>
<li>ACK—为1表示确认号字段有效</li>
<li>PSH—为1表示是带有PUSH标志的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。</li>
<li>RST—为1表示出现严重差错。可能需要重现创建TCP连接。还可以用于拒绝非法的报文段和拒绝连接请求。</li>
<li>SYN—为1表示这是连接请求或是连接接受请求，用于创建连接和使顺序号同步</li>
<li>FIN—为1表示发送方没有数据要传输了，要求释放连接。</li>
</ul>
</li>
<li>窗口（WIN，16位长）—表示从确认号开始，本报文的接受方可以接收的字节数，即接收窗口大小。用于流量控制。</li>
<li>校验和（Checksum，16位长）—对整个的TCP报文段，包括TCP头部和TCP数据，以16位字进行计算所得。这是一个强制性的字段。</li>
<li>紧急指针（16位长）—本报文段中的紧急数据的最后一个字节的序号。</li>
<li>选项字段—最多40字节。每个选项的开始是1字节的kind字段，说明选项的类型。<ul>
<li>0：选项表结束（1字节）</li>
<li>1：无操作（1字节）用于选项字段之间的字边界对齐。</li>
<li>2：最大报文段长度（4字节，Maximum Segment Size，MSS）通常在创建连接而设置SYN标志的数据包中指明这个选项，指明本端所能接收的最大长度的报文段。通常将MSS设置为（MTU-40）字节，携带TCP报文段的IP数据报的长度就不会超过MTU，从而避免本机发生IP分片。只能出现在同步报文段中，否则将被忽略。</li>
<li>3：窗口扩大因子（4字节，wscale），取值0-14。用来把TCP的窗口的值左移的位数。只能出现在同步报文段中，否则将被忽略。这是因为现在的TCP接收数据缓冲区（接收窗口）的长度通常大于65535字节。</li>
<li>4：sackOK—发送端支持并同意使用SACK选项。</li>
<li>5：SACK实际工作的选项。</li>
<li>8：时间戳（10字节，TCP Timestamps Option，TSopt）</li>
<li>发送端的时间戳（Timestamp Value field，TSval，4字节）</li>
<li>时间戳回显应答（Timestamp Echo Reply field，TSecr，4字节）</li>
</ul>
</li>
</ol>
<h2 id="网络套接字"><a href="#网络套接字" class="headerlink" title="网络套接字"></a>网络套接字</h2><p>在计算机科学中，网络套接字（英语：Network socket），又译网络套接字、网络接口、网络插槽，是电脑网络中进程间数据流的端点。使用以网际协议（Internet Protocol）为通信基础的网络套接字，称为网际套接字（Internet socket）。因为网际协议的流行，现代绝大多数的网络套接字，都是属于网际套接字。</p>
<p>socket是一种操作系统提供的进程间通信机制。</p>
<p>在操作系统中，通常会为应用程序提供一组应用程序接口（API），称为套接字接口（英语：socket API）。应用程序可以通过套接字接口，来使用网络套接字，以进行数据交换。最早的套接字接口来自于4.2 BSD，因此现代常见的套接字接口大多源自Berkeley套接字（Berkeley sockets）标准。<strong>在套接字接口中，以IP地址及通信端口组成套接字地址（socket address）。远程的套接字地址，以及本地的套接字地址完成连接后，再加上使用的协议（protocol），这个五元组（five-element tuple)，作为套接字对（socket pairs），之后就可以彼此交换数据。</strong>例如，再同一台计算机上，TCP协议与UDP协议可以同时使用相同的port而互不干扰。 操作系统根据套接字地址，可以决定应该将数据送达特定的进程或线程。这就像是电话系统中，以电话号码加上分机号码，来决定通话对象一般。</p>
<h2 id="运作方式"><a href="#运作方式" class="headerlink" title="运作方式"></a>运作方式</h2><p>TCP协议的运行可划分为三个阶段：连接创建(connection establishment)、数据传送（data transfer）和连接终止（connection termination）。操作系统将TCP连接抽象为套接字表示的本地端点（local end-point），作为编程界面给程序使用。在TCP连接的生命期内，本地端点要经历一系列的状态改变。</p>
<h3 id="创建通路"><a href="#创建通路" class="headerlink" title="创建通路"></a>创建通路</h3><p>TCP用三路握手（或称三次握手，three-way handshake）过程创建一个连接。在连接创建过程中，很多参数要被初始化，例如序号被初始化以保证按序传输和连接的强壮性。</p>
<p>一对终端同时初始化一个它们之间的连接是可能的。但通常是由一端打开一个套接字（socket）然后监听来自另一方的连接，这就是通常所指的被动打开（passive open）。服务器端被被动打开以后，用户端就能开始创建主动打开（active open）。</p>
<ol>
<li>客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三路握手的一部分。客户端把这段连接的序号设定为随机数A。</li>
<li>服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK的确认码应为A+1，SYN/ACK包本身又有一个随机产生的序号B。</li>
<li>最后，客户端再发送一个ACK。当服务端收到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包的序号被设定为收到的确认号A+1，而响应号则为B+1。</li>
</ol>
<p>如果服务器端接到了客户端发的SYN后回了SYN-ACK后客户端掉线了，服务器端没有收到客户端回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，服务器端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会断开这个连接。</p>
<h3 id="资源使用"><a href="#资源使用" class="headerlink" title="资源使用"></a>资源使用</h3><p>主机收到一个TCP包时，用两端的IP地址与端口号来标识这个TCP包属于哪个session。使用一张表来存储所有的session，表中的每条称作Transmission Control Block（TCB），tcb结构的定义包括连接使用的源端口、目的端口、目的ip、序号、应答序号、对方窗口大小、己方窗口大小、tcp状态、tcp输入/输出队列、应用层输出队列、tcp的重传有关变量等。</p>
<p>服务器端的连接数量是无限的，只受内存的限制。客户端的连接数量，过去由于在发送第一个SYN到服务器之前需要先分配一个随机空闲的端口，这限制了客户端IP地址的对外发出连接的数量上限。从Linux 4.2开始，有了socket选项<code>IP_BIND_ADDRESS_NO_PORT</code>，它通知Linux内核不保留usingbind使用端口号为0时内部使用的临时端口（ephemeral port），在connect时会自动选择端口以组成独一无二的四元组（同一个客户端端口可用于连接不同的服务器套接字；同一个服务器端口可用于接受不同客户端套接字的连接）。</p>
<p>对于不能确认的包、接收但还没读取的数据，都会占用操作系统的资源。</p>
<h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p>在TCP的数据传送状态，很多重要的机制保证了TCP的可靠性和强壮性。它们包括：使用序号，对收到的TCP报文段进行排序以及检测重复的数据；使用校验和检测报文段的错误，即无错传输；使用确认和计时器来检测和纠正丢包或延时；流控制（Flow control）；拥塞控制（Congestion control）；丢失包的重传。</p>
<h4 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h4><p>通常在每个TCP报文段中都有一对序号和确认号。TCP报文发送者称自己的字节流的编号为序号，称接收到对方的字节流编号为确认号。TCP报文的接收者为了确保可靠性，在接收到一定数量的连续字节流后才发送确认。这是对TCP的一种扩展，称为选择确认（Selective Acknowledgement）。选择确认使得TCP接收者可以对乱序到达的数据块进行确认。每一个字节传输过后，ISN号都会递增1。</p>
<p>通过使用序号和确认号，TCP层可以把收到的报文段中的字节按正确的顺序交付给应用层。序号是32位的无符号数，在它增大到232-1时，便会回绕到0。对于ISN的选择是TCP中关键的一个操作，它可以确保强壮性和安全性。</p>
<p>TCP协议使用序号（sequence number）标识每端发出的字节的顺序，从而另一端接收数据时可以重建顺序，无惧传输时的包的乱序交付或丢包。在发送第一个包时（SYN包），选择一个随机数作为序号的初值，以克制TCP序号预测攻击.</p>
<p>发送确认包(Acks)，携带了接收到的对方发来的字节流的编号，称为确认号，以告诉对方已经成功接收的数据流的字节位置。Ack并不意味着数据已经交付了上层应用程序。</p>
<p>可靠性通过发送方检测到丢失的传输数据并重传这些数据。包括超时重传（Retransmission timeout，RTO）与重复累计确认（duplicate cumulative acknowledgements，DupAcks）。</p>
<h5 id="基于重复累计确认的重传"><a href="#基于重复累计确认的重传" class="headerlink" title="基于重复累计确认的重传"></a>基于重复累计确认的重传</h5><p>如果一个包（不妨设它的序号是100，即该包始于第100字节）丢失，接收方就不能确认这个包及其以后的包，因为采用了累计ack。接收方在收到100以后的包时，发出对包含第99字节的包的确认。这种重复确认是包丢失的信号。发送方如果收到3次对同一个包的确认，就重传最后一个未被确认的包。阈值设为3被证实可以减少乱序包导致的无作用的重传（spurious retransmission）现象。选择性确认(SACK)的使用能明确反馈哪个包收到了，极大改善了TCP重传必要的包的能力。</p>
<h5 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h5><p>发送方使用一个保守估计的时间作为收到数据包的确认的超时上限。如果超过这个上限仍未收到确认包，发送方将重传这个数据包。每当发送方收到确认包后，会重置这个重传定时器。典型地，定时器的值设定为 $  {\displaystyle {\text{smoothed RTT}}+\max(G,4\times {\text{RTT variation}})}  $ 其中 $G$是时钟粒度。进一步，如果重传定时器被触发，仍然没有收到确认包，定时器的值将被设为前次值的二倍（直到特定阈值）。这可对抗中间人攻击方式的拒绝服务攻击，这种攻击愚弄发送者重传很多次导致接受者被压垮。</p>
<h4 id="数据传输举例"><a href="#数据传输举例" class="headerlink" title="数据传输举例"></a>数据传输举例</h4><ol>
<li>发送方首先发送第一个包含序列号为1（可变化）和1460字节数据的TCP报文段给接收方。接收方以一个没有数据的TCP报文段来回复（只含报头），用确认号1461来表示已完全收到并请求下一个报文段。</li>
<li>发送方然后发送第二个包含序列号为1461，长度为1460字节的数据的TCP报文段给接收方。正常情况下，接收方以一个没有数据的TCP报文段来回复，用确认号2921（1461+1460）来表示已完全收到并请求下一个报文段。发送接收这样继续下去。</li>
<li>然而当这些数据包都是相连的情况下，接收方没有必要每一次都回应。比如，他收到第1到5条TCP报文段，只需回应第五条就行了。在例子中第3条TCP报文段被丢失了，所以尽管他收到了第4和5条，然而他只能回应第2条。</li>
<li>发送方在发送了第三条以后，没能收到回应，因此当时钟（timer）过时（expire）时，他重发第三条。（每次发送者发送一条TCP报文段后，都会再次启动一次时钟：RTT）。</li>
<li>这次第三条被成功接收，接收方可以直接确认第5条，因为4，5两条已收到。</li>
</ol>
<h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><p>TCP的16位的校验和（checksum）的计算和检验过程如下：发送者将TCP报文段的头部和数据部分的和计算出来，再对其求反码（一的补数），就得到了校验和，然后将结果装入报文中传输。（这里用反码和的原因是这种方法的循环进位使校验和可以在16位、32位、64位等情况下的计算结果再叠加后相同）接收者在收到报文后再按相同的算法计算一次校验和。这里使用的反码使得接收者不用再将校验和字段保存起来后清零，而可以直接将报文段连同校验加总。如果计算结果是全部为一，那么就表示了报文的完整性和正确性。</p>
<p>注意：TCP校验和也包括了96位的伪头部，其中有源地址、目的地址、协议以及TCP的长度。这可以避免报文被错误地路由。</p>
<p>按现在的标准，TCP的校验和是一个比较脆弱的校验。出错概率高的数据链路层需要更高的能力来探测和纠正连接错误。TCP如果是在今天设计的，它很可能有一个32位的CRC校验来纠错，而不是使用校验和。但是通过在第二层使用通常的CRC校验或更完全一点的校验可以部分地弥补这种脆弱的校验。第二层是在TCP层和IP层之下的，比如PPP或以太网，它们使用了这些校验。但是这也并不意味着TCP的16位校验和是冗余的，对于因特网传输的观察，表明在受CRC校验保护的各跳之间，软件和硬件的错误通常也会在报文中引入错误，而端到端的TCP校验能够捕捉到大部分简单的错误 这就是应用中的端到端原则。</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>流量控制用来避免主机分组发送得过快而使接收方来不及完全收下，一般由接收方通告给发送方进行调控。</p>
<p>TCP使用滑动窗口协议实现流量控制。接收方在“接收窗口”域指出还可接收的字节数量。发送方在没有新的确认包的情况下至多发送“接收窗口”允许的字节数量。接收方可修改“接收窗口”的值。</p>
<p>当接收方宣布接收窗口的值为0，发送方停止进一步发送数据，开始了“保持定时器”（persist timer），以避免因随后的修改接收窗口的数据包丢失使连接的双侧进入死锁，发送方无法发出数据直至收到接收方修改窗口的指示。当“保持定时器”到期时，TCP发送方尝试恢复发送一个小的ZWP包（Zero Window Probe），期待接收方回复一个带着新的接收窗口大小的确认包。一般ZWP包会设置成3次，如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。</p>
<p>如果接收方以很小的增量来处理到来的数据，它会发布一系列小的接收窗口。这被称作愚蠢窗口综合症，因为它在TCP的数据包中发送很少的一些字节，相对于TCP包头是很大的开销。解决这个问题，就要避免对小的window size做出响应，直到有足够大的window size再响应：</p>
<ul>
<li>接收端使用David D Clark算法：如果收到的数据导致window size小于某个值，可以直接ack把window给关闭了，阻止了发送端再发数据。等到接收端处理了一些数据后windows size大于等于了MSS，或者接收端buffer有一半为空，就可以把window打开让发送端再发数据过来。</li>
<li>发送端使用著名的Nagle算法来延时处理，条件一：Window Size&gt;=MSS 或是 Data Size &gt;=MSS；条件二：等待时间或是超时200ms，这两个条件有一个满足，才会发数据，否则就是在积累数据。Nagle算法默认是打开的，所以对于一些需要小包场景的程序——比如像telnet或ssh这样的交互性程序，需要关闭这个算法。可以在Socket设置<code>TCP_NODELAY</code>选项来关闭这个算法。</li>
</ul>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>拥塞控制是发送方根据网络的承载情况控制分组的发送量，以获取高性能又能避免拥塞崩溃（congestion collapse，网络性能下降几个数量级）。这在网络流之间产生近似最大最小公平分配。</p>
<p>发送方与接收方根据确认包或者包丢失的情况，以及定时器，估计网络拥塞情况，从而修改数据流的行为，这称为拥塞控制或网络拥塞避免。</p>
<p>TCP的现代实现包含四种相互影响的拥塞控制算法: 慢开始, 拥塞避免, 快重传, 快恢复 (RFC 5681).</p>
<p>此外，发送方采取“超时重传”（retransmission timeout，RTO），这是估计出来回通信延迟 (RTT) 以及RTT的方差。</p>
<p>RFC793中定义的计算SRTT的经典算法：指数加权移动平均（Exponential weighted moving average）</p>
<ol>
<li>先采样RTT，记下最近好几次的RTT值。</li>
<li>做平滑计算SRTT公式为：<code>SRTT =( α * SRTT ) + ((1- α) * RTT)</code>，其中 α 取值在0.8 到 0.9之间</li>
<li>计算RTO，公式：<code>RTO = min [ UBOUND, max [ LBOUND, (β * SRTT) ] ]</code>其中 UBOUND是最大的timeout时间上限值，LBOUND是最小的timeout时间下限值，β值一般在1.3到2.0之间。</li>
</ol>
<p>1987年，计算RTT的Karn算法或TCP时间戳(RFC 1323)，最大特点是——忽略重传，不把重传的RTT做采样。但是，如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的RTO很小），于是，因为重转的不算，所以，RTO就不会被更新，这是一个灾难。为此，Karn算法一发生重传，就对现有的RTO值翻倍。这就是的Exponential backoff。</p>
<p>1988年，在RFC 6298中给出范·雅各布森算法取平均以获得平滑往返时延（Smoothed Round Trip Time，SRTT），作为最终的RTT估计值。这个算法在被用在今天的TCP协议中：</p>
<p><code>SRTT= SRTT+ α(RTT– SRTT)DevRTT= (1-β)*DevRTT+ β*(|RTT-SRTT|)RTO= µ *SRTT + ∂ *DevRTT</code><br>其中：DevRTT是Deviation RTT。在Linux下，α = 0.125，β = 0.25， μ = 1，∂= 4</p>
<h3 id="最大分段大小"><a href="#最大分段大小" class="headerlink" title="最大分段大小"></a>最大分段大小</h3><p>最大分段大小 (MSS)是在单个分段中TCP愿意接受的数据的字节数最大值。MSS应当足够小以避免IP分片，它会导致丢包或过多的重传。在TCP连接创建时，双端在SYN报文中用MSS选项宣布各自的MSS，这是从双端各自直接相连的数据链路层的最大传输单元(MTU)的尺寸减去固定的IP首部和TCP首部长度。以太网MTU为1500字节， MSS值可达1460字节。使用IEEE 802.3的MTU为1492字节，MSS可达1452字节。如果目的IP地址为“非本地的”，MSS通常的默认值为536（这个默认值允许20字节的IP首部和20字节的TCP首部以适合576字节IP数据报）。此外，发送方可用传输路径MTU发现（见RFC 1191）推导出从发送方到接收方的网络路径上的最小MTU，以此动态调整MSS以避免网络IP分片。</p>
<p>MSS发布也被称作“MSS协商”（MSS negotiation）。严格讲，这并非是协商出来一个统一的MSS值，TCP允许连接两端使用各自不同的MSS值。例如，这会发生在参与TCP连接的一台设备使用非常少的内存处理到来的TCP分组。</p>
<h3 id="选择确认"><a href="#选择确认" class="headerlink" title="选择确认"></a>选择确认</h3><p>最初采取累计确认的TCP协议在丢包时效率很低。例如，假设通过10个分组发出了1万个字节的数据。如果第一个分组丢失，在纯粹的累计确认协议下，接收方不能说它成功收到了1,000到9,999字节，但未收到包含0到999字节的第一个分组。因而，发送方可能必须重传所有1万个字节。</p>
<p>为此，TCP采取了“选择确认”（selective acknowledgment，SACK）选项。RFC 2018对此定义为允许接收方确认它成功收到的分组的不连续的块，以及基础TCP确认的成功收到最后连续字节序号。这种确认可以指出SACK block，包含了已经成功收到的连续范围的开始与结束字节序号。在上述例子中，接收方可以发出SACK指出序号1000到9999，发送方因此知道只需重发第一个分组(字节 0 到 999)。</p>
<p>TCP发送方会把乱序收包当作丢包，因此会重传乱序收到的包，导致连接的性能下降。重复SACK选项（duplicate-SACK option）是定义在RFC 2883中的SACK的一项扩展，可解决这一问题。接收方发出D-ACK指出没有丢包，接收方恢复到高传输率。D-SACK使用了SACK的第一个段来做标志，</p>
<ul>
<li>如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK;</li>
<li>如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK</li>
</ul>
<p>D-SACK旨在告诉发送端：收到了重复的数据，数据包没有丢，丢的是ACK包；或者“Fast Retransmit算法”触发的重传不是因为发出去的包丢了，也不是因为回应的ACK包丢了，而是因为网络延时导致的reordering。</p>
<p>SACK选项并不是强制的。仅当双端都支持时才会被使用。TCP连接创建时会在TCP头中协商SACK细节。在 Linux下，可以通过<code>tcp_sack</code>参数打开SACK功能（Linux 2.4后默认打开）。Linux下的<code>tcp_dsack</code>参数用于开启D-SACK功能（Linux 2.4后默认打开）。选择确认也用于流控制传输协议 (SCTP).</p>
<h3 id="TCP窗口缩放选项"><a href="#TCP窗口缩放选项" class="headerlink" title="TCP窗口缩放选项"></a>TCP窗口缩放选项</h3><p>TCP窗口尺寸域控制数据包在2至65,535字节。RFC 1323定义的TCP窗口缩放选项用于把最大窗口尺寸从65,535字节扩大至1G字节。扩大窗口尺寸是TCP优化的需要。</p>
<p>窗口缩放选项尽在TCP三次握手时双端在SYN包中独立指出这个方向的缩放系数。该值是16比特窗口尺寸的向左位移数，从0 (表示不位移)至14。</p>
<p>某些路由器或分组防火墙会重写窗口缩放选项，这可能导致不稳定的网络传输。</p>
<h3 id="TCP时间戳"><a href="#TCP时间戳" class="headerlink" title="TCP时间戳"></a>TCP时间戳</h3><p>RFC 1323定义了TCP时间戳，并不对应于系统时钟，使用随机值初始化。许多操作系统每毫秒增加一次时间戳；但RFC只规定tick应当成比例。</p>
<p>有两个时间戳域:</p>
<ul>
<li>4字节的发送时间戳值</li>
<li>4字节的响应回复时间戳值（最近收到数据的时间戳）</li>
</ul>
<p>TCP时间戳用于“防止序列号回绕算法”（Protection Against Wrapped Sequence numbers，PAWS），细节见RFC 1323。PAWS用于接收窗口跨序号回绕边界。这种情形下一个包可能会重传以回答问题：“是否是第一个还是第二个4 GB的序号？”时间戳可以打破这一问题。</p>
<p>另外，Eifel检测算法(RFC 3522)使用TCP时间戳确定如果重传发生是因为丢包还是简单乱序。</p>
<h3 id="带外数据"><a href="#带外数据" class="headerlink" title="带外数据"></a>带外数据</h3><p>带外数据（out-of-band data，OOB）是指对紧急数据，中断或放弃排队中的数据流；接收方应立即处理紧急数据。完成后，TCP通知应用程序恢复流队列的正常处理。</p>
<p>OOB并不影响网络，“紧急”仅影响远程端的处理。这一协议很少被实现。</p>
<h3 id="强制数据递交Forcing-data-delivery"><a href="#强制数据递交Forcing-data-delivery" class="headerlink" title="强制数据递交Forcing data delivery"></a>强制数据递交Forcing data delivery</h3><p>正常情况下，TCP等待200 ms以准备一个完整分组发出（纳格算法试图把小的信息组装为单一的包）。者产生了小的、但潜在很严重的延迟并在传递一个文件时不断重复延迟。例如，典型发送块是4 KB，典型的MSS是1460字节，在10 Mbit/s以太网上发出两个包，每个耗时约~1.2 ms，随后是剩余1176个字节的包，之后是197 ms停顿因为TCP等待装满缓冲区。</p>
<p>对于telnet，每次用户击键的回应，如果有200 ms将会非常烦人。</p>
<p>socket选项TCP_NODELAY能放弃默认的200 ms发送延迟。应用程序使用这个socket选项强制发出数据。</p>
<p>RFC定义了PSH能立即发出比特。Berkeley套接字不能控制或指出这种情形，只能由协议栈控制.</p>
<h3 id="终结通路"><a href="#终结通路" class="headerlink" title="终结通路"></a>终结通路</h3><p>连接终止使用了四路握手过程（或称四次握手，four-way handshake），在这个过程中连接的每一侧都独立地被终止。<strong>当一个端点要停止它这一侧的连接，就向对侧发送FIN，对侧回复ACK表示确认。因此，拆掉一侧的连接过程需要一对FIN和ACK，分别由两侧端点发出。</strong></p>
<p>首先发出FIN的一侧，如果给对侧的FIN响应了ACK，那么就会超时等待2*MSL时间，然后关闭连接。在这段超时等待时间内，本地的端口不能被新连接使用；避免延时的包的到达与随后的新连接相混淆。RFC793定义了MSL为2分钟，Linux设置成了30s。参数<code>tcp_max_tw_buckets</code>控制并发的<code>TIME_WAIT</code>的数量，默认值是180000，如果超限，那么，系统会把多的<code>TIME_WAIT</code>状态的连接给destory掉，然后在日志里打一个警告（如：time wait bucket table overflow）</p>
<p>连接可以工作在半开状态。即一侧关闭了连接，不再发送数据；但另一侧没有关闭连接，仍可以发送数据。已关闭的一侧仍然应接收数据，直至对侧也关闭了连接。</p>
<p>也可以通过测三次握手关闭连接。主机A发出FIN，主机B回复FIN &amp; ACK，然后主机A回复ACK</p>
<p>一些主机（如Linux或HP-UX）的TCP栈能实现半双工关闭序列。这种主机如果主动关闭一个连接但还没有读完从这个连接已经收到的数据，该主机发送RST代替FIN[14]。这使得一个TCP应用程序能确认远程应用程序已经读了所有已发送数据，并等待远程侧发出的FIN。但是远程的TCP栈不能区分Connection Aborting RST与Data Loss RST，两种原因都会导致远程的TCP栈失去所有的收到数据。</p>
<p>一些应用协议使用TCP open/close handshaking，因为应用协议的TCP open/close handshaking可以发现主动关闭的RST问题。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">s = connect(remote);</span><br><span class="line">send(s, data);</span><br><span class="line">close(s);</span><br></pre></td></tr></table></figure>
<p>TCP/IP栈采用上述方法不能保证所有数据到达对侧，如果未读数据已经到达对侧。</p>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>用户数据包协议（英语：User Datagram Protocol，缩写为UDP），又称用户数据报文协议，是一个简单的面向数据报的传输层协议</p>
<p>UDP 仅提供在相应应用程序之间传输数据段的基本功能，需要很少的开销和数据检查。UDP 是一种尽力传输协议。在网络环境中，尽力传输被称为不可靠传输，因为它缺乏目的设备对所收到数据的确认机制。UDP 中没有通知发送方是否成功传输的传输层流程。</p>
<h2 id="UDP-特征"><a href="#UDP-特征" class="headerlink" title="UDP 特征"></a>UDP 特征</h2><ul>
<li>会重新组织数据以便接受</li>
<li>不会发送任何丢失的数据分段</li>
<li>不会建立会话</li>
<li>不会告诉发送者资源是否可用</li>
</ul>
<h2 id="UDP报头结构"><a href="#UDP报头结构" class="headerlink" title="UDP报头结构"></a>UDP报头结构</h2><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1fmnezenc3gj30fa075dft.jpg" alt=""></p>
<p>UDP报头包括4个字段，每个字段占用2个字节（即16个二进制位）。在IPv4中，“来源连接端口”和“校验和”是可选字段。在IPv6中，只有来源连接端口是可选字段。</p>
<ul>
<li>源端口：源端口号，在需要对方回信时选用，不需要时可全 0.</li>
<li>目的端口：目的端口号，在终点交付报文时必须要使用到。</li>
<li>长度：UDP 用户数据报的长度，在只有首部的情况，其最小值是 8 。</li>
<li>检验和：检测 UDP 用户数据报在传输中是否有错，有错就丢弃。该字段在IPv4中是可选的，在IPv6中则是强制的。如果不使用校验和，该字段应被填充为全0。</li>
</ul>
<h2 id="UDP-数据报重组"><a href="#UDP-数据报重组" class="headerlink" title="UDP 数据报重组"></a>UDP 数据报重组</h2><p>与 TCP 数据段类似，当将多个 UDP 数据报发送到目的主机时，它们通常采用不同的路径，到达顺序也可能跟发送时的顺序不同。UDP 跟踪序列号的方式与 TCP 不同。因此，UDP 仅仅是将接收到的数据按照先来后到的顺序转发到应用程序。如果数据顺序对应用程序很重要，应用程序必须确定正确的顺序并决定如何处理数据。</p>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ul>
<li><strong>port number</strong> - numbers that are assigned to the source and destination at Layer 4 to uniquely identify the communication</li>
<li><strong>conversation multiplexing</strong> - the combining of many different conversations into one data stream</li>
<li><strong>segment</strong> - a block of application data created to facilitate network transport</li>
<li><strong>TCP</strong> - a connection-oriented reliable protocol that uses a 3-way handshake</li>
<li><strong>UDP</strong>- a connectionless protocol that has little overhead and is used for communication data such as voice and video</li>
<li><strong>best effort delivery</strong> - a data delivery method that has no service guarantee</li>
<li><strong>session</strong> - a connection between systems</li>
<li><strong>connection-oriented</strong> - used to describe the reliable nature of TCP. The connection refers to the 3-way handshake required in TCP before data transmission.</li>
<li><strong>flow control</strong> - a mechanism that is used with TCP to control the amount of traffic that is sent from the source to the destination</li>
<li><strong>datagrams</strong> - the name of the UDP PDU</li>
<li><strong>source port</strong> - a value between 1024 and 65535 used to uniquely identify the source application or process on a local host</li>
<li><strong>destination port</strong> - a port value that uniquely identifies the destination application</li>
<li><strong>well-known ports</strong> - port numbers in the range of 1-1024 that identify network applications that are well known such as web, email, and remote login applications</li>
<li><strong>dynamic ports</strong> - ports that are dynamically assigned to communication sessions as needed and are typically in the numerical range of 1024 to 65535</li>
<li><strong>nestat</strong> - a utility that tracks TCP connections on network hosts</li>
</ul>
]]></content>
      <categories>
        <category>ESAIP</category>
        <category>CCNA</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA Chapter 8: Subnetting IP Networks</title>
    <url>/2017/12/19/CCNA-Chapter-8-Subnetting-IP-Networks/</url>
    <content><![CDATA[<p>设计、实施和管理有效的 IP 编址规划能确保网络高效率地有效运行。随着连接到网络的主机数的增加，情况更是如此。理解 IP 地址的分层结构和如何修改该分层结构以更有效地满足路由要求，对于制定 IP 编址方案非常重要。</p>
<p>原始 IPv4 地址中有两级分层结构：网络和主机。这两级编址可以提供基础网络分组，便于将数据包路由到目的网络。路由器根据 IP 地址的网络部分转发数据包。一旦确定了网络位置，则地址的主机部分就可以标识目的设备。</p>
<p>但是，随着网络不断扩大，许多组织将数百甚至数千台主机添加到其网络中，两级分层结构就显得不足。</p>
<p>将网络细分，在网络分层结构中添加一个级别，实际上是创建三个级别：网络、子网和主机。分层结构中另一级别的引入在 IP 网络中创建了额外的子分组，使数据传输更快并且通过帮助最小化“本地”流量增加了过滤。</p>
<p>本章将通过子网掩码的使用详细分析 IP 网络和子网地址的创建和分配。</p>
<h1 id="对于子网划分的具体方法，可以百度谷歌查阅相关的博客，这里不再赘述，有时间再补充！"><a href="#对于子网划分的具体方法，可以百度谷歌查阅相关的博客，这里不再赘述，有时间再补充！" class="headerlink" title="对于子网划分的具体方法，可以百度谷歌查阅相关的博客，这里不再赘述，有时间再补充！"></a>对于子网划分的具体方法，可以百度谷歌查阅相关的博客，这里不再赘述，有时间再补充！</h1><p>子网划分的原因有几个</p>
<ul>
<li>大型网络下广播存在问题，表现在网络运行缓慢，原因是它导致的流量太大；设备运行缓慢，原因是设备必须接受和处理每个广播数据包</li>
<li>划分子网便于网络进行管理</li>
</ul>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ul>
<li><strong>subnetting</strong> - the process of subdividing a network into smaller groupings of devices, or subnets</li>
<li><strong>broadcast domain</strong> - an area within which a broadcast transmission will be shared</li>
<li><strong>subnet</strong> - a subdivision of a network that is created either to conserve addresses or to support specific network requirements.</li>
<li><strong>VLSM</strong> - allows subnets of different sizes to be created from the same network address</li>
</ul>
]]></content>
      <categories>
        <category>ESAIP</category>
        <category>CCNA</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA Chapter 7: IP Addressing</title>
    <url>/2017/12/19/CCNA-Chapter-7-IP-Addressing/</url>
    <content><![CDATA[<p>互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址），缩写为 IP 地址（英语：IP Address），是分配给网络上使用网际协议（英语：Internet Protocol, IP）的设备的数字标签。常见的 IP 地址分为 IPv4 与 IPv6 两大类。</p>
<h1 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h1><p>对于同一网络中的所有设备，地址的网络部分中的位必须完全相同。地址的主机部分中的位必须唯一，这方便识别网络中的特定主机。如果两台主机在 32 位数据流中的指定网络部分有相同的位模式，则这两台主机位于同一网络。主机如何知道 32 位数据流中的哪一部分用于标识网络，哪一部分用于标识主机呢？这项工作由子网掩码（ subnet mask）负责。</p>
<h2 id="IPv4-编址格式"><a href="#IPv4-编址格式" class="headerlink" title="IPv4 编址格式"></a>IPv4 编址格式</h2><p>IPv4 地址可被写作任何表示一个 32 位整数值的形式，但为了方便人类阅读和分析，它通常被写作点分十进制的形式，即四个字节被分开用十进制写出，中间用点分隔。</p>
<p>下表展示了几种不同的格式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">格式</th>
<th style="text-align:center">值</th>
<th style="text-align:center">从点分十进制转换</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">点分十进制</td>
<td style="text-align:center">192.0.2.235</td>
<td style="text-align:center">不适用</td>
</tr>
<tr>
<td style="text-align:center">点分十六进制</td>
<td style="text-align:center">0xC0.0x00.0x02.0xEB</td>
<td style="text-align:center">每个字节被单独转换为十六进制</td>
</tr>
<tr>
<td style="text-align:center">点分八进制</td>
<td style="text-align:center">0300.0000.0002.0353</td>
<td style="text-align:center">每个字节被单独转换为八进制</td>
</tr>
<tr>
<td style="text-align:center">十六进制</td>
<td style="text-align:center">0xC00002EB</td>
<td style="text-align:center">将点分十六进制连在一起</td>
</tr>
<tr>
<td style="text-align:center">十进制</td>
<td style="text-align:center">3221226219</td>
<td style="text-align:center">用十进制写出的 32 位整数</td>
</tr>
<tr>
<td style="text-align:center">八进制</td>
<td style="text-align:center">030000001353</td>
<td style="text-align:center">用八进制写出的 32 位整数</td>
</tr>
</tbody>
</table>
</div>
<p>此外，在点分格式中，每个字节都可用任意的进制表达。如，192.0x00.0002.235 是一种合法（但不常用）的表示。</p>
<a id="more"></a>
<h2 id="特殊用途的地址"><a href="#特殊用途的地址" class="headerlink" title="特殊用途的地址"></a>特殊用途的地址</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">CIDR 地址块</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">参考资料</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0.0.0.0/8</td>
<td style="text-align:center">本网络（仅作为源地址时合法）</td>
<td style="text-align:center">RFC 5735</td>
</tr>
<tr>
<td style="text-align:center">10.0.0.0/8</td>
<td style="text-align:center">专用网络</td>
<td style="text-align:center">RFC 1918</td>
</tr>
<tr>
<td style="text-align:center">100.64.0.0/10</td>
<td style="text-align:center">地址共享</td>
<td style="text-align:center">RFC 6598</td>
</tr>
<tr>
<td style="text-align:center">127.0.0.0/8</td>
<td style="text-align:center">环回</td>
<td style="text-align:center">RFC 5735</td>
</tr>
<tr>
<td style="text-align:center">169.254.0.0/16</td>
<td style="text-align:center">链路本地</td>
<td style="text-align:center">RFC 3927</td>
</tr>
<tr>
<td style="text-align:center">172.16.0.0/12</td>
<td style="text-align:center">专用网络</td>
<td style="text-align:center">RFC 1918</td>
</tr>
<tr>
<td style="text-align:center">192.0.0.0/24</td>
<td style="text-align:center">保留（IANA）</td>
<td style="text-align:center">RFC 5735</td>
</tr>
<tr>
<td style="text-align:center">192.0.2.0/24</td>
<td style="text-align:center">TEST-NET-1，文档和示例</td>
<td style="text-align:center">RFC 5735</td>
</tr>
<tr>
<td style="text-align:center">192.88.99.0/24</td>
<td style="text-align:center">6to4 中继</td>
<td style="text-align:center">RFC 3068</td>
</tr>
<tr>
<td style="text-align:center">192.168.0.0/16</td>
<td style="text-align:center">专用网络</td>
<td style="text-align:center">RFC 1918</td>
</tr>
<tr>
<td style="text-align:center">198.18.0.0/15</td>
<td style="text-align:center">网络基准测试</td>
<td style="text-align:center">RFC 2544</td>
</tr>
<tr>
<td style="text-align:center">198.51.100.0/24</td>
<td style="text-align:center">TEST-NET-2，文档和示例</td>
<td style="text-align:center">RFC 5737</td>
</tr>
<tr>
<td style="text-align:center">203.0.113.0/24</td>
<td style="text-align:center">TEST-NET-3，文档和示例</td>
<td style="text-align:center">RFC 5737</td>
</tr>
<tr>
<td style="text-align:center">224.0.0.0/4</td>
<td style="text-align:center">多播（之前的 D 类网络）</td>
<td style="text-align:center">RFC 3171</td>
</tr>
<tr>
<td style="text-align:center">240.0.0.0/4</td>
<td style="text-align:center">保留（之前的 E 类网络）</td>
<td style="text-align:center">RFC 1700</td>
</tr>
<tr>
<td style="text-align:center">255.255.255.255</td>
<td style="text-align:center">受限广播</td>
<td style="text-align:center">RFC 919</td>
</tr>
</tbody>
</table>
</div>
<h3 id="专用网络"><a href="#专用网络" class="headerlink" title="专用网络"></a>专用网络</h3><p>在 IPv4 所允许的大约四十亿地址中，三个地址块被保留作专用网络。这些地址块在专用网络之外不可路由，专用网络之内的主机也不能直接与公共网络通信。但通过网络地址转换（NAT），使用这些地址的主机可以像拥有共有地址的主机在互联网上通信。</p>
<p>下表展示了三个被保留作专用网络的地址块（RFC 1918）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名字</th>
<th style="text-align:center">地址范围</th>
<th style="text-align:center">地址数量</th>
<th style="text-align:center">有类别的描述</th>
<th style="text-align:center">最大的 CIDR 地址块</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">24 位块</td>
<td style="text-align:center">10.0.0.0–10.255.255.255</td>
<td style="text-align:center">16,777,216</td>
<td style="text-align:center">一个 A 类</td>
<td style="text-align:center">10.0.0.0/8</td>
</tr>
<tr>
<td style="text-align:center">20 位块</td>
<td style="text-align:center">172.16.0.0–172.31.255.255</td>
<td style="text-align:center">1,048,576</td>
<td style="text-align:center">连续的 16 个 B 类</td>
<td style="text-align:center">172.16.0.0/12</td>
</tr>
<tr>
<td style="text-align:center">16 位块</td>
<td style="text-align:center">192.168.0.0–192.168.255.255</td>
<td style="text-align:center">65,536</td>
<td style="text-align:center">连续的 256 个 C 类</td>
<td style="text-align:center">192.168.0.0/16</td>
</tr>
</tbody>
</table>
</div>
<h3 id="环回地址-Loopback-Address"><a href="#环回地址-Loopback-Address" class="headerlink" title="环回地址 (Loopback Address)"></a>环回地址 (Loopback Address)</h3><p>地址块 127.0.0.0/8 被保留作环回通信用。此范围中的地址绝不应出现在主机之外，发送至此地址的报文被作为同一虚拟网络设备上的入站报文（环回），主要用于检查 TCP/IP 协议栈是否正确运行和本机对本机的链接。</p>
<h3 id="本地链路地址"><a href="#本地链路地址" class="headerlink" title="本地链路地址"></a>本地链路地址</h3><p>链路本地地址（Link-local address）是计算机网络中一类特殊的地址， 通常被称为自动私有 IP 编址 (APIPA) 地址。Windows DCHP 客户端在无可用 DHCP 服务器时，使用它们进行自我配置。在对等连接中非常有用。</p>
<p>它仅供于在网段，或广播域中的主机相互通信使用。这类主机通常不需要外部互联网服务，仅有主机间相互通讯的需求。</p>
<p>IPv4 链路本地地址定义在 169.254.0.0/16 地址块。 IPv6 定义在 fe80::/10 地址块。</p>
<h3 id="以-0-或-255-结尾的地址"><a href="#以-0-或-255-结尾的地址" class="headerlink" title="以 0 或 255 结尾的地址"></a>以 0 或 255 结尾的地址</h3><p>一个常见的误解是以 0 或 255 结尾的地址永远不能分配给主机：这仅在子网掩码至少 24 位长度时（旧的 C 类地址，或 CIDR 中的/24 到/32）才成立。</p>
<p>在有类别的编址中，只有三种可能的子网掩码：A 类：255.0.0.0，B 类：255.255.0.0，C 类：255.255.255.0。如，在子网 192.168.5.0/255.255.255.0（即 192.168.5.0/24）中，网络识别码 192.168.5.0 用来表示整个子网，所以它不能用来标识子网上的某个特定主机。</p>
<p>广播地址允许数据包发往子网上的所有设备。一般情况下，广播地址是借由子网掩码的比特反码并和网络识别码运行 OR 的比特运算得到，即广播地址是子网中的最后一个地址。在上述例子中，广播地址是 192.168.5.255，所以为了避免歧义，这个地址也不能被分配给主机。在 A、B 和 C 类网络中，广播地址总是以 255 结尾。</p>
<p>但是，这并不意味着每个以 255 结尾的地址都不能用做主机地址。比如，在 B 类子网 192.168.0.0/255.255.0.0（即 192.168.0.0/16）中，广播地址是 192.168.255.255（主机位全 1）。在这种情况下，尽管可能带来误解，但 192.168.1.255、192.168.2.255 等地址可以被分配给主机。同理，192.168.0.0 作为网络识别码不能被分配，但 192.168.1.0、192.168.2.0 等都是可以的。</p>
<p>随着 CIDR 的到来，广播地址不一定总是以 255 结尾（广播地址是指主机位都为 1 的地址，255 只是其中一种情况）。比如，子网 203.0.113.16/28 的广播地址是 203.0.113.31。</p>
<p>一般情况下，子网的第一个和最后一个地址分别被作为网络识别码和广播地址，任何其它地址都可以被分配给其上的主机。</p>
<h2 id="分类网络"><a href="#分类网络" class="headerlink" title="分类网络"></a>分类网络</h2><p>分类网络（Classful Addressing）或称“分级式定址”，是在互联网 IPv4 还未出现枯竭问题的时候，用于描述互联网的网络体系的一个术语。它将 IPv4 的 IP 地址分成五个类别。每个类别的地址都由它们的前 3 位来标识；每个类别都定义了网络的大小或者类型（单播或多播）。</p>
<p>为了和已存在的 IP 地址空间及 IP 数据报兼容，对 IP 地址的定义在 1981 年的 RFC 791 进行了修改。修改后的 IP 地址共有三种网络地址长度不同的单播地址。如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Class</th>
<th style="text-align:center">前缀位</th>
<th style="text-align:center">网络地址位数</th>
<th style="text-align:center">剩余的位数</th>
<th style="text-align:center">网络数</th>
<th style="text-align:center">每个网络的主机数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A 类地址</td>
<td style="text-align:center">0</td>
<td style="text-align:center">8</td>
<td style="text-align:center">24</td>
<td style="text-align:center">128</td>
<td style="text-align:center">16,777,214</td>
</tr>
<tr>
<td style="text-align:center">B 类地址</td>
<td style="text-align:center">10</td>
<td style="text-align:center">16</td>
<td style="text-align:center">16</td>
<td style="text-align:center">16,384</td>
<td style="text-align:center">65,534</td>
</tr>
<tr>
<td style="text-align:center">C 类地址</td>
<td style="text-align:center">110</td>
<td style="text-align:center">24</td>
<td style="text-align:center">8</td>
<td style="text-align:center">2,097,152</td>
<td style="text-align:center">254</td>
</tr>
<tr>
<td style="text-align:center">D 类地址（群播）</td>
<td style="text-align:center">1110</td>
<td style="text-align:center">未定义</td>
<td style="text-align:center">未定义</td>
<td style="text-align:center">未定义</td>
<td style="text-align:center">未定义</td>
</tr>
<tr>
<td style="text-align:center">E 类地址（保留）</td>
<td style="text-align:center">1111</td>
<td style="text-align:center">未定义</td>
<td style="text-align:center">未定义</td>
<td style="text-align:center">未定义</td>
<td style="text-align:center">未定义</td>
</tr>
</tbody>
</table>
</div>
<p>可用的主机地址总是 2N - 2（N 是所用的位数，减 2 是因为第一个和最后一个地址都是无效的）。因此，对于用 8 位来表示主机地址的 C 类地址来说，主机数就是 254。</p>
<p>但是比较两个 IP 地址的物理网络的方法没有改变。对每个地址，在确定它的网络地址所占的位数和相应的值之后，就可以比较它们的网络地址了。如果两个网络地址相同，则两个 IP 地址在同一网络上</p>
<p>第一轮的改变在短期内已经足够，但是 IP 地址仍然在不断变得短缺。其中主要的问题是，多数的网站对 c 类的网络地址来说太大了，因此它们都得到了 b 类的地址。随着互联网的快速发展，b 类的地址（共 214 个）迅速减少。分类网络于 1993 年被无类别域间路由取代以解决这个问题。</p>
<h2 id="无类别域间路由"><a href="#无类别域间路由" class="headerlink" title="无类别域间路由"></a>无类别域间路由</h2><p>无类别域间路由（Classless Inter-Domain Routing、CIDR）是一个用于给用户分配 IP 地址以及在互联网上有效地路由 IP 数据包的对 IP 地址进行归类的方法。用来解决基于分类网络下，IPv4 地址分配不足的问题</p>
<p>无类别域间路由是基于可变长子网掩码（VLSM）来进行任意长度的前缀的分配的。CIDR 包括：</p>
<ul>
<li>指定任意长度的前缀的可变长子网掩码技术。遵从 CIDR 规则的地址有一个后缀说明前缀的位数，例如：192.168.0.0/16。这使得对日益缺乏的 IPv4 地址的使用更加有效。</li>
<li>将多个连续的前缀聚合成超网，以及，在互联网中，只要有可能，就显示为一个聚合的网络，因此在总体上可以减少路由表的表项数目。聚合使得互联网的路由表不用分为多级，并通过 VLSM 逆转“划分子网”的过程。</li>
<li>根据机构的实际需要和短期预期需要而不是分类网络中所限定的过大或过小的地址块来管理 IP 地址的分配的过程。</li>
</ul>
<h1 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h1><p>网际协议第 6 版（英文：Internet Protocol version 6，缩写：IPv6）是网际协议（IP）的最新版本，用作互联网的网络层协议，用它来取代 IPv4 主要是为了解决 IPv4 地址枯竭问题，不过它也在其他很多方面对 IPv4 有所改进。</p>
<p>IPv6 具有比 IPv4 大得多的编码地址空间。这是因为 IPv6 采用 128 位的地址，而 IPv4 使用的是 32 位。因此新增的地址空间支持 2128（约 3.4×1038）个地址，具体数量为 340,282,366,920,938,463,463,374,607,431,768,211,456 个，也可以说成 1632 个，因为 32 位地址每位可以取 16 个不同的值。</p>
<h2 id="IPv6-编址格式"><a href="#IPv6-编址格式" class="headerlink" title="IPv6 编址格式"></a>IPv6 编址格式</h2><p>IPv6 从 IPv4 到 IPv6 最显著的变化就是网络地址的长度。RFC 2373 和 RFC 2374 定义的 IPv6 地址有 128 位长；IPv6 地址的表达形式一般采用 32 个十六进制数。</p>
<p>在很多场合，IPv6 地址由两个逻辑部分组成：<strong>一个 64 位的网络前缀和一个 64 位的主机地址</strong>，主机地址通常根据物理地址自动生成，叫做 EUI-64（或者 64-位扩展唯一标识）</p>
<p>IPv6 二进位制下为 128 位长度，以 16 位为一组，每组以冒号“:”隔开，可以分为 8 组，每组以 4 位十六进制方式表示。例如：2001:0db8:85a3:08d3:1319:8a2e:0370:7344 是一个合法的 IPv6 地址。</p>
<p>同时 IPv6 在某些条件下可以省略：</p>
<ol>
<li>每项数字前导的 0 可以省略，省略后前导数字仍是 0 则继续，例如下组 IPv6 是相等的。<ul>
<li>2001:0DB8:<strong>0</strong>2de:<strong>0000</strong>:<strong>0000</strong>:<strong>0000</strong>:<strong>0000</strong>:<strong>0</strong>e13</li>
<li>2001:DB8:2de:<strong>0000</strong>:<strong>0000</strong>:<strong>0000</strong>:<strong>0000</strong>:e13</li>
<li>2001:DB8:2de:<strong>000</strong>:<strong>000</strong>:<strong>000</strong>:<strong>000</strong>:e13</li>
<li>2001:DB8:2de:<strong>00</strong>:<strong>00</strong>:<strong>00</strong>:<strong>00</strong>:e13</li>
<li>2001:DB8:2de:<strong>0</strong>:<strong>0</strong>:<strong>0</strong>:<strong>0</strong>:e13</li>
</ul>
</li>
<li>可以用双冒号“::”表示一组 0 或多组连续的 0，但只能出现一次：<ol>
<li>如果四组数字都是零，可以被省略。遵照以上省略规则，下面这两组 IPv6 都是相等的。<ul>
<li>2001:DB8:2de:<strong>0</strong>:<strong>0</strong>:<strong>0</strong>:<strong>0</strong>:e13</li>
<li>2001:DB8:2de::e13</li>
<li>2001:0DB8:0000:0000:0000:0000:1428:57ab</li>
<li>2001:0DB8:0000:0000:0000::1428:57ab</li>
<li>2001:0DB8:0:0:0:0:1428:57ab</li>
<li>2001:0DB8:0::0:1428:57ab</li>
<li>2001:0DB8::1428:57ab</li>
</ul>
</li>
<li>2001::25de::cade 是非法的，因为双冒号出现了两次。它有可能是下种情形之一，造成无法推断。</li>
</ol>
<ul>
<li>2001:0000:0000:0000:0000:25de:0000:cade</li>
<li>2001:0000:0000:0000:25de:0000:0000:cade</li>
<li>2001:0000:0000:25de:0000:0000:0000:cade</li>
<li>2001:0000:25de:0000:0000:0000:0000:cade</li>
</ul>
<ol>
<li>如果这个地址实际上是 IPv4 的地址，后 32 位可以用 10 进制数表示；因此::ffff:192.168.89.9 相等于::ffff:c0a8:5909，但不等于::192.168.89.9 和::c0a8:5909。</li>
</ol>
</li>
</ol>
<p>另外，::ffff:1.2.3.4 格式叫做 IPv4 映射地址。而::1.2.3.4 格式叫做 IPv4 一致地址，目前已被取消。</p>
<p>IPv4 位址可以很容易的转化为 IPv6 格式。举例来说，如果 IPv4 的一个地址为 135.75.43.52（十六进制为 0x874B2B34），它可以被转化为 0000:0000:0000:0000:0000:ffff:874B:2B34 或者::ffff:874B:2B34。同时，还可以使用混合符号（IPv4-compatible address），则地址可以为::ffff:135.75.43.52。</p>
<h3 id="IPv6-全局单播地址结构"><a href="#IPv6-全局单播地址结构" class="headerlink" title="IPv6 全局单播地址结构"></a>IPv6 全局单播地址结构</h3><p>IPv6 全局单播地址 (GUA) 具有全局唯一性，可在 IPv6 Internet 上路由。这些地址相当于公有 IPv4 地址。互联网名称与数字地址分配机构 (ICANN)，即 IANA 的运营商，将 IPv6 地址块分配给五家 RIR。目前分配的仅是前三位为 001 或 2000:: /3 的全局单播地址。换句话说，GUA 地址的第一个十六进制数以 2 或 3 开头。这只是可用 IPv6 地址空间的 1/8，对于其他类型单播和组播地址而言只是很小的一部分。</p>
<p>注意：2001:0DB8::/32 已经留作备档之用，包括示例用途。</p>
<p>全局单播地址有三个部分：</p>
<ul>
<li>全局路由前缀</li>
<li>子网 ID</li>
<li>接口 ID</li>
<li>全局路由前缀</li>
</ul>
<p>全局路由前缀为提供商（如 ISP）分配给客户或站点的地址的前缀或网络部分。一般来说，RIR 向客户分配 /48 全局路由前缀。这包括从公司企业网络到单个家庭网络中的每个站点。</p>
<p>如图显示使用 /48 全局路由前缀的全局单播地址结构。/48 前缀是分配的最常见全局路由前缀<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1fmmj5uv6f2j30h404st96.jpg" alt=""><br>例如，IPv6 地址 2001:0DB8:ACAD::/48 的前缀显示前 48 位（3 个十六进制数）(2001:0DB8:ACAD) 是该地址的前缀或网络部分。/48 前缀长度前的双冒号 (::) 表示地址的剩余部分全部为 0。</p>
<p>全局路由前缀的大小决定子网 ID 的大小。</p>
<ul>
<li>子网 ID 组织使用子网 ID 确定其站点的子网。子网 ID 越大，可用子网越多。</li>
<li>接口 ID IPv6 接口 ID 相当于 IPv4 地址的主机部分。使用术语“接口 ID”是因为单个主机可能有多个接口，而每个接口又有一个或多个 IPv6 地址。强烈建议在大多数情况下使用 /64 子网。换言之，如图 2 所示的 64 位接口 ID。</li>
</ul>
<p>注意：与 IPv4 不同，在 IPv6 中，全 0 和全 1 主机地址可以分配给设备。全 1 地址可以使用是因为 IPv6 中不使用广播地址。全 0 地址也可使用，但它留作子网路由器任播地址，应仅分配给路由器。</p>
<p>读取多数 IPv6 地址的一种简单方法是计算十六进制数。如图 3 所示，在 /64 全局单播地址中，前四个十六进制数是地址的网络部分，其中第四个十六进制数表示子网 ID。剩下的四个十六进制数用于接口 ID。</p>
<h3 id="特殊地址"><a href="#特殊地址" class="headerlink" title="特殊地址"></a>特殊地址</h3><p>IPv6 中有些地址是有特殊含义的：</p>
<ul>
<li>未指定地址<ul>
<li>::/128－所有比特皆为零的地址称作未指定地址。这个地址不可指定给某个网络接口，并且只有在主机尚未知道其来源 IP 时，才会用于软件中。路由器不可转送包含未指定地址的数据包。</li>
</ul>
</li>
<li>链路本地地址<ul>
<li>::1/128－是一种单播绕回地址。如果一个应用程序将数据包送到此地址，IPv6 堆栈会转送这些数据包绕回到同样的虚拟接口（相当于 IPv4 中的 127.0.0.1/8）。</li>
<li>fe80::/10－这些链路本地地址指明，这些地址只在区域连接中是合法的，这有点类似于 IPv4 中的 169.254.0.0/16。</li>
</ul>
</li>
<li>唯一区域位域<ul>
<li>fc00::/7－唯一区域地址（ULA，unique local address）只可在一群网站中绕送。这定义在 RFC 4193 中，是用来取代站点本地位域。这地址包含一个 40 比特的伪随机数，以减少当网站合并或数据包误传到网络时碰撞的风险。这些地址除了只能用于区域外，还具备全域性的范畴，这点违反了唯一区域位域所取代的站点本地地址的定义。</li>
</ul>
</li>
<li>多播地址<ul>
<li>ff00::/8－这个前置表明定义在”IP Version 6 Addressing Architecture”（RFC 4291）中的多播地址。其中，有些地址已用于指定特殊协议，如 ff0X::101 对应所有区域的 NTP 服务器（RFC 2375）。</li>
</ul>
</li>
<li>请求节点多播地址（Solicited-node multicast address）<ul>
<li>ff02::1:FFXX:XXXX－XX:XXXX 为相对应的单播或任播地址中的三个最低的字节。</li>
</ul>
</li>
<li><a href="#ipv4">IPv4</a><ul>
<li><a href="#ipv4-%E7%BC%96%E5%9D%80%E6%A0%BC%E5%BC%8F">IPv4 编址格式</a></li>
<li><a href="#%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E7%9A%84%E5%9C%B0%E5%9D%80">特殊用途的地址</a><ul>
<li><a href="#%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C">专用网络</a></li>
<li><a href="#%E7%8E%AF%E5%9B%9E%E5%9C%B0%E5%9D%80-loopback-address">环回地址 (Loopback Address)</a></li>
<li><a href="#%E6%9C%AC%E5%9C%B0%E9%93%BE%E8%B7%AF%E5%9C%B0%E5%9D%80">本地链路地址</a></li>
<li><a href="#%E4%BB%A5-0-%E6%88%96-255-%E7%BB%93%E5%B0%BE%E7%9A%84%E5%9C%B0%E5%9D%80">以 0 或 255 结尾的地址</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%B1%BB%E7%BD%91%E7%BB%9C">分类网络</a></li>
<li><a href="#%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1">无类别域间路由</a></li>
</ul>
</li>
<li><a href="#ipv6">IPv6</a><ul>
<li><a href="#ipv6-%E7%BC%96%E5%9D%80%E6%A0%BC%E5%BC%8F">IPv6 编址格式</a><ul>
<li><a href="#ipv6-%E5%85%A8%E5%B1%80%E5%8D%95%E6%92%AD%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84">IPv6 全局单播地址结构</a></li>
<li><a href="#%E7%89%B9%E6%AE%8A%E5%9C%B0%E5%9D%80">特殊地址</a></li>
</ul>
</li>
<li><a href="#ipv6-%E5%9C%B0%E5%9D%80%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE">IPv6 地址的自动配置</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE---slaac">动态配置 - SLAAC</a><ul>
<li><a href="#ra-%E9%80%89%E9%A1%B9-1%EF%BC%9Aslaac">RA 选项 1：SLAAC</a></li>
<li><a href="#ra-%E9%80%89%E9%A1%B9-2%EF%BC%9Aslaac-%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81-dhcpv6">RA 选项 2：SLAAC 和无状态 DHCPv6</a></li>
<li><a href="#ra-%E9%80%89%E9%A1%B9-3%EF%BC%9A%E6%9C%89%E7%8A%B6%E6%80%81-dhcpv6">RA 选项 3：有状态 DHCPv6</a></li>
<li><a href="#eui-64-%E6%B5%81%E7%A8%8B%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90">EUI-64 流程和随机生成</a><ul>
<li><a href="#eui-64-%E6%B5%81%E7%A8%8B">EUI-64 流程</a></li>
<li><a href="#%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E7%9A%84%E6%8E%A5%E5%8F%A3-id">随机生成的接口 ID</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81%E6%9C%AC%E5%9C%B0%E9%93%BE%E8%B7%AF%E5%9C%B0%E5%9D%80">动态本地链路地址</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E6%9C%AC%E5%9C%B0%E9%93%BE%E8%B7%AF%E5%9C%B0%E5%9D%80">静态本地链路地址</a></li>
</ul>
</li>
<li><a href="#ipv4-%E5%92%8C-ipv6-%E5%85%B1%E5%AD%98">IPv4 和 IPv6 共存</a></li>
<li><a href="#%E8%BF%9E%E6%8E%A5%E9%AA%8C%E8%AF%81">连接验证</a><ul>
<li><a href="#icmpv4-%E5%92%8C-icmpv6">ICMPv4 和 ICMPv6</a></li>
<li><a href="#ping-%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%9B%9E">Ping 本地环回</a></li>
</ul>
</li>
<li><a href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A">名词解释</a></li>
</ul>
<h2 id="IPv6-地址的自动配置"><a href="#IPv6-地址的自动配置" class="headerlink" title="IPv6 地址的自动配置"></a>IPv6 地址的自动配置</h2><p>与使用 IPv4 一样，在客户端配置静态地址并不能扩展至更大的环境。因此，多数 IPv6 网络的管理员会启用 IPv6 地址的动态分配。</p>
<p>设备可以通过两种方法自动获取 IPv6 全局单播地址：</p>
<p>无状态地址自动配置 (SLAAC)<br>有状态 DHCPv6<br>注意：使用 DHCPv6 或 SLAAC 时，本地路由器的本地链路地址将自动指定为默认网关地址。</p>
<h2 id="动态配置-SLAAC"><a href="#动态配置-SLAAC" class="headerlink" title="动态配置 - SLAAC"></a>动态配置 - SLAAC</h2><p>无状态地址自动配置 (Stateless Address Autoconfiguration,SLAAC) 是允许设备从 IPv6 路由器获取 IPv6 前缀、前缀长度、默认网关地址及其他信息，而无需使用 DHCPv6 服务器的方法。使用 SLAAC，设备根据本地路由器的 ICMPv6 路由器通告 (Router Advertisement,RA) 消息获取必要信息。</p>
<p>IPv6 路由器每 200 秒定期将 ICMPv6 RA 消息发送到网络上所有支持 IPv6 的设备。在响应发送 ICMPv6 路由器请求 (RS) 消息的主机时，也会发送 RA 消息。</p>
<p>默认情况下未启用 IPv6 路由。要将路由器启用为 IPv6 路由器，必须使用 <code>ipv6 unicast-routing</code> 全局配置命令。</p>
<p>注意：IPv6 地址也可在未启用为 IPv6 路由器的路由器上配置。</p>
<p>ICMPv6 RA 消息提示设备获取 IPv6 全局单播地址的方式。最终决定取决于设备的操作系统。ICMPv6 RA 消息包括：</p>
<ul>
<li>网络前缀和前缀长度 – 告知设备其所属的网络。</li>
<li>默认网关 – IPv6 本地链路地址，RA 消息的源 IPv6 地址。</li>
<li>DNS 地址和域名 – DNS 服务器的地址和域名。</li>
</ul>
<p>RA 消息具有三个选项：</p>
<p>选项 1：SLAAC - 这里有你需要的所有信息，前缀、前缀长度、默认网关<br>选项 2：SLAAC 和无状态 DHCPv6 - 我有一部分信息，但是需要从 DHCP 服务器获取其他信息 (如 DNS 地址）。<br>选项 3：有状态 DHCPv6（无 SLAAC） - 我不能提供帮助，请向 DHCP6 请求所有信息</p>
<h3 id="RA-选项-1：SLAAC"><a href="#RA-选项-1：SLAAC" class="headerlink" title="RA 选项 1：SLAAC"></a>RA 选项 1：SLAAC</h3><p>默认情况下，RA 消息会提示接收设备使用 RA 消息中的信息创建其自己的 IPv6 全局单播地址及其他信息。DHCPv6 服务器的服务不是必需项。</p>
<p>SLAAC 是无状态的，也就是说没有中央服务器（例如有状态 DHCPv6 服务器）来分配全局单播地址和维持设备及其地址的清单。借助 SLAAC，客户端设备使用 RA 消息中的信息创建其自己的全局单播地址。</p>
<ul>
<li>前缀 – RA 消息中接收</li>
<li>接口 ID – 使用 EUI-64 流程或通过生成一个随机 64 位数字产生。</li>
</ul>
<h3 id="RA-选项-2：SLAAC-和无状态-DHCPv6"><a href="#RA-选项-2：SLAAC-和无状态-DHCPv6" class="headerlink" title="RA 选项 2：SLAAC 和无状态 DHCPv6"></a>RA 选项 2：SLAAC 和无状态 DHCPv6</h3><p>通过此选项，RA 消息给予设备以下提示：</p>
<ul>
<li>使用 SLAAC 创建其自己的 IPv6 全局单播地址.</li>
<li>使用路由器的本地链路地址，即默认网关地址的 RA 的源 IPv6 地址。</li>
<li>使用无状态 DHCPv6 服务器获取其他信息，例如 DNS 服务器地址和域名。</li>
</ul>
<p>使用无状态 DHCPv6 服务器分配 DNS 服务器地址和域名。它不分配全局单播地址。</p>
<h3 id="RA-选项-3：有状态-DHCPv6"><a href="#RA-选项-3：有状态-DHCPv6" class="headerlink" title="RA 选项 3：有状态 DHCPv6"></a>RA 选项 3：有状态 DHCPv6</h3><p>有状态 DHCPv6 与 IPv4 的 DHCP 相似。使用有状态 DHCPv6 服务器的服务，设备可自动接收编址信息，包括全局单播地址、前缀长度和 DNS 服务器地址。</p>
<p>通过此选项，RA 消息给予设备以下提示：</p>
<ul>
<li>使用路由器的本地链路地址，即默认网关地址的 RA 的源 IPv6 地址。</li>
<li>使用有状态 DHCPv6 服务器获取全局单播地址、DNS 服务器地址、域名和所有其他信息。</li>
<li>使用有状态 DHCPv6 服务器分配并维持哪台设备接收哪个 IPv6 地址的清单。IPv4 的 DHCP 是有状态的。</li>
</ul>
<h3 id="EUI-64-流程和随机生成"><a href="#EUI-64-流程和随机生成" class="headerlink" title="EUI-64 流程和随机生成"></a>EUI-64 流程和随机生成</h3><p>当 RA 消息为 SLAAC 或 SLAAC 和无状态 DHCPv6 时，客户端必须生成自己的接口 ID。客户端从 RA 消息中获知地址的前缀部分，但必须创建自己的接口 ID。接口 ID 可使用 EUI-64 流程或随机生成的 64 位数字创建。</p>
<h4 id="EUI-64-流程"><a href="#EUI-64-流程" class="headerlink" title="EUI-64 流程"></a>EUI-64 流程</h4><p>IEEE 定义了扩展唯一标识符 (EUI) 或修改的 EUI-64 流程。该流程使用客户端的 48 位以太网 MAC 地址，并在该 48 位 MAC 地址的中间插入另外 16 位来创建 64 位接口 ID。</p>
<p>以太网 MAC 地址一般使用十六进制表示，由两部分组成：</p>
<ul>
<li>组织唯一标识符 (OUI) – OUI 为 IEEE 分配的 24 位（6 个十六进制数字）厂商代码。</li>
<li>设备标识符 – 设备标识符是通用 OUI 内的唯一 24 位（6 个十六进制数字）值。</li>
</ul>
<p>EUI-64 接口 ID 以二进制表示，共分三个部分：</p>
<ul>
<li>客户端 MAC 地址的 24 位 OUI，但是第 7 位（通用/本地 (U/L) 位）颠倒。这意味着，如果第 7 位是 0，则它会变为 1，反之亦然。</li>
<li>插入的 16 位值 FFFE（十六进制）</li>
<li>客户端 MAC 地址的 24 位设备标识符</li>
</ul>
<p>注意：U/L 位的用途和该位值的翻转原因会在 RFC 5342 中讨论。</p>
<p>确定更可能使用 EUI-64 创建地址的简单方法是接口 ID 中间的 FFFE</p>
<p>EUI-64 优势在于可以使用以太网 MAC 地址确定接口 ID。这也允许网络管理员使用唯一 MAC 地址轻松跟踪终端设备的 IPv6 地址。但是，这却为很多客户带来了隐私忧虑。他们担心他们的数据包可以追溯到实际物理计算机。出于这些顾虑，可以转而使用随机生成的接口 ID。</p>
<h4 id="随机生成的接口-ID"><a href="#随机生成的接口-ID" class="headerlink" title="随机生成的接口 ID"></a>随机生成的接口 ID</h4><p>根据操作系统，设备可以使用随机生成的接口 ID，而不使用 MAC 地址和 EUI-64 流程。例如，从 Windows Vista 开始，Windows 使用随机生成的接口 ID，而不是 EUI-64 创建的接口 ID。Windows XP 和之前的 Windows 操作系统均使用 EUI-64。</p>
<p>接口 ID 创建后（无论是使用 EUI-64 流程还是通过随机生成），它都可以在 RA 消息中结合 IPv6 前缀来创建全局单播地址。</p>
<p>注意：为确保任何 IPv6 单播地址的唯一性，客户端可以使用重复地址检测 (Duplicate Address Detection,DAD) 流程。这与 ARP 请求其地址的流程相似。如该请求没有响应，则地址是唯一的。</p>
<h2 id="动态本地链路地址"><a href="#动态本地链路地址" class="headerlink" title="动态本地链路地址"></a>动态本地链路地址</h2><p>所有的 IPv6 设备必须具有 IPv6 本地链路地址。本地链路地址可以动态创建，也可作为静态本地链路地址手动配置。</p>
<p>创建本地链路地址时，会根据给出的前缀和通过 EUI-64 流程或随机生成的 64 位数字创建的接口 ID 动态创建本地链路地址。操作系统通常会将相同的办法用于 SLAAC 创建的全局单播地址和动态分配的本地链路地址。默认情况下，思科 IOS 路由器使用 EUI-64 为 IPv6 接口上的所有本地链路地址生成接口 ID。</p>
<p>为了更容易在路由器上识别和记忆这些地址，通常要在路由器上静态配置 IPv6 本地链路地址。</p>
<h2 id="静态本地链路地址"><a href="#静态本地链路地址" class="headerlink" title="静态本地链路地址"></a>静态本地链路地址</h2><p>手动配置本地链路地址使得创建的地址便于识别和记忆。一般来说，只需要在路由器上创建可识别的本地链路地址。这样做很有用，因为路由器本地链路地址将被用作默认网关地址并包含在路由通告消息中。</p>
<p>可以使用与创建 IPv6 全局单播地址相同的接口命令来手动配置本地链路地址，但还需要本地链路参数。当地址以 FE80 到 FEBF 范围的十六进制数开头时，本地链路参数必须符合该地址。</p>
<p>图中显示了使用 ipv6 address interface 命令配置的本地链路地址。使用本地链路地址 FE80::1 让系统更容易识别出它属于路由器 R1。所有 R1 接口上均配置相同的 IPv6 本地链路地址。可以在各个链路上配置 FE80::1，因为它仅需在单个链路上保持唯一性。</p>
<p>类似于 R1，将 FE80::2 配置为路由器 R2 所有接口的 IPv6 本地链路地址。</p>
<h1 id="IPv4-和-IPv6-共存"><a href="#IPv4-和-IPv6-共存" class="headerlink" title="IPv4 和 IPv6 共存"></a>IPv4 和 IPv6 共存</h1><p>过渡到 IPv6 不是一朝一夕可以完成的。在可预测的未来，IPv4 和 IPv6 将共存。该过渡预计会花费数年时间。IETF 已经创建了各种协议和工具来协助网络管理员将网络迁移到 IPv6。迁移技术可分为三类：</p>
<ul>
<li>双堆栈 (Dual Stack)，双堆栈允许 IPv4 和 IPv6 在同一网络中共存。双堆栈设备同时运行 IPv4 和 IPv6 协议栈。</li>
<li>隧道 (Tunneling)，隧道是在 IPv4 网络中传输 IPv6 数据包的一种方法。IPv6 数据包封装在 IPv4 数据包中，类似于其他类型的数据。</li>
<li>转换 (Translation)，网络地址转换 64 (NAT64) 允许支持 IPv6 的设备使用与 IPv4 NAT 类似的方法与支持 IPv4 的设备通信。IPv6 数据包转换为 IPv4 数据包，反之亦然。</li>
</ul>
<p>注意：隧道和转换仅在需要时使用。目标是从源到目的地进行本地 IPv6 通信。</p>
<h1 id="连接验证"><a href="#连接验证" class="headerlink" title="连接验证"></a>连接验证</h1><h2 id="ICMPv4-和-ICMPv6"><a href="#ICMPv4-和-ICMPv6" class="headerlink" title="ICMPv4 和 ICMPv6"></a>ICMPv4 和 ICMPv6</h2><p>虽然 IP 并非尽力传输协议，TCP/IP 协议簇却会在发生某些错误时提供要发送的消息。这些消息使用 ICMP 服务发送。<strong>其用途是就特定情况下处理 IP 数据包的相关问题提供反馈，而并非是使 IP 可靠</strong>。ICMP 消息并非必需的，而且在网络内通常出于安全原因而被禁止。</p>
<p>ICMP 可同时用于 IPv4 和 IPv6。ICMPv4 是 IPv4 的消息协议。ICMPv6 为 IPv6 提供相同的服务，此外，还包括其他功能。在本课程中，涉及 ICMPv4 和 ICMPv6 时均会使用术语 ICMP。</p>
<p>ICMP 消息的类型及其发送原因非常多。我们将介绍其中比较常见的一些消息。</p>
<p>ICMPv4 和 ICMPv6 通用的 ICMP 消息包括：</p>
<ul>
<li>主机确认（Host Confirmation    ）：ICMP 回应消息可用于确定主机是否运行正常。本地主机向一台主机发送 ICMP 回应请求。如果主机可用，目的主机会回应以响应应答。</li>
<li>目标或服务不可达（Destination or Service Unreachable）： 当主机或网关收到无法传送的数据包时，它会使用 ICMP 目的地不可达消息通知源主机，目标或服务无法到达。消息包括指示数据包为何无法传送的代码。注意：ICMPv6 的目的地不可达消息代码与此类似，但是也稍有不同。<ul>
<li>ICMPv4 的目的地不可达代码示例有：</li>
<li>0 - 网络不可达。</li>
<li>1 - 主机不可达。</li>
<li>2 - 协议不可达。</li>
<li>3 - 端口不可达。</li>
</ul>
</li>
<li>超时（Time Exceeded）：路由器使用 ICMPv4 超时消息表明，因为数据包的生存时间 (TTL) 字段递减到 0 而不能转发数据包。如果路由器接收数据包并且将 IPv4 数据包的 TTL 字段的值递减为零，则它会丢弃数据包并向源主机发送超时消息。</li>
<li>路由重定向</li>
</ul>
<p>如果路由器因数据包过期而无法转发 IPv6 数据包，ICMPv6 也会发送超时消息。IPv6 没有 TTL 字段；它使用<strong>跳数限制字段(Hop Limit field)来确定数据包是否过期。</strong></p>
<h2 id="Ping-本地环回"><a href="#Ping-本地环回" class="headerlink" title="Ping 本地环回"></a>Ping 本地环回</h2><p>我们也可以使用 ping 进行一些特殊测试和验证。例如，测试本地主机上的内部 IPv4 或 IPv6 配置。要执行此测试，对于 IPv4，我们 ping 本地环回地址 127.0.0.1，对于 IPv6，则是 ::1。</p>
<p><strong>从 127.0.0.1 接收的 IPv4 响应或从 ::1 接收的 IPv6 响应，表示主机上的 IP 安装正确。此响应来自网络层。但是，此响应并不代表地址、掩码或网关配置正确。</strong>它也不能说明有关网络协议栈下层的任何状态。它只测试 IP 网络层的 IP 连接。如果收到错误消息，则表示该主机上的 TCP/IP 无法正常运行。</p>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ul>
<li><strong>brinary</strong> - a numbering system consisting of the digits 0 and 1, used by computers to perform operations</li>
<li><strong>bit</strong> - a single binary digit, represented by a 0 or a 1</li>
<li><strong>octet</strong> - one section of an IP address, consisting of a group of 8 bits</li>
<li><strong>positional notation</strong> - determining a digit value based on the digit position, used in converting from one numbering system to another</li>
<li><strong>subnet mask</strong> - a continuous sequence of 1 bits followed by a continuous sequence of 0 bits, used to determine the network portion of an IP address</li>
<li><strong>ANDing</strong> - a binary process used to determine the network address of a host address by using the host address subnet mask</li>
<li><strong>prefix lenght</strong> - the number of bits set to 1 in a subnet mask</li>
<li><strong>network address</strong> - a dotted-decimal number that represents a unique IP network</li>
<li><strong>host address</strong> - any IP address in an IP network that can be assigned to an interface</li>
<li><strong>broadcast address</strong> - a dotted-decimal number that represents all hosts in an IP network</li>
<li><strong>unicast address</strong> - the IP address of a single host on a network</li>
<li><strong>multicast address</strong> - an IP address representing a selected group of hosts</li>
<li><strong>public address</strong> - an IP address that can be routed on the Internet</li>
<li><strong>private address</strong> - an IP address used internally and not routed on the Internet</li>
<li><strong>classful addressing</strong> - specific ranges of IP addresses that make up classes of addresses in which the number of available network and host addresses are defined</li>
<li><strong>classless addressing</strong> - IP addressing standards created in 1993 that allow address allocation based on prefix length rather than predefined class ranges</li>
<li><strong>hexadecimal</strong> - a base-sixteen numbering system that uses numerals 0 through 9 and letters A through F to represent binary numbers in more condensed form</li>
<li><strong>IPv6 link-local address</strong> - an IP address that is required for every IPv6-enabled network interface and that allows a device to communicate with other IPv6-enabled devices on the same link</li>
<li><strong>ping</strong> - a utility that sends a series of echo requests from one IP host to another IP host and that processes the echo reply messages to test connectivity between the devices</li>
<li><strong>traceroute</strong> - a utility that generates details about the route traveled by data sent between two devices</li>
</ul>
]]></content>
      <categories>
        <category>ESAIP</category>
        <category>CCNA</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA Chapter 6: Network Layer</title>
    <url>/2017/12/18/CCNA-Chapter-6-Network-Layer/</url>
    <content><![CDATA[<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层（Network Layer）是 OSI 模型中的第三层（TCP/IP 模型中的网际层）。网络层提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径，并具有一定的拥塞控制和流量控制的能力。由于 TCP/IP 协议体系中的网络层功能由 IP 协议规定和实现，故又称 IP 层。</p>
<p>本章着重介绍网络层的作用。其中将探讨如何把网络分为不同的主机组，以便管理网络内的数据包流。此外还介绍了如何实现网络之间的通信。网络之间的这种通信称为路由。</p>
<p>为了实现这种端到端传输，网络层使用了四个基本过程：</p>
<ul>
<li>终端设备编址 - 必须为终端设备配置唯一的 IP 地址，以便在网络上进行识别。</li>
<li>封装 - 网络层将来自传输层的协议数据单元 (PDU) 封装到数据包中。封装过程中会添加 IP 报头信息，例如来源（发送）和目的（接收）主机的 IP 地址。</li>
<li>路由 - 网络层提供服务，将数据包转发至另一网络上的目的主机。要传送到其他网络，数据包必须经过路由器的处理。路由器的作用是为数据包选择最佳路径，并将其转发至目的主机，该过程称为路由。数据包可能需要经过很多中间设备才能到达目的主机。数据包在到达目的主机的过程中经过的每个路由器均称作一跳。</li>
<li>解封 - 当数据包到达目的主机的网络层时，主机会检查数据包的 IP 报头。如果在报头中的目的 IP 地址与其自身的 IP 地址匹配，IP 报头将会从数据包中删除。网络层解封数据包后，后继的第 4 层 PDU 会向上传递到传输层的相应服务。</li>
</ul>
<p>传输层（OSI 第 4 层）负责管理每台主机上的运行进程之间的数据传输，而网络层协议则指定从一台主机向另一台主机传送数据时使用的数据包结构和处理过程。网络层工作时无需考虑每个数据包中所携带的数据，这使其能够为多台主机之间的多种类型的通信传送数据包。</p>
<h1 id="IP，Internet-Protocol"><a href="#IP，Internet-Protocol" class="headerlink" title="IP，Internet Protocol"></a>IP，Internet Protocol</h1><p>网络层的两种主要协议为 IPv4 和 IPv6</p>
<p>IP 协议有三种特征：</p>
<ul>
<li>无连接：发送数据包前不于目标建立端到端连接</li>
<li>尽力交付：IP 不可靠，不保证数据包交付，IP 不具备管理和恢复未送达数据包或已损坏数据包的能力，在 TCP/IP 协议簇中，传输层负责保证可靠性。</li>
<li>介质无关：与传输介质无关，网络层会考虑介质可以传输的最大 PDU 大小。此特征称为最大传输单位 (maximum transmission unit，MTU)。在将数据包从一个介质转发到具有更小 MTU 的介质时，必须分割数据包。此过程称为数据包分段（fragmenting the packet）或分段（fragmentation）。</li>
</ul>
<h2 id="IPv4-和-IPv6-的优缺点"><a href="#IPv4-和-IPv6-的优缺点" class="headerlink" title="IPv4 和 IPv6 的优缺点"></a>IPv4 和 IPv6 的优缺点</h2><p>IPv4 的局限性</p>
<ul>
<li>IP 地址耗尽 - 对于目前来说，40 亿可用的 IPv4 的地址已经接近耗尽</li>
<li>Internet 路由表膨胀 - 路由器使用路由表（routing table）确定最佳路径。随着连接到 Internet 的服务器数量增加，网络路由的数量也不断增加。这些 IPv4 路由消耗 Internet 路由器上的大量内存和处理器资源。</li>
<li>缺乏端到端连接 - <strong>网络地址转换 (Network Address Translation，NAT) </strong>是 IPv4 网络中经常实施的一项技术。NAT 为多种设备共享单一的公有 IPv4 地址提供方法。但是，因为共享了公有 IPv4 地址，内部网络主机的 IPv4 地址会隐藏起来。这会给需要端到端连接的技术造成难题。</li>
</ul>
<p>IPv6 的功能提升包括：</p>
<ul>
<li>更大的地址空间 - IPv6 地址基于 128 位分层编址，而 IPv4 采用的是 32 位。</li>
<li>改进数据包处理过程 - IPv6 报头简化为更少的字段。</li>
<li>消除了对 NAT 的需求 - 有了数额如此巨大的公有 IPv6 地址，私有 IPv4 地址和公有 IPv4 地址之间不再需要 NAT。这可避免需要端到端连接的应用程序遇到某些由 NAT 引起的应用程序故障。</li>
</ul>
<h2 id="封装-IP"><a href="#封装-IP" class="headerlink" title="封装 IP"></a>封装 IP</h2><p>传输层会将数据分段然后添加报头信息，以便目的设备接收后重组。</p>
<p>网络层所处理的数据是传输层封装之后的，网络层会添加 IP 报头，内含包括目的 IP 地址在内的重要内容，目的 IP 地址在到达目的设备之前都不会改变。</p>
<p>相对于 IPv4 报头，IPv6 的简化报头有若干优势：</p>
<ul>
<li>报头格式简单，处理数据包更高效</li>
<li>负载更大，增加了吞吐量和传输效率</li>
<li>分层网络体系结构增加了路由器效率</li>
<li>自动配置地址</li>
</ul>
<h3 id="IPv4-报头格式"><a href="#IPv4-报头格式" class="headerlink" title="IPv4 报头格式"></a>IPv4 报头格式</h3><p>IPv4 报头格式如下，括号内为 bits</p>
<p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1fml98skr94j30jk05nq3h.jpg" alt=""></p>
<ol>
<li><strong>版本号（Version）</strong>：长度 4 bit 。标识目前采用的 IP 协议的版本号。一般的值为 0100（IPv4），0110（IPv6）</li>
<li><strong>IP 报头长度（Header Length）</strong>：长度 4 bit 。这个字段的作用是为了描述 IP 报头的长度，因为在 IP 报头中有变长的可选部分。该部分占 4 个 bit，长度单位为 4 个字节，即本区域值 = IP 头部长度（单位为字节）/ 长度单位（4 个字节）。因此，一个 IP 报头的长度最长为 “ 1111 ”，即 15 x 4 个字节 = 60 个字节。IP 报头最小长度为 20 字节</li>
<li><strong>服务类型（Type of Service）</strong>也称为 Differentiated Services，DS 字段是一个用于确定每个数据包优先级的 8 位字段。DiffServ 字段的六个最高有效位是区分服务代码点 (DSCP)，而后两位是显式拥塞通知 (ECN) 位。</li>
<li><strong>IP 包总长度（Total Length）</strong>：长度 16 bit 。以字节为单位计算的 IP 包的长度（包括头部和数据），所以 IP 包最大长度 65 535 字节。所以，数据包有效载荷的大小 = IP 包总长度（Total Length）- IP 报头长度（Header Length）。</li>
<li><strong>标识符（Identifier）</strong>：长度 16 bit 。该字段和 Flags 和 Fragment Offest 字段联合使用，对较大的上层数据包进行分段操作。路由器从一种介质向具有较小 MTU 的另一种介质转发数据包时必须将数据包分段。路由器将一个包拆分后，所有拆分开的小包被标记相同的值，以便目的端设备能够区分哪个包属于被拆分开的包的一部分。</li>
<li><strong>标记（Flags）</strong>：长度 3 bit 。<ul>
<li>该字段第一位不使用。</li>
<li>第二位是 DF（Don’t Fragment）位，DF 位设为 1 时表明路由器不能对该上层数据包分段。如果一个上层数据包无法在不分段的情况下进行转发，则路由器会丢弃该上层数据包并返回一个错误信息。</li>
<li>第三位是 MF（More Fragments）位，当路由器对一个上层数据包分段，则路由器会在除了最后一个分段的 IP 包的报头中将 MF 位设为 1 。</li>
</ul>
</li>
<li><strong>片偏移（Fragment Offset）</strong>：长度 13 bit，以 8 个八位组为单位。表示该 IP 包在该组分片包中位置，接收端靠此来组装还原 IP 包。</li>
<li><strong>生存时间（TTL）</strong>：长度 8 bit，设计之初是以秒（s）为单位的，但实际以跳数为单位，建议的缺省值为 64 。 包含用于限制数据包寿命的一个 8 位二进制值。数据包发送方设置初始 TTL 值，数据包每经过一次路由器处理，数值就减少一。如果 TTL 字段的值减为零，则路由器将丢弃该数据包并向源 IP 地址发送 Internet 控制消息协议 (ICMP) 超时消息。这个字段可以防止由于路由环路而导致 IP 包在网络中不停被转发。</li>
<li><strong>协议（Protocol）</strong>：长度 8 bit 。标识了上层所使用的协议。以下是比较常用的协议号：1 ICMP；2 IGMP；6 TCP；17 UDP；88 IGRP；89 OSPF 。</li>
<li><strong>头部校验（Header Checksum）</strong>：长度 16 bit 。用来做 IP 头部的正确性检测，但不包含数据部分。 因为每个路由器要改变 TTL 的值，所以路由器会为每个通过的数据包重新计算这个值</li>
<li><strong>起源和目标地址（Source and Destination Addresses）</strong>：这两个地址都是 32 bit 。标识了这个 IP 包的起源和目标地址。要注意除非使用 NAT，否则整个传输的过程中，这两个地址不会改变。</li>
<li><strong>可选项（Options）</strong>：这是一个可变长的字段。该字段属于可选项，主要用于测试，一般不填写，由起源设备根据需要改写。可选项目包含以下内容：<ul>
<li>松散源路由（Loose source routing）：给出一连串路由器接口的 IP 地址。IP 包必须沿着这些 IP 地址传送，但是允许在相继的两个 IP 地址之间跳过多个路由器。</li>
<li>严格源路由（Strict source routing）：给出一连串路由器接口的 IP 地址。IP 包必须沿着这些 IP 地址传送，如果下一跳不在 IP 地址表中则表示发生错误。</li>
<li>路由记录（Record route）：当 IP 包离开每个路由器的时候记录路由器的出站接口的 IP 地址。</li>
<li>时间戳（Timestamps）：当 IP 包离开每个路由器的时候记录时间。</li>
<li>填充（Padding）：因为 IP 报头长度（Header Length）部分的单位为 32 bit，所以 IP 报头的长度必须为 32 bit 的整数倍。因此，在可选项后面，IP 协议会填充若干个 0，以达到 32 bit 的整数倍。</li>
</ul>
</li>
</ol>
<h3 id="IPv6-报头格式"><a href="#IPv6-报头格式" class="headerlink" title="IPv6 报头格式"></a>IPv6 报头格式</h3><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1fmla63zspdj30jk0amjrs.jpg" alt=""></p>
<ol>
<li><strong>版本（Version）</strong>：4 bit，值为 6（二进制值为 0110）表示 IPv6 报文。</li>
<li><strong>流量类别（Traffic Class）</strong>：8 bit，这相当于 IPv4 协议中的 ToS 字段。但是，考虑到 ToS 字段这些年的发展，现在都用来做区分服务等级（Differentiated Class of Service，DiffServ）了。所以，即使这个字段和旧的 ToS 字段有些相似，它们的名字要比所传送的值更能确切地反映目前的用处。</li>
<li><strong>流标签（Flow Label）</strong>：20 bit，IPv6 中新增。流标签可用来标记特定流的报文，以便在网络层区分不同的报文。转发路径上的路由器可以根据流标签来区分流并进行处理。由于流标签在 IPv6 报文头中携带，转发路由器可以不必根据报文内容来识别不同的流，目的节点也同样可以根据流标签识别流，同时由于流标签在报文头中，因此使用 IPSec 后仍然可以根据流标签进行 QoS 处理。</li>
<li><strong>有效载荷长度（Payload Length）</strong>：16 bit，以字节为单位的 IPv6 载荷长度，也就是 IPv6 报文基本头以后部分的长度（包括所有扩展头部分）。IPv4 的总长度字段是 16 位的，但 IPv6 的有效载荷长度字段却是 20 位，这就意味着该字段能够指定更长的有效载荷（1 048 575 字节，相对 IPv4 中只有 65 535 字节）。</li>
<li><strong>下一报头（Next Header）</strong>：8 bit，用来标识当前头（基本头或扩展头）后下一个头的类型。此域内定义的类型与 IPv4 中的协议域值相同。IPv6 定义的扩展头由基本头或扩展头中的扩展头域链接成一条链。这一机制下处理扩展头更高效，转发路由器只处理必须处理的选项头，提高了转发效率。</li>
<li><strong>跳数限制（Hop Limit）</strong>：8 bit，和 IPv4 中的 TTL 字段类似。每个转发此报文的节点把此域减 1，如果此域值减到 0 则丢弃。注意：IPv4 中的 TTL 设计之初是以秒（s）为单位的，但实际使用时跟 IPv6 中的 Hop Limit 一样，是以跳数为单位。</li>
<li><strong>源地址（Source Address）</strong>：128 bit，报文的源地址。</li>
<li><strong>目的地址（Destination Address）</strong>：128 bit，报文的目的地址。</li>
</ol>
<p>IPv6 数据包还可能包含扩展报头 (EH)，以便提供可选的网络层信息。扩展报头为可选项，位于 IPv6 报头及负载之间。EH 用于分段、安全性、移动性支持等。</p>
<p>与 IPv4 不同，路由器不会对路由的 IPv6 数据包进行分段。</p>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>路由（routing）就是通过互联的网络把信息从源地址传输到目的地址的活动。路由发生在 OSI 网络参考模型中的第三层即网路层。</p>
<p>主机可以将数据包发送至：</p>
<ul>
<li>自身 - 主机会将数据包发送到一个称作<strong>环回接口的特殊 IPv4 地址 127.0.0.1</strong>，以对自身执行 ping 操作。对环回接口执行 ping 操作可以测试主机上的 TCP/IP 协议堆栈。</li>
<li>本地主机 - 该主机与发送主机位于同一本地网络。这些主机共享同一个网络地址。</li>
<li>远程主机 - 这是位于远程网络上的主机。这些主机不共享同一个网络地址。</li>
</ul>
<h2 id="默认网关"><a href="#默认网关" class="headerlink" title="默认网关"></a>默认网关</h2><p>默认网关是可以将流量路由到其他网络的网络设备。它是将流量从本地网络路由出去的路由器。</p>
<p>如果把一个网络比作一个房间，那么默认网关就好比是门口。如果要去另一个房间或网络，您就需要找到门口。</p>
<p>或者，不知道默认网关 IP 地址的 PC 或计算机就好比是一个房间里不知道门口在哪的人。他们可以和房间或网络中的其他人交谈，但是如果他们不知道默认网关地址，或者如果没有默认网关，那么就没有出路。</p>
<p>主机的路由表通常包括默认网关。主机通过动态主机配置协议 (Dynamic Host Configuration Protocol，DHCP) 动态接收默认网关 IPv4 地址，或者通过手动配置。配置默认网关会在 PC 的路由表中创建一个默认路由。默认路由是计算机尝试联系远程网络时所用的路由或路径。</p>
<h2 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h2><p>当一台主机发送数据包到另一台主机时，它将使用路由表来确定将数据包发送到哪里。如果目的主机位于远程网络，则数据包会转发到默认网关。</p>
<p>数据包到达默认网关（通常是路由器）时会发生什么情况？路由器会查看路由表来确定将数据包转发到哪里。</p>
<p>路由器的路由表存储下列信息：</p>
<ul>
<li>直连路由 - 这些路由来自于活动的路由器接口。当接口配置了 IP 地址并激活时，路由器会添加直连路由。路由器的每个接口均连接到一个不同的网段。</li>
<li>远程路由 - 这些路由来自连接到其他路由器的远程网络。通向这些网络的路由可以由网络管理员在本地路由器上手动配置，也可动态配置，后者的方法是启用本地路由器，使其与其他使用动态路由协议的路由器交换信息。</li>
<li>默认路由 - 与主机一样，如果路由表中没有通向目标网络的其他路由，路由器也会将默认路由作为最后选用网关。</li>
</ul>
<p>在 Cisco IOS 路由器上，<code>show ip route</code> 命令可用于显示路由器的 IPv4 路由表</p>
<p>还必须要知道，路由器不能转发目的网络与路由表中的路由不匹配的数据包。如果路由表中没有代表目的网络的路由，会丢弃数据包（即不转发）。但是，正如主机可以使用默认网关将数据包转发到未知目的地址，路由器也可以包含默认路由，以创建最后选用网关。可以手动配置或动态获取默认路由。</p>
<h3 id="直连路由表条目"><a href="#直连路由表条目" class="headerlink" title="直连路由表条目"></a>直连路由表条目</h3><p>为路由器接口配置 IPv4 地址、子网掩码并激活时，将会自动创建以下两个路由表条目：</p>
<ul>
<li>C - 用于确定直连网络。为接口配置 IP 地址并激活时，会自动创建直连网络。</li>
<li>L - 表示这是本地接口。这是路由器接口的 IPv4 地址。</li>
</ul>
<p>例如：<code>C 192.168.10.1 is directly connected,GigabitEthernet0/0</code></p>
<p>直连路由表条目有三部分组成：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">路由来源</th>
<th style="text-align:center">目的网络</th>
<th style="text-align:center">传出接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">确定路由如何获知网络</td>
<td style="text-align:center">确定目的网络和他的获取方式</td>
<td style="text-align:center">确定用于将数据转发至最终目的地的出口</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">192.168.10.1 is directly connected,</td>
<td style="text-align:center">GigabitEthernet0/0</td>
</tr>
</tbody>
</table>
</div>
<h3 id="远程网络路由表条目"><a href="#远程网络路由表条目" class="headerlink" title="远程网络路由表条目"></a>远程网络路由表条目</h3><p>一个路由器通常配置有多个接口。路由表既储存直连网络信息，也储存远程网络信息。</p>
<p>远程网络路由表条目有 7 个部分</p>
<p>例如：<code>D 10.1.1.0/24 90 2170112 via 209.165.200.226, 00:00:05, Serial0/0/0</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">路由来源</th>
<th style="text-align:center">目的网络</th>
<th style="text-align:center">管理距离</th>
<th style="text-align:center">度量</th>
<th style="text-align:center">下一跳</th>
<th style="text-align:center">路由时间戳</th>
<th>传出接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">确定路由器如何获知网络。常见路由来源包括 S（静态路由）、D（增强型内部网关路由选择协议）、O（开放最短路径优先选择）</td>
<td style="text-align:center">确定目的网络</td>
<td style="text-align:center">确定路由来源的管理距离（可信度），值越低表示可信度越高</td>
<td style="text-align:center">值越低表示此路由器越佳</td>
<td style="text-align:center">用于确定转发数据包的下一路由器的 IP 地址</td>
<td style="text-align:center">用于识别路由器最后一次侦听的时间</td>
<td>确定用于将数据转发至最终目的地的出口</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">10.1.1.0/24</td>
<td style="text-align:center">90</td>
<td style="text-align:center">2170112</td>
<td style="text-align:center">via 209.165.200.226,</td>
<td style="text-align:center">00:00:05,</td>
<td>Serial0/0/0</td>
</tr>
</tbody>
</table>
</div>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>路由器（英语：Router，又称路径器）是一种电讯网络设备，提供路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过的路由路径（host 到 host 之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端（在路由器内部进行），这称为转送。路由工作在 OSI 模型的第三层——即网络层，例如网际协议（IP）。</p>
<p>它是一种设备同样也是一种计算机，同其他计算机设备一样，路由器也需要 CPU、OS、RAM、ROM、NVRAM 和闪存</p>
<p>路由表、ARP 缓存表、数据包缓存都存放在 RAM 中</p>
<p>思科路由器和交换机都会在重启时将 IOS 映像和启动配置文件加载到 RAM 中，如图所示。</p>
<p><code>show version</code> 命令会显示路由器当前所运行的 Cisco IOS 软件的版本信息、引导程序版本信息以及硬件配置信息（包括系统存储器大小）。</p>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ul>
<li><strong>routing</strong> - the process of sending packets to hosts on a remote network</li>
<li><strong>maximum transmission unit,MTU</strong> - the largest PDU that is supported</li>
<li><strong>Time-to-Live,TTL</strong> - a value that limits the the lifetime of a packet</li>
<li><strong>administrative distance</strong> - the trustworthiness of a route</li>
<li><strong>next-hop</strong> - the destination router indicated by the outgoing interface entry in the routing table</li>
<li><strong>RAM</strong> - volatile memory that stores the running configuration and tables as generated by the device</li>
<li><strong>ROM</strong> - nonvolatile memory that contains a limited IOS and instructions for the router</li>
<li><strong>NVRAM</strong> - nonvolatile memory that stores the startup configuration of a device</li>
<li><strong>hostname</strong> - a way to identify a networking device</li>
<li><strong>flash</strong> - nonvolatile memory that stores the IOS and other system files</li>
<li><strong>connectionless</strong> - a connection does not have to be established to send data</li>
<li><strong>in-band configuration</strong> - requires the establishment of a network connection to the device to be configured</li>
<li><strong>out-of-band configuration</strong> - requires a direct physical connection to the device to be configured</li>
<li><strong>default gateway</strong> - a device that allows the devices on one network to communicate with devices on other networks</li>
<li><strong>metric</strong> - a value that is used by a routing protocol to identify the best route to insert into a routing table</li>
</ul>
]]></content>
      <categories>
        <category>ESAIP</category>
        <category>CCNA</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA Chapter 5: Ethernet</title>
    <url>/2017/12/17/CCNA-Chapter-5-Ethernet/</url>
    <content><![CDATA[<p>OSI 物理层通过网络介质传输构成数据链路层帧的位。</p>
<p>以太网是目前世界上占主导地位的 LAN 技术。以太网在数据链路层和物理层运行。以太网协议标准定义网络通信的许多方面，包括帧格式、帧大小、时序和编码。当消息在以太网络上的主机之间发送时，主机会将消息格式化为标准指定的帧结构。</p>
<p>由于以太网由这些较下层的标准组成，因此可能是 OSI 模型中最容易理解的。OSI 模型将数据链路层的编址、成帧和介质访问功能与介质的物理层标准分隔开来。以太网标准定义第 2 层协议和第 1 层技术。虽然以太网规格支持不同的介质、带宽以及第 1 层和第 2 层的其他变体，但所有以太网变体的基本帧格式和地址方案是相同的。</p>
<p>以太网已经从一种共享介质、有争议的数据通信技术发展成为今天的高带宽、全双工技术，本章将分析它的特性和运作。</p>
<p>总的来说以太网是一个物理层和数据链路层的具体实现，本章笔记所记录的内容与前一章标题类似但是内容上更加具体</p>
<h1 id="以太网封装"><a href="#以太网封装" class="headerlink" title="以太网封装"></a>以太网封装</h1><p>以太网是在数据链路层和物理层运行的，正如上一章介绍的，以太网标准同时定义第 2 层协议和第 1 层技术。对于第 2 层协议，正如所有 802 IEEE 标准一样，以太网依靠数据链路层的两个单独子层运行，即逻辑链路控制 (LLC) 和 MAC 子层。</p>
<h2 id="MAC-子层"><a href="#MAC-子层" class="headerlink" title="MAC 子层"></a>MAC 子层</h2><p>以太网 MAC 子层有两项主要职责：</p>
<ul>
<li>数据封装</li>
<li>介质访问控制</li>
</ul>
<a id="more"></a>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><p>数据封装过程包括发送前的帧组装和收到帧时的帧解析。在构建帧时，MAC 层会向网络层 PDU 添加帧头和帧尾。</p>
<p>数据封装提供三项主要功能：</p>
<ul>
<li>帧定界 (Frame delimiting) - 成帧过程提供重要的定界符，用于标识组成帧的一组位。这些定界位会对发送节点与接收节点进行同步。</li>
<li>编址 (Addressing ) - 封装过程包含第 3 层 PDU，还提供数据链路层编址。</li>
<li>错误检测 (Error detection) - 每个帧中包含一个帧尾，用于检测传输中的任何错误。</li>
</ul>
<p>帧的使用有助于比特的发送，因为会把它们组成比特组放在介质中和在接收节点接收。</p>
<p>Ethernet II 是 TCP/IP 网络中使用的以太网帧格式。在这种格式中帧字段的具体结构和字段大小如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">8 字节</th>
<th style="text-align:center">6 字节</th>
<th style="text-align:center">6 字节</th>
<th style="text-align:center">2 字节</th>
<th style="text-align:center">46 到 1500 字节</th>
<th>4 字节</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">报头</td>
<td style="text-align:center">目的 MAC 地址</td>
<td style="text-align:center">源 MAC 地址</td>
<td style="text-align:center">EhterType</td>
<td style="text-align:center">数据</td>
<td>FCS</td>
</tr>
<tr>
<td style="text-align:center">前导码 7 字节、起始帧分节符（SFD，帧首）1 字节</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">用于告知准备接受新帧</td>
<td style="text-align:center">帧中的地址会跟设备中 MAC 地址检测匹配可以是单播组播广播</td>
<td style="text-align:center">用于标识发出帧的网卡，必须是单播地址</td>
<td style="text-align:center">常为 16 进制，0x800 用于 IPV4，0x86DD 用于 IPV6，0x806 用于 ARP</td>
<td style="text-align:center">包含来自 3 层的 PUD，内含上层的封装信息</td>
<td>帧校验序列 (FCS) 字段用于检测帧中的错误。它使用循环冗余校验 (CRC)、数据改变可能是由于代表比特的电信号中断所致</td>
</tr>
</tbody>
</table>
</div>
<p>以太网帧大小的最小值为 64 个字节，最大值为 1518 个字节。这包括从“目的 MAC 地址”字段到“帧校验序列 (FCS)”字段的所有字节。在描述帧的大小时，不包含“前导码”字段。</p>
<p>任何长度小于 64 个字节的帧都被接收站点视为“冲突碎片 (collision fragment)”或“残帧 (runt frame)”而自动丢弃。超过 1500 个字节的数据帧被视为“巨帧 (jumbo)”或“小型巨型帧 (baby giant frames)”。</p>
<h3 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h3><p>MAC 子层的第二项职责是介质访问控制。介质访问控制负责将帧放入介质中和从介质中移除帧。顾名思义，它控制对介质的访问。该子层直接与物理层通信。</p>
<p>以太网的基础逻辑拓扑是一个多路访问总线；因此，各个网段的所有节点（设备）共享介质。以太网是一种网络争用方法。网络争用方法是指一旦有数据需要发送，所有设备都可以尝试通过共享介质传输数据。载波侦听多路访问/冲突检测 (CSMA/CD) 过程用于在半双工以太网 LAN 中检测和解决冲突。当前的以太网 LAN 采用全双工交换机，可使多台设备同时发送和接受，并无任何冲突。</p>
<h2 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h2><p>以太网 MAC 地址是一种表示为 12 个十六进制数字（每个十六进制数字为 4 位）的 48 位二进制值。是一个网卡的物理地址，该地址会被永久编码到 ROM 芯片中，因此被称为烧录地址（burned-in address，BIA），在数据链路层封装在帧中。这是设备在以太网中身份的象征。为了避免处理每个帧时产生过多开销，创建了 MAC 地址来标识实际源和目的节点。</p>
<p>MAC 地址值是 IEEE 为确保每台以太网设备使用全局唯一地址而强制厂商遵守规定的直接结果。IEEE 规定销售以太网设备的任何厂商都要向 IEEE 注册。IEEE 为厂商分配了一个 3 字节（24 位）的代码，称为组织唯一标识符 (Organizationally Unique Identifier，OUI)。</p>
<p>IEEE 要求厂商遵守两条简单的规定，如图所示：</p>
<ul>
<li>分配给网卡或其他以太网设备的所有 MAC 地址都必须使用厂商分配的 OUI 作为前 3 个字节。</li>
<li>OUI 相同的所有 MAC 地址必须在最后 3 个字节中分配一个唯一值。</li>
</ul>
<p>注意：由于生产中或一些虚拟机实施方法中的错误，可能存在重复的 MAC 地址。在以上任一情况下，必须在新网卡或软件中修改 MAC 地址。</p>
<p>MAC 有三种表示形式：使用破折号、冒号、句点都可以</p>
<h3 id="单播、组播、广播-MAC-地址"><a href="#单播、组播、广播-MAC-地址" class="headerlink" title="单播、组播、广播 MAC 地址"></a>单播、组播、广播 MAC 地址</h3><p>在以太网中，第 2 层单播、组播和广播通信会使用不同的 MAC 地址。</p>
<p>单播 MAC 地址是帧从一台发送设备发送到一台目的设备时使用的唯一地址。</p>
<p>广播数据包中目的 IP 地址为一个主机位全为 1 的 ip 地址作为目的地址，该地址也成为广播地址，而目的 MAC 地址为十六进制（在二进制中是 48 个 1）的 FF-FF-FF-FF-FF-FF 广播 MAC 地址。</p>
<p>组播 MAC 地址</p>
<p>源主机用来确定目的 MAC 地址的流程称为地址解析协议 (ARP)。ARP 将在本章后续部分讨论。</p>
<p>虽然目的 MAC 地址可以是单播、广播或组播地址，但是源 MAC 地址必须始终为单播地址。</p>
<h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><p>第 2 层以太网交换机使用 MAC 地址做出转发决策。它完全忽视帧的数据部分的协议，例如 IPv4 数据包。交换机仅根据第 2 层以太网 MAC 地址做出转发决策。</p>
<p>与旧式以太网集线器（它重复除了传入端口以外的所有端口的位）不同，以太网交换机在做出每个帧的转发决策时会查询 MAC 地址表。</p>
<p>MAC 地址表有时也称为内容可编址内存 (content addressable memory，CAM) 表。</p>
<p>交换机通过检查端口传入帧的源 MAC 地址来动态构建 MAC 地址表。交换机通过匹配帧中的目的 MAC 地址与 MAC 地址表中的条目来转发帧。</p>
<p>对进入交换机的每个以太网帧执行下列流程。</p>
<ul>
<li>记录每个进入交换机的每个帧的源 MAC 地址和帧进入交换机的端口号<ul>
<li>如果源 MAC 地址不存在，会将其和传入端口号一并添加到表中。</li>
<li>如果源 MAC 地址已存在于表中，则交换机会更新该条目的刷新计时器。默认情况下，大多数以太网交换机将条目在表中保留 5 分钟。</li>
</ul>
</li>
</ul>
<p>注意：如果源 MAC 地址已存在于表中，但是在不同的端口上，交换机会将该地址视为一个新的条目。使用相同的 MAC 地址和最新的端口号来替换该条目。</p>
<ul>
<li>转发 – 检查目的 MAC 地址 如果目的 MAC 地址为单播地址，该交换机会看帧中的目的 MAC 地址与 MAC 地址表中的条目是否匹配。<ul>
<li>如果表中存在该地址，交换机会从指定端口转发帧。</li>
<li>如果表中不存在该地址，交换机会从除传入端口外的所有端口转发帧。我们将这称为未知单播（unknown unicast）。</li>
</ul>
</li>
</ul>
<p>注意：如果目的 MAC 地址为广播或组播，该帧将泛洪到除传入端口外的所有端口。</p>
<h2 id="交换机上的帧转发方法"><a href="#交换机上的帧转发方法" class="headerlink" title="交换机上的帧转发方法"></a>交换机上的帧转发方法</h2><ul>
<li>存储转发交换，Store-and-forward switching</li>
<li>直通交换，Cut-through switching</li>
</ul>
<h1 id="地址解析协议，ARP"><a href="#地址解析协议，ARP" class="headerlink" title="地址解析协议，ARP"></a>地址解析协议，ARP</h1><p>当数据包在网络之间进行交换时，源 IP 地址和目的 IP 地址都是封装在第三层 UDP 中，不会更改，而 MAC 地址会在每层设备中重新解封封装，在解封后设备会根据目的 ip 地址来确定下一设备的物理信息，当目的 IP 地址处于远程网络中时，则目的 MAC 地址为主机的默认网关（即路由器的网卡）的地址。，而数据流中 IPv4 数据包的 IPv4 地址如何与通往目的地路径中每条链路上的 MAC 地址相关联？这可以通过地址解析协议 (Address Resolution Protocol，ARP) 过程来完成。</p>
<p>网络中的设备会使用 ARP 确定目的 MAC 地址，ARP 提供两种基本功能：</p>
<ul>
<li>将 IP 地址解析为 MAC 地址，</li>
<li>维护映射表</li>
</ul>
<p>也就是说，当数据包发送到要封装入以太网帧的数据链路层时，设备将参照其内存中的表来查找映射至 IPv4 地址的 MAC 地址。如果设备找到 IPv4 地址，其相应的 MAC 地址将作为帧中的目的 MAC 地址。如果找不到该条目，设备会发送一个 ARP 请求。</p>
<p>在思科路由器上，<code>show ip arp</code> 命令用于显示 ARP 表。</p>
<p>在 Windows 7 PC 上，<code>arp –a</code> 命令用于显示 ARP 表。</p>
<h2 id="ARP-请求"><a href="#ARP-请求" class="headerlink" title="ARP 请求"></a>ARP 请求</h2><p>当设备需要与 IPv4 地址关联的 MAC 地址，而它的 ARP 表中没有 IPv4 地址条目时，会发送一个 ARP 请求。</p>
<p>ARP 消息直接封装到以太网帧中。没有 IPv4 报头。ARP 请求消息包括：</p>
<ul>
<li>目的 IPv4 地址 – 这是需要相应的 MAC 地址的 IPv4 地址。</li>
<li>目的 MAC 地址 – 这是未知 MAC 地址，并在 ARP 请求消息中为空。</li>
</ul>
<p>ARP 请求使用以下报头信息封装在以太网帧中：</p>
<ul>
<li>目的 MAC 地址 – 这是一种要求 LAN 上的所有以太网网卡接受并处理 ARP 请求的广播地址。</li>
<li>源 MAC 地址 – 这是 ARP 请求发送方的 MAC 地址。</li>
<li>类型 - ARP 消息的类型字段为 0x806。该类型字段会通知接收网卡需要将帧的数据部分传递给 ARP 处理。</li>
</ul>
<p>因为 ARP 请求属于广播，交换机会将其泛洪到除接收端口外的其他所有端口。LAN 上的所有以太网网卡会处理广播。每台设备必须处理 ARP 请求，以检查目的 IPv4 地址是否与其自己的地址相匹配。路由器不会将广播转发到其他接口。</p>
<p>LAN 上只有一台设备的 IPv4 地址与 ARP 请求中的目的 IPv4 地址相匹配。所有其他设备将不应答。</p>
<h2 id="ARP-应答"><a href="#ARP-应答" class="headerlink" title="ARP 应答"></a>ARP 应答</h2><p>只有具有和 ARP 请求中目的 IPv4 地址关联的 IPv4 地址的设备会以 ARP 应答做出响应。ARP 应答消息包括：</p>
<ul>
<li>发送方的 IPv4 地址 – 这是发送方的 IPv4 地址，发送方即被请求 MAC 地址的那台设备。</li>
<li>发送方的 MAC 地址 – 这是发送方的 MAC 地址，即 ARP 请求发送方需要的 MAC 地址。</li>
</ul>
<p>ARP 应答使用以下报头信息封装在以太网帧中：</p>
<ul>
<li>目的 MAC 地址 – 这是 ARP 请求发送方的 MAC 地址。</li>
<li>源 MAC 地址 – 这是 ARP 应答发送方的 MAC 地址。</li>
<li>类型 - ARP 消息的类型字段为 0x806。该类型字段会通知接收网卡需要将帧的数据部分传递给 ARP 处理。</li>
</ul>
<p>只有原始发送 ARP 请求的设备会收到单播 ARP 应答。收到该 ARP 应答后，设备会将 IPv4 地址及相应的 MAC 地址添加到自身的 ARP 表中。该 IPv4 地址的数据包现在便可使用其相应的 MAC 地址封装在帧中。</p>
<p>如果没有设备响应 ARP 请求，就无法创建帧，所以会丢弃数据包。</p>
<p>ARP 表中的条目具有时间戳。如果设备在时间戳到期时没有从特定设备收到帧，此设备的条目将会从 ARP 表中删除。</p>
<p>此外，也可以在 ARP 表中输入静态映射条目，但这种情况很少见。静态 ARP 表条目没有到期时间，必须手动删除。</p>
<p>注意：IPv6 使用与 IPv4 类似的 ARP 流程，称为 ICMPv6 邻居发现。与 IPv4 的 ARP 请求和 ARP 应答类似，IPv6 使用邻居请求和邻居通告消息。</p>
<h2 id="ARP-问题"><a href="#ARP-问题" class="headerlink" title="ARP 问题"></a>ARP 问题</h2><ul>
<li>ARP 请求广播带来的网络性能下降</li>
<li>ARP 欺骗（ARP Spoofing）</li>
</ul>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ul>
<li><strong>Organizationally Unique Identifier</strong> - a three-byte code that is assigned by IEEE to identify the vendor of a NIC</li>
<li><strong>physical address</strong> - a Layer 2 address that allows NICs to communicate with each other</li>
<li><strong>logical address</strong> - a Layer 3 address that identifies both the network and the specific host on that network</li>
<li><strong>Address Resolution Protocol</strong> - the process that is used to find a Layer 2 address when a Layer 3 address is known</li>
<li><strong>auto-MDIX</strong> - a feature that detects the type of cable, and configures the interfaces to allow the connection</li>
<li><strong>store-and-forward switching</strong> - a switching method that receives the entire frame before forwarding</li>
<li><strong>cut-through switching</strong> - a switching method that begins the forwarding process as soon as enough information has been received to make a forwarding decision</li>
<li><strong>fast-forward switching</strong> - a cut-through switching method that begins to forward data as soon as the destination address has been received</li>
<li><strong>fragment-free switching</strong> - a cut-through switching method that begins to forward data after receipt of the first 64 bytes of a frame</li>
</ul>
]]></content>
      <categories>
        <category>ESAIP</category>
        <category>CCNA</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA Chapter 4: Network Access</title>
    <url>/2017/12/15/CCNA-Chapter-4-Network-Access/</url>
    <content><![CDATA[<p>接下来主要分为四大部分来介绍网络协议，分别是网络接入层（物理层和数据链路层），互联网层（网络层），传输层，应用层（会话层，表示层，应用层）。</p>
<p>本章主要介绍网络接入层，在发送设备上，数据链路层的作用是准备数据以供传输，并控制该数据访问物理介质的方式。物理层通过将代表数据的二进制数字编码成信号来控制数据传送到物理介质的方式。在接收端，物理层通过连接介质接收信号。在将信号解码为数据后，物理层会将帧传递到数据链路层以便接受和处理。</p>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>在进行网络通信之前，都必须在本地网络上建立一个物理连接。物理连接可以通过电缆进行有线连接，也可以通过无线电波进行无线连接。在进行无线连接之前，设备必须连接到一个无线接入点（wireless access point，AP）。</p>
<p>网络接口卡（Network Interface Cards， NICs） 将设备连接到网络。以太网（Ethernet）网卡用于有线连接，而 WLAN 网卡用于无线连接。</p>
<p>OSI 物理层通过网络介质传输构成数据链路层帧的位。该层从数据链路层接收完整的帧，并将这些帧编码为一系列信号，传输到本地介质上。经过编码的位构成了帧，这些位可以被终端设备或中间设备接收。</p>
<p>数据从源节点向目的节点传输的过程如下：</p>
<ol>
<li>用户数据在传输层进行分段，由网络层放入数据包，再由数据链路层封装成帧。</li>
<li>在物理层编码，并创建电子、光纤或无线电波信号来代表每个帧中的位。</li>
<li>然后，将这些信号逐个发送到介质上。</li>
<li>目的节点物理层从介质上检索每个信号，将其还原为位表示方式，然后将这些位作为一个完整的帧向上传递到数据链路层。</li>
</ol>
<p>应用数据 -&gt; 消息片段（segments） -&gt; 数据包（Packet） -&gt; 帧（Farme） -&gt; 位（Bits） -&gt; 信号（Signal）</p>
<p>常见的物理层设备</p>
<ul>
<li>网卡</li>
<li>光纤</li>
<li>CAT-5线</li>
<li>RJ-45接头</li>
<li>集线器有整波作用。</li>
<li>Repeater加强信号。</li>
<li>串口</li>
<li>并口</li>
</ul>
<a id="more"></a>
<h2 id="物理层功能"><a href="#物理层功能" class="headerlink" title="物理层功能"></a>物理层功能</h2><ul>
<li>管理物理组件（Physical Components）： 这里说所说物理组件表示用于物理传输、承载信号的电子硬件设备、介质和其他连接器，物理层规定相关硬件的接口和连接器引脚的标准</li>
<li>编码（Encoding）：编码或线路编码是一种将数据位流转换为预定义“代码”的方法。这些代码就是位组，用于提供一种可预测模式，以便发送者和接收者均能识别。在网络中，编码是用于代表位（即 0 和 1）的一种电压或电流形式。<ul>
<li>例如，曼彻斯特编码的 0 位表示为从高到低的电压转换，而 1 位表示为从低到高的电压转换。转换在每个位周期的中间进行。这种类型的编码用于 10 b/s 的以太网。更快的数据速率需要更复杂的编码。</li>
</ul>
</li>
<li>信令 (Signaling)：物理层必须在介质上生成代表“1”和“0”的电信号、光信号或无线信号。表示位的方法称为信令方法。物理层标准必须定义哪种类型的信号代表“1”，而哪种类型的信号代表“0”。这可以简单到只是改变电信号或光脉冲的级别。例如，长脉冲可能代表 1，而短脉冲代表 0。</li>
</ul>
<h2 id="物理层特征"><a href="#物理层特征" class="headerlink" title="物理层特征"></a>物理层特征</h2><p>不同的物理介质所支持的位传输速率不同。数据传输的讨论通常都会提及<strong>带宽 (Bandwidth)</strong>和<strong>吞吐量 (throughput)</strong></p>
<h3 id="带宽（Bandwidth）"><a href="#带宽（Bandwidth）" class="headerlink" title="带宽（Bandwidth）"></a>带宽（Bandwidth）</h3><p>带宽是介质承载数据的能力，可以测量在给定时间内一端流向另一端的数据流量，但是不是位传输的物理速度，在以太网中，物理速度是确定的，即电子的速度。带宽是一种物理属性，在网络建立起的时候就已经确定的。</p>
<p>多种因素的结合，决定了网络的实际带宽：</p>
<ul>
<li>物理介质的属性</li>
<li>信令和检测网络信号所选用的技术</li>
</ul>
<h3 id="吞吐量（throughput）"><a href="#吞吐量（throughput）" class="headerlink" title="吞吐量（throughput）"></a>吞吐量（throughput）</h3><p>由于各种因素的影响，吞吐量经常与物理层实施中指定的带宽不符，这是一种实时的度量。</p>
<p>许多因素会影响吞吐量，包括：</p>
<ul>
<li>流量大小</li>
<li>流量类型</li>
<li>从源通往目的地的过程中遇到的网络设备数所产生的延时（Latency ）。</li>
</ul>
<p>延时（Latency ）是指数据从一个给定点传送到另一给定点所用的时间，包括延迟。</p>
<p>值得注意的是，在一个流量的传输过程中，吞吐量会受到最低链路速度的那一段路径影响，即短板效应</p>
<p>用于评估可用数据传输的第三个测量标准，称为<strong>实际吞吐量（goodput）</strong>。实际吞吐量是在给定时间段内传输的有用数据的衡量标准。</p>
<h2 id="物理层介质（Physical-Layer-Media）"><a href="#物理层介质（Physical-Layer-Media）" class="headerlink" title="物理层介质（Physical Layer Media）"></a>物理层介质（Physical Layer Media）</h2><p>网络介质有三种基本形式。物理层为每种介质制定的位的表示方式及分组如下：</p>
<ul>
<li><strong>铜缆 (Copper cable)</strong>：信号为电脉冲模式。</li>
<li><strong>光缆 (Fiber-optic cable)</strong>：信号为光模式。</li>
<li><strong>无线 (Wireless)</strong>：信号为微波传输模式。</li>
</ul>
<p>对于不同的物理层介质的使用都有不同的标准要求，例如铜介质要求综合考量，使用铜缆的类型，通信的带宽，使用连接器类型，介质传送的最大距离</p>
<h3 id="铜缆-Copper-cable"><a href="#铜缆-Copper-cable" class="headerlink" title="铜缆 (Copper cable)"></a>铜缆 (Copper cable)</h3><p>铜介质具有<strong>价格低廉、易于安装、对电流的电阻低</strong>的特点。但是，铜介质受到<strong>距离和信号干扰</strong>的限制。主要的信号干扰源有以下两种：</p>
<ul>
<li><strong>电磁干扰 (Electromagnetic interference, EMI) 或射频干扰 (radio frequency interference, RFI)</strong> - EMI 和 RFI 干扰信号会扭曲和损坏通过铜介质承载的数据信号。</li>
<li><strong>串扰 (Crosstalk )</strong> - 串扰是一根电线中信号的电场或磁场对邻近电线中的信号造成的干扰。在电话线上，串扰会由相邻电路中另一语音会话的接听部分引起。具体而言，当电流流经电线时，会在电线周围产生一个较小的环形磁场，而相邻电线可能接收到该磁场。</li>
</ul>
<p>为了应对 EMI 和 RFI 的负面影响，某些类型的铜缆会<strong>用金属屏蔽套包裹，并要求适当的接地连接</strong>。<br>为了应对串扰的负面影响，某些类型的铜缆将<strong>相反电路线对绞合</strong>在一起以有效消除串扰。  </p>
<p>以下方式也可以限制电子噪音对铜缆的影响：</p>
<ul>
<li>选择的电缆类型或类别要适合特定的网络环境。</li>
<li>设计电缆基础设施来规避建筑结构中已知和潜在的干扰源。</li>
<li>使用包括正确处理和端接电缆的电缆技术。</li>
</ul>
<p>现阶段网络中常用的铜介质的线缆有三种类型：</p>
<ul>
<li><strong>非屏蔽双绞线 (Unshielded Twisted-Pair, UTP)</strong>：是最常用的网络介质。通过 RJ-45 连接器（俗称水晶头）端接的 UTP 布线用于网络主机与中间网络设备的互连，例如交换机和路由器。电线的绞合有助于防止其他电线的信号干扰。</li>
<li><strong>屏蔽双绞线 (Shielded Twisted-Pair, STP)</strong>：STP 电缆结合屏蔽技术来应对 EMI 和 RFI，使用电线绞合技术来应对串扰。但是，与 UTP 电缆相比，STP 电缆更加昂贵而且不易安装。也使用 RJ-45 连接器</li>
<li><strong>同轴电缆 (Coaxial)</strong> 同轴电缆，或简称同轴，由于它的两根导线分享同一个轴而得名。同轴电缆包括：<ul>
<li>一根用于传输电子信号的铜导线。</li>
<li>包裹着铜导线的柔软的塑料绝缘层。</li>
<li>绝缘材料的表皮是铜线编织或金属箔，作用相当于电路中的第二条电线，而且还可作为内部导体的屏蔽层。该第二层或屏蔽层还可减少许多外部电磁干扰。</li>
<li>整个电缆由一层电缆表皮覆盖，使其免于较小的物理损坏。</li>
</ul>
</li>
</ul>
<h4 id="UTP-布线"><a href="#UTP-布线" class="headerlink" title="UTP 布线"></a>UTP 布线</h4><p>在用作网络介质时，非屏蔽双绞线 (UTP) 由四对有彩色标记的铜线组成。这些铜线绞合在一起，并用软塑料套包裹。在安装过程中，它尺寸较小是有利的。</p>
<p>UTP 电缆并不使用屏蔽层来对抗 EMI 和 RFI 的影响。相反，电缆设计者发现他们可以通过以下方式来减少串扰的负面影响：</p>
<ul>
<li><strong>抵消</strong>：当电路中的两根电线紧密排列时，彼此的磁场正好相反。因此，这两个磁场相互抵消，也抵消了所有的外部 EMI 和 RFI 干扰信号。</li>
<li><strong>变化每个线对中的绞合数量</strong>：为了进一步增强配对电线的抵消效果，设计者会变化电缆中每个线对的绞合数量。UTP 电缆必须遵守精确的规定来管理每米（3.28 英尺）电缆所允许的绞合数或编织数。请注意，橙色/橙白色线对比蓝色/蓝白色线对的绞合要少。每个彩色线对绞合的次数不同。</li>
</ul>
<p>UTP 电缆<em>仅通过绞合线</em>对的抵消效果来减小信号衰减，并为网络介质中的线对提供有效的自屏蔽。</p>
<h5 id="UTP-布线标准"><a href="#UTP-布线标准" class="headerlink" title="UTP 布线标准"></a>UTP 布线标准</h5><p>电气电子工程师协会 (IEEE) 定义了铜缆的电特征。IEEE 按照它的性能对 UTP 布线划分等级。电缆分类的依据是它们承载更高速率带宽的能力。例如，5 (Cat5) 类电缆通常用于 100BASE-TX 快速以太网安装。其他类别包括增强型 5 (Cat5e) 类电缆、6 (Cat6) 类电缆 和 6a 类电缆。随着新的千兆位以太网技术的开发和运用，如今已经很少采用 5e 类电缆，新建筑安装推荐使用 6 类电缆。</p>
<ul>
<li>3 类电缆：用于语音，最常用语电话线路</li>
<li>5 类和 5e 类电缆：用于数据传输，支持 100Mb/s 和 1000Mb/s，但不推荐后者。5e 类电缆支持 1000Mb/s</li>
<li>6 类电缆：用于数据传输，已在每对线之间加入分隔物来增加传输速度，支持 1000Mb/s - 10Gb/s 但不推荐 10Gb/s</li>
</ul>
<h5 id="UTP-电缆类型"><a href="#UTP-电缆类型" class="headerlink" title="UTP 电缆类型"></a>UTP 电缆类型</h5><p>以下是通过使用指定的布线约定得到的主要电缆类型：<strong>以太网直通电缆 (Ethernet Straight-through)</strong>、<strong>以太网交叉电缆 (Ethernet Crossover)</strong>、<strong>全反电缆 (Rollover)</strong></p>
<ul>
<li>以太网直通电缆：最常见的网络电缆类型。它通常用于主机到交换机和交换机到路由器的互连。</li>
<li>以太网交叉电缆：用于互连相似设备的电缆。例如，交换机到交换机、主机到主机或路由器到路由器的连接。</li>
<li>全反电缆：思科专有电缆，用于工作站到路由器或交换机控制台端口的连接。</li>
</ul>
<p>图中显示了这些电缆的 UTP 电缆类型、相关标准以及典型应用。而且还标识了 TIA-568A 和 TIA-568B 标准的各个线对。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flkoidn76bj30h60bdq45.jpg" alt=""></p>
<h3 id="光缆-Fiber-optic-cable"><a href="#光缆-Fiber-optic-cable" class="headerlink" title="光缆 (Fiber-optic cable)"></a>光缆 (Fiber-optic cable)</h3><p>光缆能够以更远的距离和更高的带宽传输数据，并且完全不受 EMI 和 RFI 影响。<br>光纤是一种由非常纯的玻璃制成的极细透明的弹性线束。通过光缆传输时，位会被编码成光脉冲。光缆用作波导管或“光导管”，以最少的信号丢失来传输两端之间的光.<br>目前光纤布线用于四类行业：</p>
<ul>
<li>企业网络：用于主干布线和基础设施设备互连。</li>
<li>光纤到户 (FTTH)：用于为家庭和小型企业提供不间断宽带服务。</li>
<li>长距离传输网络：由服务提供商用于连接国家/地区与城市。</li>
<li>水下有线网络：用于提供可靠高速、高容量的网络解决方案，使其在深度与横跨海洋的距离相当的严酷海下环境中仍能生存。单击 <a href="http://www.submarinecablemap.com/" target="_blank" rel="noopener">此处</a> 查看描绘海底电缆位置的电信地理地图。</li>
</ul>
<h4 id="光纤介质的类型"><a href="#光纤介质的类型" class="headerlink" title="光纤介质的类型"></a>光纤介质的类型</h4><p>在介质中把被传输的数据表示为位的光脉冲是由以下物质产生的：</p>
<ul>
<li>激光 (Lasers)</li>
<li>发光二极管 (Light emitting diodes, LEDs)</li>
</ul>
<p>电子半导体设备（称为光电二极管）检测光脉冲并将其转换为电压。</p>
<p>光缆通常分为两种类型：</p>
<ul>
<li><strong>单模光纤 (Single-mode fiber, SMF)</strong>：包含一个极小的芯，使用昂贵的激光技术来发送单束光。普遍用于跨越数百千米的长距离传输，例如应用于长途电话和有线电视中的光纤。核心小，散射小，适合长距离应用，千米范围</li>
<li><strong>多模光纤 (Multimode fiber, MMF)</strong>：包含一个更大的芯，使用 LED 发射器发送光脉冲。具体而言，LED 发出的光从不同角度进入多模光纤。普遍用于 LAN 中，因为它们可以由低成本的 LED 提供支持。它可以通过长达 550 米的链路提供高达 10 Gb/s 的带宽。允许更大的色散，会导致信号丢失。适合长距离但是比单模较近，百米范围。</li>
</ul>
<p>多模和单模光纤之间的主要区别之一就是色散 (dispersion) 的数量。色散是指光脉冲在时间上的分布。色散越多，信号强度的减弱就越快。</p>
<h4 id="光纤与铜缆"><a href="#光纤与铜缆" class="headerlink" title="光纤与铜缆"></a>光纤与铜缆</h4><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flkordhtiij30gm047mxd.jpg" alt=""></p>
<h3 id="无线-Wireless"><a href="#无线-Wireless" class="headerlink" title="无线 (Wireless)"></a>无线 (Wireless)</h3><p>无线介质使用无线电或微波频率来承载代表数据通信二进制数字的电磁信号。<br>关于无线网络有一些关注重点，包括：</p>
<ul>
<li>覆盖面积：无线数据通信技术非常适合开放环境。但是，在楼宇和建筑物中使用的某些建筑材料以及当地地形将会限制它的有效覆盖。</li>
<li>干扰：无线电易受干扰，可能会受到家庭无绳电话、某些类型的荧光灯、微波炉和其他无线通信装置等常见设备的干扰。</li>
<li>安全性：无线通信覆盖无需进行介质的物理接线。因此，未获得网络访问授权的设备和用户可以访问传输。所以网络安全是无线网络管理的重要组成部分。</li>
<li>共享介质：WLAN 以半双工模式运行，意味着一台设备一次只能发送或接收。无线介质由所有无线用户共享。同时需要访问 WLAN 的用户越多，分配给每位用户的带宽越少。</li>
</ul>
<h4 id="无线介质的类型"><a href="#无线介质的类型" class="headerlink" title="无线介质的类型"></a>无线介质的类型</h4><p>无线数据通信的 IEEE 和电信行业标准包括数据链路层和物理层。</p>
<ul>
<li>Wi-Fi：标准 IEEE 802.11：无线 LAN (WLAN) 技术，通常称为 Wi-Fi。WLAN 使用一种称为“载波侦听多路访问/冲突避免 (CSMA/CA)”的争用协议。无线 NIC 在传输数据之前必须先侦听，以确定无线电通道是否畅通。如果其他无线设备正在传输，则 NIC 必须等待通道畅通。</li>
<li>标准 IEEE 802.15：蓝牙：无线个域网 (WPAN) 标准，通常称为“蓝牙”，采用装置配对过程进行通信，距离为 1 到 100 米。</li>
<li>标准 IEEE 802.16：WiMAX：通常称为微波接入全球互通 (WiMAX)，采用点到多点拓扑结构，提供无线带宽接入。</li>
</ul>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>数据链路层（Data Link Layer）是OSI参考模型第二层，位于物理层与网络层之间。在广播式多路访问链路中（局域网），由于可能存在介质争用，它还可以细分成介质访问控制（MAC）子层和逻辑链路控制（LLC）子层，介质访问控制（MAC）子层专职处理介质访问的争用与冲突问题。</p>
<p>在第 2 层中连接到公共介质的网络设备称为节点。节点将生成并转发帧。OSI 数据链路层负责帧在物理网络介质中源节点和目的节点之间的交换。</p>
<p>局域网与广域网皆属第1,2层。</p>
<h2 id="数据链路子层"><a href="#数据链路子层" class="headerlink" title="数据链路子层"></a>数据链路子层</h2><p>数据链路层可以拆分成两个子层：</p>
<ul>
<li><strong>逻辑链路控制 (Logical Link Control，LLC)</strong> - 这一较高子层与网络层通信。它放入帧中的信息用于确定帧所使用的网络层协议。此信息允许多个第 3 层协议（如 IPv4 和 IPv6）使用相同的网络接口和介质。用户的数据链路服务通过LLC子层为网络层提供统一的接口。</li>
<li><strong>介质访问控制 (Media Access Control，MAC)</strong> - 是局域网中数据链路层的下层部分，提供定址及媒体访问的控制方式，使得不同设备或网络上的节点可以在多点的网络上通信，而不会互相冲突，上述的特性在局域网或者城域网中格外重要。</li>
</ul>
<h2 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h2><p>第 2 层协议指定了将数据包封装成帧的过程，以及用于将已封装数据包放置到各介质上和从各介质获取已封装数据包的技术。用于将帧放置到介质上和从介质获取帧的技术称为介质访问控制方法。</p>
<p><strong>当数据包从源主机到目的主机传输时，它们通常会经过不同的物理网络。这些物理网络可由不同类型的物理介质组成</strong>，如铜线、光纤、由电磁信号、无线电和微波频率组成的无线介质，以及卫星链路。</p>
<p>如果没有数据链路层，则网络层协议（如 IP）必须提供连接到传送路径中可能存在的各种类型介质所需的连接。而且，每当系统开发出一种新的网络技术或介质时，IP 必须做出相应调整。此过程会妨碍协议和网络介质的创新和发展。这是采用分层式方法进行联网的主要原因。</p>
<p>实际使用的介质访问控制方法取决于：</p>
<ul>
<li>拓扑（Topology） - 节点之间的连接如何显示在数据链路层中。</li>
<li>介质共享（Media sharing） - 节点如何共享介质。介质共享可以是点对点（例如 WAN 连接中的共享）或者例如 LAN 网络中的共享。</li>
</ul>
<h3 id="常见的物理WAN拓扑"><a href="#常见的物理WAN拓扑" class="headerlink" title="常见的物理WAN拓扑"></a>常见的物理WAN拓扑</h3><p><strong>- 点对点(Point-to-Point)</strong> - 这是最简单的拓扑，由两个端点间的永久链路组成。因此，这是一种非常普遍的 WAN 拓扑。<br><strong>- 集中星型(Hub and Spoke)</strong> - 星型拓扑的 WAN 版本，在该拓扑中一个中心站点使用点对点链路互连分支站点。<br><strong>- 网状(Mesh )</strong> - 该拓扑可用性高，但要求每个终端系统都与其他各个系统互连。因此管理成本和物理成本都会非常高。每条链路实质上是另一节点的点对点链路。</p>
<h3 id="物理-LAN-拓扑"><a href="#物理-LAN-拓扑" class="headerlink" title="物理 LAN 拓扑"></a>物理 LAN 拓扑</h3><p>物理拓扑定义了终端系统的物理互连方式。在共享介质 LAN 上，终端设备可以使用以下物理拓扑互连：</p>
<ul>
<li>星型（Star） - 将终端设备连接到中心中间设备。早期的星型拓扑使用以太网集线器互连终端设备。但现在，星型拓扑使用以太网交换机。星型拓扑安装简易、扩展性好（易于添加和删除终端设备），而且故障排除容易。</li>
<li>扩展星型（Extended Star） - 在扩展星型拓扑中，额外的以太网交换机与其他星型拓扑互连。扩展星型是一种混合拓扑。</li>
<li>总线（Bus） - 所有终端系统都相互连接，并在两端以某种形式端接。终端设备互连时不需要基础设施设备（例如交换机）。因为总线拓扑价格低廉而且安装简易，所以传统的以太网络中会使用采用同轴电缆的总线拓扑。</li>
<li>环（Ring） - 终端系统与其各自的邻居相连，形成一个环状。与总线拓扑不同，环拓扑不需要端接。环拓扑用于传统的光纤分布式数据接口 (FDDI) 和令牌环网络。</li>
</ul>
<h2 id="提供介质访问"><a href="#提供介质访问" class="headerlink" title="提供介质访问"></a>提供介质访问</h2><p>在每个通信中可能需要不同的介质访问控制方法。在数据包从本地主机传送到远程主机的过程中，其遇到的各种网络环境可能具有不同的特性。例如，以太网 LAN 由许多竞争访问网络介质的主机组成。串行链路由仅两个设备之间的直接连接组成。</p>
<p>路由器接口将数据包封装为适当的帧，并使用适当的介质访问控制方法来访问每条链路。在任意指定的网络层数据包交换过程中，可能存在多次数据链路层和介质的转换。</p>
<p>在路径沿途的每一跳，路由器：从介质接受帧 -&gt; 解封帧 -&gt; 将数据包重新封装到新帧中 -&gt; 从适合该物理网络网段的介质转发新帧</p>
<p>例如路由器具有连接到 LAN 的一个以太网接口和连接到 WAN 的一个串行接口。在处理帧的过程中，路由器将使用数据链路层服务从某个介质接收帧，再将它解封到第 3 层 PDU，然后将 PDU 重新封装到新帧中，再将帧放到网络下一链路的介质中。</p>
<h2 id="全双工和半双工（Half-and-Full-Duplex）"><a href="#全双工和半双工（Half-and-Full-Duplex）" class="headerlink" title="全双工和半双工（Half and Full Duplex）"></a>全双工和半双工（Half and Full Duplex）</h2><p>双工通信是指两台设备之间数据传输的方向。半双工通信会将每次的数据交换限制为一个方向，而全双工允许同时发送和接收数据。</p>
<ul>
<li>半双工通信 - 两台设备都可以通过该介质发送和接收，但无法同时执行这两个操作。半双工模式在传统总线拓扑中与以太网集线器配合使用。WLAN 也在半双工模式下运行。半双工每次只允许一台设备通过共享介质发送或接收，而且会与争用访问方法结合使用。</li>
<li>全双工通信 - 两台设备均可同时通过介质进行发送和接收。数据链路层假定介质随时可供两个节点实现传输。默认情况下，以太网交换机在全双工模式下运行，但是如果与以太网集线器等设备连接，则可以在半双工模式下运行。</li>
</ul>
<p><strong>两个互连设备，比如一个主机网卡和以太网交换机上的一个接口，必须采用同一双工模式运行</strong>。否则，将会出现双工不匹配，导致链路上效率低下和延时。</p>
<h2 id="介质访问控制方法"><a href="#介质访问控制方法" class="headerlink" title="介质访问控制方法"></a>介质访问控制方法</h2><p>在某些网络拓扑中，多个节点共享一个公共介质。这些称为多路访问网络。以太网 LAN 和 WLAN 都是多路访问网络的示例。在某一时刻，可能有多个设备尝试通过同一网络介质发送和接收数据。</p>
<p>某些多路访问网络需要使用规则来管理设备共享物理介质的方式。对于共享介质，有两种基本的访问控制方法：</p>
<ul>
<li>争用访问（Contention-based access） - 在半双工模式下运行的所有节点争用介质，但一次只有一台设备可以发送。但是，当多台设备同时传输时，会使用一个进程。使用集线器的以太网 LAN 和 WLAN 都是这种访问控制类型的示例。</li>
<li>受控访问（Controlled access） - 每个节点都有各自使用介质的时间。这种确定性的网络类型效率很低，因为设备必须等到轮到自己才能访问介质。传统令牌环 LAN 就是这种访问控制类型的示例。</li>
</ul>
<p>默认情况下，以太网交换机在全双工模式下运行。这允许交换机和全双工连接的设备同时发送和接收。</p>
<h3 id="争用访问-–-CSMA-CD"><a href="#争用访问-–-CSMA-CD" class="headerlink" title="争用访问 – CSMA/CD"></a>争用访问 – CSMA/CD</h3><p>WLAN、使用集线器的以太网 LAN 和传统以太网总线网络都是争用访问网络的示例。所有这些网络都在半双工模式下运行。这需要有一个进程来管理设备何时可以发送以及当多台设备同时发送时会发生什么情况。</p>
<p>载波侦听多路访问/冲突检测 (The Carrier Sense Multiple Access/Collision Detection，CSMA/CD) 进程可用于半双工以太网 LAN。CSMA 进程如下：</p>
<ol>
<li>PC1 有一个以太网帧要发送给 PC3。</li>
<li>PC1 的网卡需要确定是否有人通过介质传输。如果它没有检测到载波信号，也就是说，它没有收到来自其他设备的传输，则假定网络可用于发送。</li>
<li>PC1 的网卡发送以太网帧</li>
<li>以太网集线器接收帧。以太网集线器也称为多端口中继器。传入端口上收到的任何位都会重新生成，并通过所有其他端口发送出去</li>
<li>如果另一台设备，比如 PC2，想要传输，但当前正在接收一个帧，则它必须等待通道畅通。</li>
<li>与集线器连接的所有设备都将收到该帧。由于帧拥有 PC3 的目的数据链路地址，只有该设备会接受并复制整个帧。所有其他设备的网卡都将忽略该帧</li>
</ol>
<p>如果两台设备同时传输，则会发生冲突。两台设备都将检测到网络上的冲突，这就是冲突检测 (Collision Detection，CD)。这一过程可通过网卡比较传输的数据与接收的数据，或通过识别出介质中的信号振幅高于正常状况来实现。两台设备发送的数据会损坏且需重新发送。</p>
<h3 id="争用访问-–-CSMA-CA"><a href="#争用访问-–-CSMA-CA" class="headerlink" title="争用访问 – CSMA/CA"></a>争用访问 – CSMA/CA</h3><p>IEEE 802.11 WLAN 所使用的另一种 CSMA 形式为载波侦听多路访问/冲突避免 ( Carrier Sense Multiple Access/Collision Avoidance，CSMA/CA)。CMSA/CA 采用一种与 CSMA/CD 类似的方法来检测介质是否畅通。CMSA/CA 还采用其他技术。CMSA/CA 不会检测冲突，但会通过在传输之前等待来尝试避免冲突。要进行传输的每台设备都包含传输所需的持续时间。所有其他无线设备都会收到此信息，知道介质将有多长时间不可用，如图所示。当无线设备发送 802.11 帧后，接收方会返回确认，以使发送方知道帧已到达。</p>
<p>不管是使用集线器的以太网 LAN，还是 WLAN，争用系统在介质使用率高的情况下都无法很好地扩展。一定要注意，使用交换机的以太网 LAN 不使用争用系统，因为交换机和主机网卡在全双工模式下运行。</p>
<h2 id="帧字段"><a href="#帧字段" class="headerlink" title="帧字段"></a>帧字段</h2><p>成帧技术将位流拆分成可破解的多个分组，且将控制信息作为不同字段值插入帧头和帧尾中。此格式使物理信号具备能被节点接收且可在目的地解码成数据包的一种结构。</p>
<p>通用帧字段类型包括：</p>
<ul>
<li>帧开始和停止指示标志（Frame start and stop indicator flags） - 用于标识帧的开始和结束位置的限制。</li>
<li>编址（Addressing） - 表示介质上的源节点和目的节点。</li>
<li>类型（Type） - 用于标识数据字段中的第 3 层协议。</li>
<li>控制（control） - 用于标识特殊流量控制服务，比如服务质量 (QoS)。QoS 用于为某些类型的消息提供转发优先权。传送 IP 语音 (VoIP) 数据包的数据链路帧通常会获得优先权，因为它们对延迟敏感。</li>
<li>数据（Data） - 包含帧负载（即数据包报头、数据段报头和数据）。</li>
<li>错误检测（Error detectioni） - 这些帧字段用于进行错误检测并包含在数据之后形成帧尾。</li>
</ul>
<p>并非所有协议均包含全部此类字段。特定数据链路协议的标准定义了实际帧格式。</p>
<p>数据链路层协议将帧尾添加到各帧结尾处。帧尾的作用是确定帧是否无错到达。此过程称为错误检测，通过将组成帧的各个位的逻辑或数学摘要放入帧尾中来实现。因为介质中的信号可能遭受干扰、失真或丢失，从而大幅更改这些信号所代表的位值，所以要将错误检测添加到数据链路层。</p>
<p>发送节点会创建帧内容的逻辑摘要，称为循环冗余校验 (cyclic redundancy check，CRC) 值。此值将放入帧校验序列 (FCS) 字段中以代表帧内容。在以太网尾部，FCS 为接收节点提供一种方法，用于确定帧是否出现传输错误。</p>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ul>
<li><strong>bandwith</strong> - the maximum rate at which data can be carried over a specific medium</li>
<li><strong>throughput</strong> - the actual amount of data, in bits, that crosses a given point in a network over a certain period of time</li>
<li><strong>goodput</strong> - the amount of usable data that crosses a given point in a network over a certain period of time</li>
<li><strong>electromagnetic interference</strong> - interference that is caused when the electromagnetic field of one device affects the electromagnetic field of other devices</li>
<li><strong>radio frequency interference</strong> - electromagnetic interference that is in the radio frequency range</li>
<li><strong>crosstalk</strong> - occurs when the signals of one wire affect the signals on an adjacent wire</li>
<li><strong>cancellation</strong> - the twisting of opposing wires to effectively eliminate crosstalk</li>
<li><strong>Header</strong> - information that is added before the data field in a frame</li>
<li><strong>trailer</strong> - information that is added after the data field in a frame</li>
<li><strong>physical topology</strong> - the actual connections and layout of devices in a network</li>
<li><strong>logical topology</strong> - the way that the data travels through the network</li>
<li><strong>contention-based access</strong> - nodes compete to be able to use the network medium</li>
<li><strong>controlled access</strong> - when each node has an orderly opportunity to access the medium</li>
<li><strong>frame check sequence</strong> - value of the field in a frame that is computed from the contents of the frame and determines if the frame has been damaged</li>
<li><strong>full-deplex</strong> - devices are able to send and receive data simultaneously</li>
<li><strong>half-deplex</strong> - devices are able to send and receive information, but only one direction at a time.</li>
</ul>
]]></content>
      <categories>
        <category>ESAIP</category>
        <category>CCNA</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA Chapter 3: Network Protocols and Communications</title>
    <url>/2017/12/14/CCNA-Chapter-3-Network-Protocols-and-Communications/</url>
    <content><![CDATA[<h1 id="通信基本规则"><a href="#通信基本规则" class="headerlink" title="通信基本规则"></a>通信基本规则</h1><p>对于所有的通信形式，不论是人与人之间的还是计算机之间的，都需要具有三种基本的要素，消息来源、消息目的地和通道。</p>
<p>除此之外通信的双方必须对通信的内容有着同样的解读规范，既是协议（Protocols），所有的协议必须具有以下方面：</p>
<ul>
<li>标识发送方和接收方</li>
<li>通用语言和语法</li>
<li>传递的速度和时间</li>
<li>证实或确认要求</li>
</ul>
<p>网络通信中使用的协议共享许多基本特质。除了识别源和目的地址之外，计算机和网络协议还定义了消息在网络中如何传输的细节。<br>常用的计算机协议如下：</p>
<ul>
<li>消息编码 Message Encoding</li>
<li>消息格式和封装 Message Formatting and Encapsulation</li>
<li>消息大小 Message Size</li>
<li>消息时序 Message Timming</li>
<li>消息传输选项 Message Delivery Options</li>
</ul>
<a id="more"></a>
<h2 id="消息编码"><a href="#消息编码" class="headerlink" title="消息编码"></a>消息编码</h2><p>在发送消息时，首先执行的步骤之一是编码（Encoding）。编码是为了便于传输信息，信息将被转换为另一种广为接受的形式。解码（Decoding）是编码的逆向过程，其目的是解释信息。</p>
<p>主机之间的编码必须采用适合介质的格式。通过网络发送的消息先由发送主机转换成位。根据用来传输位的网络介质，将每个位编码成声音、光波或电子脉冲的样式，如铜制线缆和光纤分别采用不同的信号传递信息。目的主机接收并解码信号，解释收到的消息。</p>
<h2 id="消息格式和封装"><a href="#消息格式和封装" class="headerlink" title="消息格式和封装"></a>消息格式和封装</h2><p>对于人们之前广为使用的书信交流方式，信件都包含以下要素：收信人的标识，称呼，信件正文，结束语，信件的身份标识。这就是消息的格式。除此之外，大多数信件还需要信封，信封上有寄信人和收信人的地址。如果目的地址和格式不正确，信件就无法投递。</p>
<p>将一种消息格式（信件）放入另一种消息格式（信封）的过程称为封装（encapsulation）。收信人从信封中取出信件的过程就是解封（De-encapsulation）。</p>
<p>通过计算机网络发送的消息也要遵循特定的格式规则才能被发送和处理。就像信件封装在信封中进行投递一样，计算机消息也以类似方式处理。<strong>每条计算机消息在通过网络发送之前都以特定的格式封装，称为帧（frame）</strong>。帧就像信封一样；它提供目的地址和源主机的地址。注意，帧在帧编址部分和封装的消息中都有一个源地址和一个目的地址。关于这两种类型的地址之间的区别将在本章后续部分作出说明。</p>
<p>帧的格式和内容由消息类型及其发送通道决定。消息如果没有正确格式化，就无法成功发送或被目的主机处理。</p>
<h2 id="消息大小"><a href="#消息大小" class="headerlink" title="消息大小"></a>消息大小</h2><p>通信的另一条规则是大小。人们在相互交流时，他们发送的消息通常会分成较小的部分或较短的句子。这些句子的大小限制为接收方一次可以处理的大小。</p>
<p>同样，将一条长消息通过网络从一台主机发送到另一台主机时，也必须将其分为许多小片段控制网络中传送的消息片段（帧）大小的规则非常严格，并且不同的渠道有不同的规则。帧太长或太短都无法传送。帧大小限制规则要求源主机将长消息分割为同时符合最小和最大长度要求的多个片段。长消息必须分成不同的帧发送，其中每个帧包含原始消息的一个片段。每个帧还将拥有自己的编址信息。在接收主机上，消息的各个片段会重新组合为原始消息</p>
<h2 id="消息时序"><a href="#消息时序" class="headerlink" title="消息时序"></a>消息时序</h2><ul>
<li>信息的访问方法： 网络主机需要访问方法来了解开始发送消息的时间以及在发生冲突时响应的方式。</li>
<li>流量控制： 源主机和目的主机使用流量控制方法来协商成功通信的正确时序。</li>
<li>响应超时：网络主机也会使用规则来指定等待响应的时长，以及在响应超时的情况下执行什么操作。</li>
</ul>
<h2 id="消息传输选项"><a href="#消息传输选项" class="headerlink" title="消息传输选项"></a>消息传输选项</h2><p>对于不同类型的消息，有的需要接收方收到后发送确认回执，而有的不需要。此外，一对一传输选项称为<strong>单播（unicast）</strong>，如果主机需要用一对多传输选项发送消息，则称为“<strong>组播（multicast）</strong>”，如果网络上所有主机都需要同时接收该消息，可以使用<strong>广播（broadcast）</strong>。广播代表一对全体的消息传输选项。</p>
<h1 id="网络协议和标准"><a href="#网络协议和标准" class="headerlink" title="网络协议和标准"></a>网络协议和标准</h1><p>通信协议或简称为传输协议（Communications Protocol）在电信中，是指在任何物理介质中允许两个或多个在传输系统中的终端之间传播信息的系统标准，也是指计算机通信或网络设备的共同语言， <strong>通信协议定义了通信中的语法学, 语义学和同步规则以及可能存在的错误检测与纠正</strong>。通信协议在硬件，软件或两者之间皆可实现</p>
<p>协议栈（Protocol stack），又称协议堆叠，是计算机网络协议套件（协议簇，协议族）的一个具体的软件实现。</p>
<p>例如对于 TCP/IP 协议族，常见的协议有应用层的 HTTP、DNS、DHCP，传输层的 TCP、UDP，互联网层的 IPV4、IPV6、ICMP，网络接入层的 Ethernet 等等</p>
<h2 id="TCP-IP-协议族的通信过程"><a href="#TCP-IP-协议族的通信过程" class="headerlink" title="TCP/IP 协议族的通信过程"></a>TCP/IP 协议族的通信过程</h2><ol>
<li><p>首先演示是 Web 服务器准备超文本标记语言 (HTML) 页面作为需要发送的数据。</p>
</li>
<li><p>将应用程序协议 HTTP 报头添加到 HTML 数据的前面。报头包含各种信息，包括服务器所使用的 HTTP 版本和指示它有信息需要传送给 Web 客户端的状态码。</p>
</li>
<li><p>HTTP 应用层协议将 HTML 格式的网页数据传送到传输层。TCP 传输层协议用于管理单个会话，本示例中为 Web 服务器和 Web 客户端之间的单个会话。</p>
</li>
<li><p>接下来将 IP 信息添加到 TCP 信息的前面。IP 分配合适的源和目的 IP 地址。此信息称为 <strong>IP 数据包（IP packet）</strong>。</p>
</li>
<li><p>以太网协议将信息添加到 IP 数据包的两端，称为<strong>数据链路帧（ data link frame）</strong>。将此帧传送到通往 Web 客户端的路径中最近的路由器上。该路由器将删除以太网信息，分析 IP 数据包，为该数据包确定最佳路径，将数据包插入新的帧中，并将其发送到通往目的地的下一个邻居路由器上。<strong>每台路由器在转发数据包之前都会删除旧的数据链路信息并添加新的数据链路信息</strong>。</p>
</li>
<li><p>现在该数据在由介质和中间设备组成的网际网络中传输。</p>
</li>
<li><p>客户端收到包含数据的数据链路帧。每个协议报头都会得到处理，然后按与添加相反的顺序将其删除。将以太网信息处理并删除之后，接着处理并删除 IP 协议信息，然后是 TCP 信息，最后是 HTTP 信息。</p>
</li>
<li><p>然后网页信息将传递到客户端的 Web 浏览器软件。</p>
</li>
</ol>
<p>总的来说：在每一层上都会将上一层封装好的数据整个地重新作为新的消息再封装上这一层所添加的信息。具体可以看该章 <a href="./#封装与解封">封装与解封</a> 部分</p>
<h1 id="网络分层模型"><a href="#网络分层模型" class="headerlink" title="网络分层模型"></a>网络分层模型</h1><p>网络模型只是网络工作原理的表示方式，模型不是实际的网络。</p>
<p>使用分层模型来描述网络协议及其工作方式的优点包括：</p>
<ul>
<li>有助于协议设计，因为对于在特定层工作的协议而言，它们的工作方式及其与上下层之间的接口都已经确定。</li>
<li>促进竞争，因为可以同时使用不同厂商的产品。</li>
<li>避免一个协议层的技术或功能变化影响相邻的其他层。</li>
<li>提供了描述网络功能和能力的通用语言。</li>
</ul>
<p>TCP/IP 模型和开放式系统互联 (OSI) 模型是讨论网络功能时使用的主要模型。它们每个代表一个基本分层网络模型类型：</p>
<ul>
<li><strong>协议模型（Protocol model）</strong> - 这种类型的模型与特定的协议簇结构紧密配合。TCP/IP 模型描述了 TCP/IP 协议簇中每个协议层实现的功能，因此属于协议模型。TCP/IP 也用作参考模型。</li>
<li><strong>参考模型（Reference model）</strong> - 这种类型的模型通过描述特定层需要完成什么但不规定如何完成来保持各类网络协议和服务中的一致性。OSI 模型是一种广为人知的网际网络参考模型，但也是 OSI 协议簇中的一种协议模型。</li>
</ul>
<h2 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h2><p>OSI 参考模型总共有 7 层，从上到下分别为：</p>
<ul>
<li><strong>应用层 (Application)</strong>：包含用于进程间通讯的协议</li>
<li><strong>表示层 (Presentation)</strong>：对应用层服务之间传输的数据规定了通用的表示方法。</li>
<li><strong>会话层 (Session)</strong>：为表示层提供组织对话和管理数据交换的服务</li>
<li><strong>传输层 (Transport)</strong>：为终端设备之间的每个通讯定义了<strong>数据分段</strong>、传输和重组服务 <strong>封装端口信息</strong></li>
<li><strong>网络层 (Network)</strong>：为所标识的终端设备之间通过网络交换一个个数据的片段提供服务，<strong>封装逻辑地址，即 IP 地址</strong></li>
<li><strong>数据链路层 (Data Link)</strong>：描述了设备之间通过公共介质交换数据帧的方法 <strong>添加物理地址，即 MAC 地址</strong></li>
<li><strong>物理层 (Physical)</strong>：物理层协议描述的机械、电气、功能和操作方法用于激活、维护和停用网络设备之间比特传输使用的物理连接</li>
</ul>
<h2 id="TCP-IP-协议模型"><a href="#TCP-IP-协议模型" class="headerlink" title="TCP/IP 协议模型"></a>TCP/IP 协议模型</h2><p> TCP/IP 协议模型公有 4 层，从上到下依次为：</p>
<ul>
<li><strong>应用层 (Application)</strong>：向用户提供数据，以及编码和对话控制</li>
<li><strong>传输层 (Transoprt)</strong>：支持各种设备之间通过不同网络通信</li>
<li><strong>互联网层 (Internet)</strong>：确定通过网络的最佳路径</li>
<li><strong>网络接入层 (Network Access)</strong>：控制组成网络的硬件设备和介质</li>
</ul>
<h2 id="两种网络模型的对比"><a href="#两种网络模型的对比" class="headerlink" title="两种网络模型的对比"></a>两种网络模型的对比</h2><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1fmgt6x76pyj30ey0a6wf5.jpg" alt=""></p>
<h1 id="网络中的数据传输"><a href="#网络中的数据传输" class="headerlink" title="网络中的数据传输"></a>网络中的数据传输</h1><h2 id="消息分段"><a href="#消息分段" class="headerlink" title="消息分段"></a>消息分段</h2><p>理论上来说，可以将一次通信的内容作为一大块连续的高容量位流，通过网络从源发送到目的地。但如果真以这种方式传输消息，那就意味着在传输此数据期间，同一个网络中的其他设备都不能发送或接收消息。这种大型数据流会导致严重的延迟。而且，一旦互联网络基础架构中有一条链路在传输期间出现故障，那么整个消息都会丢失，必须全部重传。</p>
<p>所以，更好的办法是先将数据划分为更小、更易于管理的片段，然后再通过网络发送。将数据流划分为较小的片段称为<strong>分段 (segmentation)</strong>。消息分段主要有两个优点：</p>
<ul>
<li>通过从源设备向目的设备发送一个个小片段，就可以在网络上交替发送许多不同会话，称为<strong>多路复用 (multiplexing)</strong>。</li>
<li>分段可以增强网络通信的效率。如果由于网络故障或网络拥塞，有部分消息未能传送到目的地，则只需重新传输丢失的部分。</li>
</ul>
<p>使用分段和多路复用在网络上传输消息要面临的挑战是增加了该过程的复杂程度。</p>
<h2 id="封装与解封"><a href="#封装与解封" class="headerlink" title="封装与解封"></a>封装与解封</h2><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flkmfni2lvj30h70d6taf.jpg" alt="">‘<br>在通过网络介质传输应用程序数据的过程中，随着数据沿协议栈向下传递，每层都要添加各种协议信息。此过程称为<strong>封装 (Encapsulation)</strong>。<br>一段数据在任意协议层的表示形式称为<strong>协议数据单元 (Protocol Data Units , PDU)</strong>。在封装过程中，后续的每一层都根据使用的协议封装其从上一层接收的 PDU。在网络中发送消息时，封装过程自上而下工作。在各层，上层信息被视为封装协议内的数据。例如，TCP 数据段被视为 IP 数据包内的数据。<br>接收主机上的过程与之相反，称为<strong>解封 (De-encapsulation)</strong>。解封是接收设备用来删除一个或多个协议报头的过程。数据在朝着最终用户应用程序沿<em>协议栈向上移动</em>的过程中被解封。</p>
<p>Logical addresses, also known as IP addresses, are encapsulated at the network layer. Physical addresses are encapsulated at the data link layer. Port addresses are encapsulated at the transport layer. No addresses are encapsulated at the physical layer.</p>
<h2 id="网络地址和数据链路地址"><a href="#网络地址和数据链路地址" class="headerlink" title="网络地址和数据链路地址"></a>网络地址和数据链路地址</h2><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flkmmtew4kj30fs03mwem.jpg" alt=""><br>网络层和数据链路层负责将数据从源设备传输到目的设备。如图，两层中的协议都包含源地址和目的地址，但它们的地址具有不同的用途。</p>
<ul>
<li><strong>网络层源地址和目的地址 (Network layer source and destination addresses)</strong> - 负责将 IP 数据包从原始源设备传输到处于同一网络或远程网络中的最终目的设备。</li>
<li><strong>数据链路层源地址和目的地址 (Data link layer source and destination addresses)</strong> – 负责将数据链路帧从一个网络接口卡 (NIC) 传输到同一网络上的另一个 NIC。</li>
</ul>
<p>IP 地址是网络层（或第 3 层）逻辑地址，用于将 IP 数据包从原始源设备传输到最终目的设备。<br>IP 数据包包含两个 IP 地址：</p>
<ul>
<li><strong>源 IP 地址 (Source IP address)</strong> - 发送设备（数据包的原始源设备）的 IP 地址。</li>
<li><strong>目的 IP 地址 (Destination IP address)</strong> - 接收设备（数据包的最终目的设备）的 IP 地址。</li>
<li>MAC 地址是以太网网卡的物理内嵌地址。The MAC address is also known as the physical or Ethernet address. Because it is encoded on hardware, on the Ethernet NIC, it will stay the same no matter where the NIC is geographically located.</li>
</ul>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ul>
<li><strong>encoding</strong> - process of modifying data to an acceptable format for transmission</li>
<li><strong>decoding</strong> - process of modifying transmitted data into a format that is usable by a device</li>
<li><strong>encapsulation</strong> - process of inserting a formatted message inside another formatted message</li>
<li><strong>segmentation</strong> - process of splitting data into smaller pieces for transmission on a network</li>
<li><strong>de-encapsulation</strong> - process of removing a formatted message from another formatted message</li>
<li><strong>unicast</strong> - a form of message delivery in which a message is delivered to a single destination</li>
<li><strong>multicast</strong> - a form of transmission in which a message is delivered to a group of hosts</li>
<li><strong>broadcast</strong> - a form of transmission in which a message is delivered to all hosts on a network</li>
<li><strong>open standard</strong> - refers to protocols that are available to the public at no cost</li>
<li><strong>proprietary</strong> - refers to protocols that are developed by companies and are available to the public for purchase</li>
<li><strong>PDU</strong> - the form of a piece of data that is associated with each protocol layer</li>
<li><strong>default gateway</strong> - a router that is responsible for redirecting the packets it receives to their destination</li>
</ul>
]]></content>
      <categories>
        <category>ESAIP</category>
        <category>CCNA</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA Chapter 2: Configure a Network Operating System</title>
    <url>/2017/12/12/CCNA-Chapter-2-Configure-a-Network-Operating-System/</url>
    <content><![CDATA[<h1 id="基本操作系统概念"><a href="#基本操作系统概念" class="headerlink" title="基本操作系统概念"></a>基本操作系统概念</h1><h2 id="Shell-壳层"><a href="#Shell-壳层" class="headerlink" title="Shell, 壳层"></a>Shell, 壳层</h2><p>在计算机科学中，壳层（英语：shell）指“为用户提供用户界面”的软件，通常指的是命令行界面的解析器。一般来说，这个词是指操作系统中，提供访问内核所提供之服务的程序。<strong>Shell 也用于泛指所有为用户提供操作界面的程序，也就是程序和用户交互的接口</strong>。因此与之相对的是程序内核（英语：kernel），内核不提供和用户的交互功能。</p>
<p>不过这个词也拿来指应用软件，或是任何在特定组件外围的软件，例如浏览器或电子邮件软件是 HTML 排版引擎的 shell。Shell 这个词是来自于操作系统（内核）与用户界面的外层界面。</p>
<p>通常将 shell 分为两类：命令行与图形界面。命令行壳层提供一个命令行界面（CLI）；而图形壳层提供一个图形用户界面（GUI）。</p>
<ul>
<li>命令行界面（英语：command-line interface，缩写：CLI）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为字符用户界面（character user interface, CUI）。</li>
<li>图形用户界面（Graphical User Interface，简称 GUI）是指采用图形方式显示的计算机操作用户界面。与早期计算机使用的命令行界面相比，图形界面对于用户来说在视觉上更易于接受。然而这界面若要通过在显示器的特定位置，以“各种美观、而不单调的视觉消息”提示用户“状态的改变”，势必得比简单的文字消息呈现，花上更多的电脑运算能力，计算“要改变显示器哪些光点，变成哪些颜色”。</li>
</ul>
<h2 id="Kernel-内核"><a href="#Kernel-内核" class="headerlink" title="Kernel, 内核"></a>Kernel, 内核</h2><p>在计算机科学中，内核（英语：kernel），是一个电脑程序，用来管理软件发出的数据 I/O（输入与输出）要求，将这些要求转译为数据处理的指令，交由中央处理器（CPU）及电脑中其他电子组件进行处理，是现代操作系统中最基本的部分。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并由内核决定一个程序在什么时候对某部分硬件操作多长时间。<strong>直接对硬件操作是非常复杂的。所以内核通常提供一种硬件抽象的方法，来完成这些操作。</strong>通过进程间通信机制及系统调用，应用进程可间接控制所需的硬件资源（特别是处理器及 IO 设备）。</p>
<a id="more"></a>
<h1 id="操作系统的访问"><a href="#操作系统的访问" class="headerlink" title="操作系统的访问"></a>操作系统的访问</h1><p>在配置系统时，需要访问 CLI 环境的时候可以用以下三种方法</p>
<h2 id="控制台，console"><a href="#控制台，console" class="headerlink" title="控制台，console"></a>控制台，console</h2><p>这里说的是硬件层面的控制台，而不是通俗的与 CLI 通意的控制台。是一种物理管理端口，可通过该端口对思科设备进行带外访问（out-of-band access）。带外访问是指通过仅用于设备维护的专用管理通道进行访问。</p>
<p>使用控制台端口的优势在于，即使没有配置任何网络服务，也可以访问设备，例如执行网络设备的初始配置时。当执行初始配置时，运行终端仿真软件的计算机使用特殊电缆连接到设备的控制台端口。用于设置交换机或路由器的配置命令可通过该相连的计算机输入。</p>
<h2 id="Telnet"><a href="#Telnet" class="headerlink" title="Telnet"></a>Telnet</h2><p>Telnet 协议是一种应用层协议，使用于互联网及局域网中，使用虚拟终端机的形式，提供双向、以文字字符串为主的交互功能。属于 TCP/IP 协议族的其中之一，是 Internet 远程登录服务的标准协议和主要方式，常用于网页服务器的远程控制，可供用户在本地主机运行远程主机上的工作。</p>
<p>Telnet 在 1969 年开发出来，在 RFC 15 定义， RFC 854 定义了扩展。互联网工程任务组（IETF），在 STD 8 中，将其加以标准化，是最早形成的互联网协议之一。</p>
<p>传统 Telnet 会话所传输的数据并未加密，账号和密码等敏感数据容易会被窃听，因此很多服务器都会封锁 Telnet 服务，改用更安全的 SSH。</p>
<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>Secure Shell（安全外壳协议，简称 SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH 通过在网络中创建安全隧道来实现 SSH 客户端与服务器之间的连接。虽然任何网络服务都可以通过 SSH 实现安全传输，SSH 最常见的用途是远程登录系统，人们通常利用 SSH 来传输命令行界面和远程执行命令。</p>
<p>SSH 是用于远程管理的推荐方法，因为它可以提供安全连接。SSH 提供加密密码身份验证和会话数据的传输。这可使用户 ID、密码和管理会话的详细信息保持私密。</p>
<p>在设计上，SSH 是 Telnet 和非安全 shell 的替代品。Telnet 和 Berkeley rlogin、rsh、rexec 等协议采用明文传输，使用不可靠的密码，容易遭到监听、嗅探和中间人攻击。SSH 旨在保证非安全网络环境（例如互联网）中信息加密完整可靠。</p>
<h2 id="终端仿真程序"><a href="#终端仿真程序" class="headerlink" title="终端仿真程序"></a>终端仿真程序</h2><p>有许多不错的终端仿真程序可通过与控制台端口的串行连接或 SSH/Telnet 连接进行网络设备连接。</p>
<ul>
<li>PuTTY</li>
<li>Tera Term</li>
<li>SecureCRT</li>
<li>OS X 终端</li>
</ul>
<h1 id="Cisco-IOS-Cisco-Internetwork-Operating-System"><a href="#Cisco-IOS-Cisco-Internetwork-Operating-System" class="headerlink" title="Cisco IOS, Cisco Internetwork Operating System"></a>Cisco IOS, Cisco Internetwork Operating System</h1><p>Cisco IOS 是思科网络设备商使用的通用网络系统，大多数思科设备，无论其大小和种类如何，大都是使用 Cisco IOS</p>
<p>本章节就来主要学习一下 Cisco IOS 的配置和使用</p>
<h2 id="Cisco-IOS-操作模式"><a href="#Cisco-IOS-操作模式" class="headerlink" title="Cisco IOS 操作模式"></a>Cisco IOS 操作模式</h2><p>Cisco IOS 采用一种分层操作的模式结构，在每一层种可以执行特定的命令和配置。对于每种命令要在各自的层中执行。</p>
<p>总的来说 Cisco IOS 的层次结构为：</p>
<ul>
<li>用户 EXEC 模式（User EXEC Mode）：在该模式下只能执行基本的监控指令，不能执行任何改变设备配置的命令，用户 EXEC 模式采用<code>&gt;</code>结尾的 CLI 提示符。View-Only mode</li>
<li>特权 EXEC 模式（Privileged EXEC Mode 也成为 enable mode）：在该模式下可以访问所有的命令和功能，可以执行所有的监控命令和配置管理命令。。特权 EXEC 模式由采用 <code>#</code> 符号结尾的 CLI 提示符。注意：<strong>进行用户配置时还需要进入对应的配置模式</strong><ul>
<li>全局配置模式：对 CLI 配置所做的更改将影响整个设备的运行。全局配置模式由在设备名称之后加 <code>(config)#</code> 结尾的提示符标识，比如 <code>Switch(config)#</code>。<strong>访问全局配置模式之后才能访问其他具体的配置模式</strong>。其中的每种模式可以用于配置 IOS 设备的特定部分或特定功能。两个常见的子配置模式包括：<ul>
<li>线路配置模式 - 用于配置控制台、SSH、Telnet 或 AUX 访问。默认提示符为 <code>Switch(config-line)#</code></li>
<li>接口配置模式 - 用于配置交换机端口或路由器网络接口。默认提示符为 <code>Switch(config-if)#</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="各个模式切换的具体命令"><a href="#各个模式切换的具体命令" class="headerlink" title="各个模式切换的具体命令"></a>各个模式切换的具体命令</h3><ul>
<li>用户 EXEC 模式 -&gt; 特权 EXEC 模式：<code>enable</code></li>
<li>特权 EXEC 模式 -&gt; 用户 EXEC 模式：<code>disable</code></li>
<li>特权 EXEC 模式 -&gt; 全局配置：<code>configure terminal</code></li>
</ul>
<p>其他子配置模式</p>
<ul>
<li>要进入线路子配置模式，使用 <code>line</code> 命令后跟您要访问的管理线路类型和编号来实现。要退出子配置模式并返回全局配置模式，使用 exit 命令。<ul>
<li><code>line console 0</code>用来管理控制台线路对设备的访问</li>
<li><code>line vty 0 15</code>用来管理虚拟终端 (VTY) 线路支持对设备的远程访问，许多思科交换机支持第 0 到 15 的 16 条 VTY 线路。主要用来管理 SSH 和 Telnet 产生的设备访问</li>
</ul>
</li>
<li>进入接口配置模式，使用 <code>interface</code> 命令后跟您要访问的接口名称和编号来实现。要退出子配置模式并返回全局配置模式，使用 exit 命令。<ul>
<li><code>interface FastEthernet 0/1</code></li>
<li><code>interface vlan 1</code> 配置交换机虚拟接口（SVI）</li>
</ul>
</li>
</ul>
<h2 id="Cisco-IOS-帮助功能"><a href="#Cisco-IOS-帮助功能" class="headerlink" title="Cisco IOS 帮助功能"></a>Cisco IOS 帮助功能</h2><p>IOS 提供两种形式的帮助：</p>
<ul>
<li>上下文相关帮助，Context-Sensitive Help</li>
<li>命令检查帮助，Command Syntax Check</li>
</ul>
<p>上下文相关帮助可使您快速找到每个命令模式中哪些命令可用，哪些命令以特定字符或字符组开头，以及哪些参数和关键字可用于特定命令。要访问上下文相关帮助，请直接在 CLI 中输入一个问号 ?。</p>
<p>命令语法检查用于验证用户输入的命令是否有效。输入命令后，命令行解释程序将从左向右评估命令。如果解释程序可以理解该命令，则用户要求执行的操作将被执行，且 CLI 将返回到相应的提示符。然而，如果解释程序无法理解用户输入的命令，它将提供反馈，说明该命令存在的问题。</p>
<h2 id="Cisco-IOS-设备基本配置"><a href="#Cisco-IOS-设备基本配置" class="headerlink" title="Cisco IOS 设备基本配置"></a>Cisco IOS 设备基本配置</h2><h3 id="设备名称"><a href="#设备名称" class="headerlink" title="设备名称"></a>设备名称</h3><p>主机名选择要求</p>
<ul>
<li>以字母开头</li>
<li>不包含空格</li>
<li>以字母或数字结尾</li>
<li>仅使用字母、数字和破折号</li>
<li>长度少于 64 个字符</li>
</ul>
<p>配置主机名：<code>hostname</code> <em>hostname</em><br>取消主机名：<code>no hostname</code></p>
<h3 id="设备访问限制"><a href="#设备访问限制" class="headerlink" title="设备访问限制"></a>设备访问限制</h3><p>用户密码分为两种，分别对应两种 EXEC 模式</p>
<ul>
<li>配置特权 EXEC 模式的访问密码，只需要在全局配置下使用 <code>enable secret</code> <em>password</em> 命令。</li>
<li>配置用户 EXEC 模式访问，要对访问的模式来分别来设置，对于采用控制台还是虚拟终端（VTY）要进入相应的线路子配置模式中配置<ul>
<li>进入相应的配置子模式后，使用 <code>password</code> <em>password</em> 命令指定密码。最后，使用 login 命令启用访问。</li>
</ul>
</li>
</ul>
<p>对于以上配置，默认的情况下，所配置的密码会在启动配置文件和运行配置文件中以明文显示，而想要加密密码，在全局配置模式下使用<code>service password-encryption</code></p>
<h3 id="标语信息"><a href="#标语信息" class="headerlink" title="标语信息"></a>标语信息</h3><p>尽管要求用户输入密码是防止未经授权的人员进入网络的有效方法，但同时必须向试图访问设备的人员声明仅授权人员才可访问设备。出于此目的，可向设备输出中加入一条标语。当控告某人侵入设备时，<strong>标语可在诉讼程序中起到重要作用</strong>。某些法律体系规定，若不事先通知用户，则既不允许起诉该用户，甚至连对该用户进行监控都不允许。</p>
<p>要在网络设备上创建当日消息标语，请使用 <code>banner motd</code> <em>the message of the day</em> 全局配置命令。命令执行完毕后，系统将向之后访问设备的所有用户显示该标语，直到该标语被删除为止。</p>
<p>因为任何试图登录的人员均可看到标语，因此标语消息应该谨慎措辞。标语的确切内容或措辞取决于当地法律和企业政策。标语应指明仅允许授权人员访问设备。<strong>任何暗含“欢迎登录”或“邀请登录”意味的词语都不合适</strong>。此外，标语可以涉及影响所有网络用户的信息，例如系统关机安排和其他信息。</p>
<h3 id="保存配置"><a href="#保存配置" class="headerlink" title="保存配置"></a>保存配置</h3><p>有两种系统文件用于存储设备配置：</p>
<ul>
<li>启动配置（startup-config） - 该文件存储在非易失性随机访问存储器 （Non-volatile Random Access Memory，NVRAM） 中，包含设备在启动或重启时将会使用的所有命令。设备断电后，NVRAM 中的内容不会丢失。</li>
<li>运行配置（running-config） - 该文件存储在随机访问存储器 (RAM) 中，反映当前配置。修改运行配置会立即影响思科设备的运行。RAM 是易失性存储器。如果设备断电或重新启动，则它会丢失所有内容。</li>
</ul>
<p>在特权 EXEC 模式下，使用<code>show running-config</code>命令可以查看运行配置文件，相应的使用<code>show startup-config</code>查看启动配置文件</p>
<p>如果设备断电或重新启动，所有未保存的配置更改都会丢失。要将对运行配置所作的更改保存到启动配置文件中，使用 <code>copy running-config startup-config</code> 特权 EXEC 模式命令。</p>
<p>使用 <code>erase startup-config</code> 特权 EXEC 模式命令可删除启动配置</p>
<h1 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h1><blockquote>
<p>此部分暂时先不详细表述，在第 7 章中会更详细的解释 ipv4 和 ipv6</p>
</blockquote>
<p>互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址），缩写为 IP 地址（英语：IP Address），是分配给网络上使用网际协议（英语：Internet Protocol, IP）的设备的数字标签。常见的 IP 地址分为 IPv4 与 IPv6 两大类。</p>
<p>IPv4 地址的结构称为点分十进制四组表示法，用 0 到 255 之间的四个十进制数字表示。IPv4 地址会分配给连接到网络的各个设备。</p>
<h2 id="子网掩码（subnet-mask）"><a href="#子网掩码（subnet-mask）" class="headerlink" title="子网掩码（subnet mask）"></a>子网掩码（subnet mask）</h2><p>子网掩码（subnet mask），它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的网络地址以及哪些位标识的是主机地址的位掩码。</p>
<p>通常情况下，子网掩码的表示方法和地址本身的表示方法是一样的。在 IPv4 中，就是点分十进制四组表示法（四个取值从 0 到 255 的数字由点隔开，比如 255.128.0.0）或表示为一个八位十六进制数（如 FF.80.00.00，它等同于 255.128.0.0），后者用得较少。</p>
<p>另一种更为简短的形式叫做无类别域间路由（CIDR）表示法，<strong>它给出的是一个地址加上一个斜杠以及网络掩码的二进制表示法中“1”的位数（即网络号中和网络掩码相关的是哪些位）</strong>。例如，192.0.2.96/28 表示的是一个前 28 位被用作网络号的 IP 地址（和 255.255.255.240 的意思一样）。</p>
<p>子网掩码的好处就是：不管网络有没有划分子网，只要把子网掩码和 IP 地址进行逐位的“与”运算（AND）即得出网络地址来。这样在路由器处理到来的分组时就可以采用同样的方法。</p>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ul>
<li><strong>Cisco IOS</strong> - term that represents the operating systems used by Cisco networking devices</li>
<li><strong>shell</strong> - portion of operating system that interacts with applications and the user</li>
<li><strong>kernel</strong> - portion of operating system that interfaces directly with computer hardware</li>
<li><strong>GUI</strong> - a user-friendly interface that provides an interaction between a user and an OS through a graphical environment</li>
<li><strong>console</strong> - a physical port of a Cisco device that provides access to the device via a dedicated management channel, also known as out-of-band access</li>
<li><strong>keyword</strong> - parameter with a predefined value to be used by an IOS command</li>
<li><strong>argument</strong> - parameter that has to be supplied by the user to an IOS command</li>
<li><strong>startup configuration</strong> - file that is stored in NVRAM and that contains the configuration that has been saved on a device to be used upon startup or reboot</li>
<li><strong>running configuration</strong> - file that is stored in RAM and that contains the configuration that is being done on a device</li>
<li><strong>SVI</strong> - a logical interface used to remotely manage a switch over an IPv4 network</li>
<li><strong>SSH</strong> - a protocol to establish a remote secure CLI connection over the network</li>
<li><strong>ping</strong> - command to verify connectivity between the source (the device where the command is issued) and the destination (IP address used as argument)</li>
<li><strong>traceroute</strong> - command to check the path that a packet takes to reach a destination</li>
<li><strong>ipconfig</strong> - Windows command that shows the IP configuration settings on a PC</li>
<li><strong>DHCP</strong> - a protocol that dynamically leases IPv4 addresses to DHCP-enabled end devices</li>
</ul>
]]></content>
      <categories>
        <category>ESAIP</category>
        <category>CCNA</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA Chapter 1: Explore the Network</title>
    <url>/2017/12/11/CCNA-Chapter-1-Explore-the-Network/</url>
    <content><![CDATA[<h1 id="基础网络概念"><a href="#基础网络概念" class="headerlink" title="基础网络概念"></a>基础网络概念</h1><p>在计算机网络中，设备之间通过数据链路交换数据，节点之间的链接由网线或者无线来建立。简单的说计算机网络连接两台或多台计算机进行通信的系统。</p>
<p>计算机网络可以按照覆盖范围分类也可按照不同节点之间的功能关系（网络架构）分类。</p>
<p>计算机网络可以看作成一个拓扑结构，分为星型、环形等等</p>
<p>相关的概念内容还有，网络性能，其中包括：服务质量（QoS），网络阻塞，网络恢复能力；组成硬件，传输媒介，网络协议等等。</p>
<p>本章只介绍网络分类和网络的基础部分，硬件和传输媒介在后几章中会提到</p>
<a id="more"></a>
<h1 id="网络组件（Network-Components）"><a href="#网络组件（Network-Components）" class="headerlink" title="网络组件（Network Components）"></a>网络组件（Network Components）</h1><p>网络基础设施包含三类网络组件：设备，介质和服务。</p>
<ul>
<li>终端设备（End Devices）</li>
<li>中间网络设备（Intermediary Network Devices）<ul>
<li>重新生成和重新传输数据信号</li>
<li>维护有关网络和网际网络中存在哪些通道的信息。</li>
<li>将错误和通信故障通知其它设备</li>
<li>发生链路故障时按照备用路径转发数据</li>
<li>根据优先级别分类和转发消息</li>
<li>根据安全设置允许或拒绝数据的通行</li>
</ul>
</li>
<li>网络介质（Network Media）<ul>
<li>介质可成功传送信号的最大距离是多少？</li>
<li>介质将安装在什么类型的环境中？</li>
<li>必须传输的数据量和传输速度是多少？</li>
<li>介质和安装的成本是什么？</li>
</ul>
</li>
</ul>
<h1 id="计算机网络类型"><a href="#计算机网络类型" class="headerlink" title="计算机网络类型"></a>计算机网络类型</h1><h2 id="从网络架构分类"><a href="#从网络架构分类" class="headerlink" title="从网络架构分类"></a>从网络架构分类</h2><h3 id="客户端-服务器（Client-Server）"><a href="#客户端-服务器（Client-Server）" class="headerlink" title="客户端-服务器（Client/Server）"></a>客户端-服务器（Client/Server）</h3><p>所有连接到网络并直接参与网络通信的计算机都属于主机 (hosts)。主机也称为终端设备 (end devices)。</p>
<p>客户端-服务器（Client/Server）又称为主从式架构、C/S 架构，它把客户端 (Client) 与服务器 (Server) 区分开来。每一个客户端软件的实例都可以向一个服务器或应用程序服务器发出请求。</p>
<p>服务器是装有特殊软件，可以为网络上其他终端设备提供信息（例如电子邮件或网页）的计算机。<strong>每项服务都需要单独的服务器软件</strong></p>
<p>客户端是安装了特殊软件，可向服务器请求信息以及显示所获取信息的计算机</p>
<h3 id="浏览器-服务器（Browser-Server）结构"><a href="#浏览器-服务器（Browser-Server）结构" class="headerlink" title="浏览器-服务器（Browser/Server）结构"></a>浏览器-服务器（Browser/Server）结构</h3><p>浏览器-服务器（Browser/Server）结构，简称 B/S 结构，与 C/S 结构不同，其客户端不需要安装专门的软件，只需要浏览器即可，浏览器通过 Web 服务器与数据库进行交互，可以方便的在不同平台下工作；服务器端可采用高性能计算机，并安装 Oracle、Sybase、Informix 等大型数据库。B/S 结构简化了客户端的工作，它是随着 Internet 技术兴起而产生的，对 C/S 技术的改进，但该结构下服务器端的工作较重，对服务器的性能要求更高。</p>
<h3 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h3><p>对等式网络（peer-to-peer， 简称 P2P），又称点对点技术，是无中心服务器、依靠用户群（peers）交换信息的互联网体系，它的作用在于，减低以往网络传输中的节点，以降低数据丢失的风险。与有中心服务器的中央网络系统不同，对等网络的每个用户端既是一个节点，也有服务器的功能，任何一个节点无法直接找到其他节点，必须依靠其户群进行信息交流。</p>
<p>常用的 p2p 服务有，BitTorrent、磁力链、Gnutella、eMule</p>
<h4 id="P2P-网络的优缺点"><a href="#P2P-网络的优缺点" class="headerlink" title="P2P 网络的优缺点"></a>P2P 网络的优缺点</h4><p>优点</p>
<ul>
<li>易于安装，Easy to set up</li>
<li>复杂性较低，Less complexity</li>
<li>成本更低，因为不需要专用网络和专用服务器，Lower cost since network devices and dedicated servers may not be required</li>
<li>可用于简单的任务，例如传输文件和共享打印机，Can be used for simple tasks such as transferring files and sharing printers</li>
</ul>
<p>缺点</p>
<ul>
<li>无法集中管理， No centralized administration</li>
<li>安全性较差，Not as secure</li>
<li>不可扩展，Not scalable</li>
<li>所有设备皆可作为服务器和客户端，这会降低性能，All devices may act as both clients and servers which can slow their performance</li>
</ul>
<h2 id="从网络覆盖范围分类"><a href="#从网络覆盖范围分类" class="headerlink" title="从网络覆盖范围分类"></a>从网络覆盖范围分类</h2><h3 id="Internet-互联网"><a href="#Internet-互联网" class="headerlink" title="Internet, 互联网"></a>Internet, 互联网</h3><p>互联网是网络 (network) 与网络之前串成的巨大网络，这些网络以一组标准的网络 TCP/IP 协议族相连，形成逻辑上的单一巨大国际网络。</p>
<p>互联网不等同于万维网，万维网只是互联网所提供的服务之一</p>
<p>互联网属于计算机网络 (computer network) 的一种</p>
<p>互联网带有范围广泛的信息资源和服务，例如相互关系的超文本文件，万维网的应用，电子邮件的基础设施，点对点网络 (p2p, peer-to-peer)，文件共享，以及 IP 电话服务。</p>
<h3 id="WAN-广域网"><a href="#WAN-广域网" class="headerlink" title="WAN, 广域网"></a>WAN, 广域网</h3><p>广域网（Wide Area Network，WAN），又称广域网、外网、公网。是连接不同地区局域网或城域网计算机通信的远程网。通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个地区、城市和国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。广域网并不等同于互联网。</p>
<p>WAN 通常由服务提供商 (SP) 或 Internet 服务提供商 (ISP) 管理。</p>
<p>WAN 的具体功能包括：</p>
<ul>
<li>WAN 互连广泛地理区域（例如各大城市、州、省、国家/地区或大陆之间）内的 LAN。</li>
<li>WAN 通常由多个服务提供商管理。</li>
<li>WAN 通常提供 LAN 之间的较慢链路。</li>
</ul>
<h3 id="SAN-存储区域网络"><a href="#SAN-存储区域网络" class="headerlink" title="SAN, 存储区域网络"></a>SAN, 存储区域网络</h3><p>存储区域网络（Storage Area Network，SAN）是一种连接外接存储设备和服务器的架构。人们采用包括光纤通道技术、磁盘阵列、磁带柜、光盘柜的各种技术进行实现。该架构的特点是，连接到服务器的存储设备，将被操作系统视为直接连接的存储设备。除针对大型企业的企业级存储方案外，随着在 2000 年后价格和复杂度的降低，越来越多的中小型企业也在逐步采用该项技术。</p>
<h3 id="MAN-都会网域"><a href="#MAN-都会网域" class="headerlink" title="MAN, 都会网域"></a>MAN, 都会网域</h3><p>都会网域（Metropolitan Area Network，MAN）指大型的计算机网络，属于 IEEE802.6 标准，是介于 LAN 和 WAN 之间能传输语音与数据的公用网络。MAN 是改进 LAN（局域网）中的传输媒介，扩大局域网的范围，达到包含一个大学校园、城市或都会区。它是较大型的局域网，需要的成本较高，但可以提供更快的传输速率。</p>
<h3 id="LAN-局域网"><a href="#LAN-局域网" class="headerlink" title="LAN, 局域网"></a>LAN, 局域网</h3><p>局域网（Local Area Network, LAN），又称内网。指覆盖局部区域（如办公室或楼层）的计算机网络。早期的局域网网络技术都是各不同厂家所专有，互不兼容。后来，电机电子工程师学会推动了局域网技术的标准化，由此产生了 IEEE 802 系列标准。这一系列标准覆盖了双绞线、同轴电缆、光纤和无线等多种传输媒介和组网方式，并包括网络测试和管理的内容。</p>
<p>在历经使用了链式局域网， 令牌环，与 AppleTalk 技术后，以太网和 Wi-Fi(无线网络连接) 是现今局域网中最常用的两项技术。</p>
<p>以太网（IEEE 802.3 标准）是最常用的局域网组网方式。以太网使用双绞线作为传输媒介。在没有中继的情况下，最远可以覆盖 200 米的范围。最普及的以太网类型数据传输速率为 100Mb/s，更新的标准则支持 1000Mb/s 和 10000Mb/s 的速率。</p>
<h3 id="WLAN-无线局域网"><a href="#WLAN-无线局域网" class="headerlink" title="WLAN, 无线局域网"></a>WLAN, 无线局域网</h3><p>无线局域网（Wireless LAN，WLAN）是不使用任何导线或传输电缆连接的局域网，而使用无线电波作为数据传送的媒介，传送距离一般只有几十米。蓝牙、wifi 都是常用的无线局域网技术</p>
<p>无线局域网最通用的标准是 IEEE 定义的 802.11 系列标准。</p>
<h3 id="Intranets-and-Extranets-内部网和外部网"><a href="#Intranets-and-Extranets-内部网和外部网" class="headerlink" title="Intranets and Extranets, 内部网和外部网"></a>Intranets and Extranets, 内部网和外部网</h3><p>内部网（Intranet）通常用于表示一个组织的私有局域网和广域网连接，只有该组织的成员、员工或其他获得授权的人员可以访问。</p>
<p>外部网（Extranet）是一个使用与互联网同样技术的计算机网络，它通常属于一个企业或组织的内部网（Intranet）或建立在互联网中并为指定的用户提供信息的共享和交流等服务。</p>
<p>组织可以使用外联网为在其他组织工作，但需要本组织数据的人提供安全访问。外联网示例包括：</p>
<ul>
<li>公司为外部供应商和承包商提供访问。</li>
<li>医院为医生提供预约系统，以便医生为患者安排预约。</li>
<li>当地教育局为其管辖区的学校提供预算和人员信息。</li>
</ul>
<h1 id="Internet-连接"><a href="#Internet-连接" class="headerlink" title="Internet 连接"></a>Internet 连接</h1><h2 id="家庭和小型办公室-Internet-连接"><a href="#家庭和小型办公室-Internet-连接" class="headerlink" title="家庭和小型办公室 Internet 连接"></a>家庭和小型办公室 Internet 连接</h2><ul>
<li>同轴电缆（Cable） - 通常由有线电视服务提供商提供，Internet <strong>数据信号在输送有线电视信号的同一电缆上进行传输</strong>。它能提供高带宽、始终联网和 Internet 连接。</li>
<li>DSL - 数字用户线路提供高带宽、始终联网和 Internet 连接。DSL 通过电话线路运行。<strong>通常小型办公室和家庭办公室用户会选择使用非对称 DSL (ADSL)，这种方式的特点是下载速度高于上传速度</strong>。</li>
<li>移动电话（Cellular） - 手机 Internet 访问使用手机网络连接。只要您能收到手机信号，就能获得手机 Internet 访问。性能可能会受手机功能和手机信号塔的限制。</li>
<li>卫星（Satellite） - 对于根本没有 Internet 连接的地方来说，获得卫星 Internet 访问非常有用。卫星天线要求到卫星的视线要清晰。</li>
<li>拨号电话（Dial-up Telephone） - 使用电话线和调制解调器，费用相对较低。拨号调制解调器连接提供的低带宽通常不足用于大型数据传输，但对旅行过程中的移动访问非常有用。</li>
</ul>
<p>许多家庭和小型办公室更常使用光纤电缆（fiber optic cables）直接连接。这样，ISP 可以提供更高带宽速度并支持更多服务，例如 Internet、电话、电视。</p>
<h2 id="企业-Internet-连接"><a href="#企业-Internet-连接" class="headerlink" title="企业 Internet 连接"></a>企业 Internet 连接</h2><p>企业连接选项与家庭用户选项有所不同。企业可能需要更高带宽、专用带宽和托管服务。可用连接选项取决于附近的服务提供商类型。</p>
<ul>
<li>专用租用线路（Dedicated Leased Line） - 租用线路实际上是服务提供商网络内连接地理位置分散的办公室的保留电路，提供个人语音和/或数据网络。电路通常按月或按年租用。可能会非常昂贵。</li>
<li>以太网 WAN（Ethernet WAN） - 以太网 WAN 将 LAN 访问技术扩展到 WAN 中。以太网是一种 LAN 技术，您将在后面的章节中学习。现在以太网的优势将可以扩展到 WAN 中。</li>
<li>DSL - 企业 DSL 提供各种格式。一种常见的选择是<strong>对称数字用户线路 (SDSL)</strong>，它类似于 DSL 的普通用户版本，<strong>但是提供相同的上传和下载速度</strong>。</li>
<li>卫星（Satellite ） - 与小型办公室和家庭办公室用户类似，当有线解决方案不可用时，卫星服务可以提供连接。</li>
</ul>
<h1 id="可靠网络的构架"><a href="#可靠网络的构架" class="headerlink" title="可靠网络的构架"></a>可靠网络的构架</h1><p>要构建一个可靠的网络，必须在底层架构上解决以下四个特征：</p>
<ul>
<li>容错能力，Fault Tolerance<ul>
<li>有多条路径到达目的地，在链路发生故障的时候可以快速恢复。称为<strong>冗余（redundancy）</strong></li>
<li>提供冗余的一种方法是实施<strong>分组交换网络（packet-switched network）</strong>，流量分割成通过共享网络发送的数据包，具体内容之后章节内提到</li>
</ul>
</li>
<li>可扩展性，Scalability<ul>
<li>能够快速扩张来支持新增用户和应用程序，同时还保证不影响现有用户</li>
<li>使网络具有可扩展性的一种方法是购买模块化的网络设备。</li>
<li>网络具有可扩展性的原因是设计人员可以遵循广为接受的标准和协议</li>
</ul>
</li>
<li>服务质量，Quality of Service (QoS)<ul>
<li>当带宽需求超过可用量时，就会造成拥塞。在尝试通过网络实现并发通信时，<strong>网络带宽需求可能超过可用范围，从而造成网络拥塞（congestion）</strong>。</li>
<li>QoS 成为了用于管理拥塞和确保向所有用户可靠传输内容的主要机制。</li>
<li>在出现阻塞时，网页内容通常会安排较低的优先级，优先处理流媒体来保障用户体验流畅。</li>
</ul>
</li>
<li>安全，Security<ul>
<li>网络基础设施的安全性<ul>
<li>保护提供网络连接的设备的安全</li>
<li>防止有人未经授权访问网络上的管理软件</li>
</ul>
</li>
<li>信息的安全性<ul>
<li>机密性（Confidentiality） - 数据机密性意味着只有预定和授权收件人可以访问并读取数据。</li>
<li>完整性（Integrity） - 数据完整性表示保证信息在从源地址到目的地址的传输过程中不会被更改。</li>
<li>可用性（Availability） - 数据可用性表示保证授权用户及时可靠地访问数据服务。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="网络新趋势"><a href="#网络新趋势" class="headerlink" title="网络新趋势"></a>网络新趋势</h1><h2 id="自带设备（Bring-Your-Own-Device，-BYOD）"><a href="#自带设备（Bring-Your-Own-Device，-BYOD）" class="headerlink" title="自带设备（Bring Your Own Device， BYOD）"></a>自带设备（Bring Your Own Device， BYOD）</h2><p>BYOD 意味着设备由任何使用者在任意地点使用</p>
<h2 id="云计算（Cloud-Computing）"><a href="#云计算（Cloud-Computing）" class="headerlink" title="云计算（Cloud Computing）"></a>云计算（Cloud Computing）</h2><p>云类型主要有四种：公共云、私有云、混合云和定制云。Public Clouds, Private Clouds, Hybrid Clouds, and Custom Clouds.</p>
<h2 id="电力线网络（Powerline-Networking）"><a href="#电力线网络（Powerline-Networking）" class="headerlink" title="电力线网络（Powerline Networking）"></a>电力线网络（Powerline Networking）</h2><p>电力线网络是家庭网络的一种新兴趋势，它使用现有的电线连接设备。“无需新电线”的概念是指只要有电源插座就能连接网络。这样可以节省安装数据线的成本，而且不会增加电费成本。通过<strong>使用供电的同一配线</strong>(A device connects to an existing home LAN using an adapter and an existing electrical outlet.)，电力线网络通过按一定频率发送数据来发送信息。</p>
<h2 id="无线宽带（Wireless-Broadband）"><a href="#无线宽带（Wireless-Broadband）" class="headerlink" title="无线宽带（Wireless Broadband）"></a>无线宽带（Wireless Broadband）</h2><p>无线 Internet 服务提供商 （Wireless Internet Service Provider，WISP）。无线 Internet 服务提供商 (WISP) 是使用类似家庭无线局域网 (WLAN) 的无线技术，将用户连接到专用的接入点或热点的 ISP。WISP 更多用于 DSL 或电缆服务不太可行的农村环境。</p>
<h1 id="网络安全威胁"><a href="#网络安全威胁" class="headerlink" title="网络安全威胁"></a>网络安全威胁</h1><h2 id="网络最常见的外部威胁"><a href="#网络最常见的外部威胁" class="headerlink" title="网络最常见的外部威胁"></a>网络最常见的外部威胁</h2><ul>
<li>病毒、蠕虫和特洛伊木马（Viruses, worms, and Trojan horses）- 在用户设备上运行的恶意软件和任意代码</li>
<li>间谍软件和广告软件（Spyware and adware） - 用户设备上安装的软件，秘密收集关于用户的信息</li>
<li>零日攻击（也称零小时攻击）（Zero-day attacks, also called zero-hour attacks） - 在出现漏洞的第一天发起的攻击</li>
<li>黑客攻击 （Hacker attacks）- 由经验丰富的人员对用户设备或网络资源发起的攻击</li>
<li>拒绝服务攻击 （Denial of service attacks）- 意图使网络设备上的应用和进程减缓或崩溃的攻击</li>
<li>数据拦截和盗窃 （Data interception and theft） - 通过公司网络捕获私人信息的攻击</li>
<li>身份盗窃 （Identity theft ） - 窃取用户的登录凭据来访问私人数据的攻击</li>
</ul>
<p>其中，<strong>身份盗窃是对个人用户造成最大破坏的网络威胁</strong></p>
<p>大多数常见的数据泄密事件归因于网络的<strong>内部用户</strong>。Typical internal security threats include weak or exposed passwords, lost or stolen devices, and malicious employees.</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>家庭或小型办公室的网络安全组件应至少包括：</p>
<ul>
<li>防病毒和反间谍软件 – 这些软件用于防止终端设备感染恶意软件。</li>
<li>防火墙过滤 – 用于阻止未经授权访问网络。这可以是基于主机的防火墙系统，用于阻止未经授权访问终端设备，也可以是家用路由器上的基本过滤服务，用于阻止外部人员未经授权访问网络。</li>
</ul>
<p>除上述内容外，大型网络和企业网络通常具有其他安全要求：</p>
<ul>
<li>专用防火墙系统 – 用于提供更高级的防火墙功能，更详细地过滤大量数据流。</li>
<li>访问控制列表 (ACL) – 用于进一步过滤访问和流量转发。</li>
<li>入侵防御系统 (IPS) – 用于识别快速扩散的威胁，例如零日攻击或零小时攻击。</li>
<li>虚拟专用网络 (VPN) – 用于为远程员工提供安全访问。</li>
</ul>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ul>
<li><strong>collaboration tools</strong> - tools that allow individuals to work together as a team on a project, no matter where they are located</li>
<li><strong>cellular</strong> - technology in which a user can get access to the Internet when connecting a cell phone to a cell phone network</li>
<li><strong>SAN</strong> - type of network infrastructure that stores, retrieves, and replicates data</li>
<li><strong>fault</strong> tolerance - a network characteristic that restricts the impact of a failure on network access and allows a network to recover quickly from the failure</li>
<li><strong>QoS</strong> - a mechanism to manage the flow of traffic based on different requirements to ensure reliable delivery of each type of traffic</li>
<li><strong>BYOD</strong> - makes it possible for users to be free to use their personal devices to access a corporate or a campus network</li>
<li><strong>cloud computing</strong> - technology that allows users and organizations to store data on remotely located servers on the Internet</li>
<li><strong>data center</strong> - a facility used to store information originating from users or organizations</li>
<li><strong>Powerline Networking</strong> - the connection of devices to the Internet through the use of existing electrical wiring</li>
<li><strong>converged network</strong> - a network with the capability of delivering traffic with different requirements but with the use of the same network infrastructure</li>
<li><strong>DSL</strong> - technology that provides the user with a high-bandwidth connection to the Internet over a telephone line</li>
<li><strong>peer-to-peer network</strong> - a type of network in which computers can perform the role of a server and a client at the same time</li>
<li><strong>intranet</strong> - a private interconnection of LANs and WANs inside an organization that can only be accessed by organization members or by non-members with authorization</li>
<li><strong>extrant</strong> - a network that provides safe and secure access to an organization’s data to authorized people who work outside that organization</li>
</ul>
]]></content>
      <categories>
        <category>ESAIP</category>
        <category>CCNA</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>UML 组件图</title>
    <url>/2017/11/23/UML-%E7%BB%84%E4%BB%B6%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="UML-Component-Diagrams"><a href="#UML-Component-Diagrams" class="headerlink" title="UML Component Diagrams"></a>UML Component Diagrams</h1><p>组件图 (Component Diagrams) 显示组件，提供的和必需的接口，端口以及它们之间的关系。这种类型的图用于基于组件的开发（CBD）来描述具有面向服务的体系结构（SOA）的系统。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>组件 (Component) 是一个类用来表述具有封装内容的系统的一个模块化的部分。组件根据提供的接口和所需的接口来定义其行为。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flseyrogznj303w0200q3.jpg" alt=""></p>
<p>提供的接口 (Provided interface)，要么是由本身实现，要么是由一个分类器实现、要么是由组件的公共端口 (port) 实现<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsf06linej305a01y3y9.jpg" alt=""><br>请求的接口 (Required interface)，要么是由组件本身的使用依赖指定，由用于实现组件的分类器之一的使用依赖性指定，是组件的公共端口所必需的。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsf06mcnwj305a0250rz.jpg" alt=""></p>
<p>端口 (port) 是一个封装构件的显示的对外窗口，所有进出构件的交互都要通过端口。</p>
<p>组件图用依赖关系 (Component dependency) 表示各组件之间存在的关系类型。在 UML 中，组件图中依赖关系的表示方法与类图中依赖关系相同，都是一个由客户指向提供者的虚线箭头。</p>
<p>组件连接器 (Assembly connector) 表示构件之间的关系，它连接构件内部的类，将一个构件的供接口和一个构件的需接口捆绑在一起</p>
<ul>
<li>Realization</li>
<li>Artifact</li>
</ul>
<a id="more"></a>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsgl04wa8j30go0t53zb.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsgl02x7jj30nm0gfdg7.jpg" alt=""></p>
]]></content>
      <categories>
        <category>ESAIP</category>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>UML 部署图</title>
    <url>/2017/11/23/UML-%E9%83%A8%E7%BD%B2%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="Deployment-Diagrams"><a href="#Deployment-Diagrams" class="headerlink" title="Deployment Diagrams"></a>Deployment Diagrams</h1><p>部署图 (Deployment Diagrams) 描述的是系统运行时的结构，展示了硬件的配置及其软件如何部署到网络结构中。一个系统模型只有一个部署图，部署图通常用来帮助理解分布式系统。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>结点 (Node) 是存在与运行时的代表计算机资源的物理元素，可以是硬件也可以是运行其上的软件系统</p>
<p>物件(Artifact)，表示物理实体，是软件开发过程的产物。这可能包括流程模型（如用例模型，设计模型等），源文件，可执行文件，设计文档，测试报告，原型，用户手册等。</p>
<p>节点实例(Node instance)与结点的区别在于名称有下划线和结点类型前面有冒号，冒号前面可以有示例名称也可以没有示例名称</p>
<p>Manifestation 是一种抽象关系表示一个或多个模型是有一个Artifact渲染（实现）得到的。</p>
<p>An execution environment is a (software) node that offers an execution environment for specific types of components that are deployed on it in the form of executable artifacts. Components of the appropriate type are deployed to specific execution environments.</p>
<p>A device is a node which represents a physical computational resource with processing capability upon which artifacts may be deployed for execution.</p>
<p>通讯路径(Communication path)是两个部署目标之间的链接关系。用来交换信号和消息。</p>
<a id="more"></a>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsglqn0ewj30rc0jsgmk.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsglqjhw7j30lt0cd0sw.jpg" alt=""></p>
]]></content>
      <categories>
        <category>ESAIP</category>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>UML 活动图</title>
    <url>/2017/11/23/UML-%E6%B4%BB%E5%8A%A8%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="Activity-Diagrams"><a href="#Activity-Diagrams" class="headerlink" title="Activity Diagrams"></a>Activity Diagrams</h1><p>活动图描述了为了完成一个目标需要做的行动以及这些行动的执行顺序。</p>
<h2 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h2><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsdt9z97wj30bu0ibq3s.jpg" alt=""></p>
<p>活动 (Activity) 是一个行为，被分解成一个或多个行动 (action)，一项行动代表一项活动的一个单一步骤</p>
<p>为了指定活动的流程，可以用一个活动边 (edges) 来将行动连接在一起。边指定了数据是如何从一个行动走向下一个的。</p>
<p>初始结点 (initial node) 是活动的开始。</p>
<p>决策节点 (decision node) 是控制节点，用来表明输入指向哪里，由布尔表达式控制。</p>
<p>合并节点 (merge node) 是决策节点的对立，将交替的流量汇集到一个输出流中。</p>
<p>分叉节点 (fork node) 将当前通过一个行动的流分成多个并发流。</p>
<p>连接节点 (join node) 是分叉节点的对立，同步。</p>
<h2 id="Activity-partitions"><a href="#Activity-partitions" class="headerlink" title="Activity partitions"></a>Activity partitions</h2><p>泳道 (Swim Lane) 一个垂直通道，永远安排某个特定 Acotr 的所有活动。</p>
<p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsds54rwbj30ge0ac754.jpg" alt=""></p>
<a id="more"></a>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsgmxy5x5j30js0q7wf3.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsgmxypxsj30k40sdt9c.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsgmy2busj30hu0pm3z2.jpg" alt=""></p>
]]></content>
      <categories>
        <category>ESAIP</category>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>UML 状态图</title>
    <url>/2017/11/23/UML-%E7%8A%B6%E6%80%81%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="State-Machine-Diagrams"><a href="#State-Machine-Diagrams" class="headerlink" title="State Machine Diagrams"></a>State Machine Diagrams</h1><p>状态图显示一个状态机，状态机用于对模型元素的动态行为进行建模，具体地说是对系统行为中受事件驱动的方面进行建模。通常使用状态图来说明业务角色或业务实体可能的状态。</p>
<h2 id="状态-States"><a href="#状态-States" class="headerlink" title="状态 (States)"></a>状态 (States)</h2><p>状态有以下几种：</p>
<ul>
<li>simple state</li>
<li>composite state</li>
<li>submachine state</li>
</ul>
<h3 id="Simple-State"><a href="#Simple-State" class="headerlink" title="Simple State"></a>Simple State</h3><p>一个简单状态不需要子状态。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsd1mc5frj303m021dfl.jpg" alt=""></p>
<p>活动标签</p>
<ul>
<li>entry (behavior performed upon entry to the state)</li>
<li>do (ongoing behavior, performed as long as the element is in the state)</li>
<li>exit (behavior performed upon exit from the state)</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsd4lxnjyj3046030jr6.jpg" alt=""></p>
<h3 id="Composite-State"><a href="#Composite-State" class="headerlink" title="Composite State"></a>Composite State</h3><p>表示拥有子状态<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsd6st1osj309g03eweb.jpg" alt=""></p>
<h3 id="其他状态"><a href="#其他状态" class="headerlink" title="其他状态"></a>其他状态</h3><p>初始状态 (Initial Pseudostate) 表示为一个实心圆圈<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsd9z9gz7j304g01l0s5.jpg" alt=""></p>
<p>最终状态 (Final State) 表示状态机结束。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsdb0hl1yj303g01f3ya.jpg" alt=""></p>
<a id="more"></a>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsgnuuxykj30hi0e3glu.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsgnur140j30dc0avjra.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsgnv0881j30lj0dc3yz.jpg" alt=""></p>
]]></content>
      <categories>
        <category>ESAIP</category>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>UML 包图</title>
    <url>/2017/11/23/UML-%E5%8C%85%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="UML-Package-Diagrams"><a href="#UML-Package-Diagrams" class="headerlink" title="UML Package Diagrams"></a>UML Package Diagrams</h1><p>包图 (Package Diagram) 是一个 UML 的结构图，表示了系统在包 (package) 层面的设计。提供了将 UML 相关元素进行分组并命名的方法。可视化系统各个部分之间的依赖关系。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h3><p>包是一种命名空间，用于将语义相关的元素组合在一起，并可能一起更改。将元素组织成组，为系统模型提供更好的结构是一个通用的机制。作为一个名称空间，包可以导入其他包的单个成员或其他包的所有成员。软件包也可以与其他软件包合并。</p>
<p>一个包被渲染成一个标签式文件夹 - 一个矩形的顶部左边有一个小标签。如果包裹的成员没有显示在包裹矩形内，那么包裹的名字应该放在里面。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1fls9z0yedpj303m02d0nu.jpg" alt=""><br>包裹的成员可能会显示在包裹的边界内。在这种情况下，包的名称应该放在选项卡上。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1fls9z0z1hyj307i03aa9u.jpg" alt=""></p>
<a id="more"></a>
<p>包裹的成员可以通过从包裹到成员的分支线来显示在包裹的外面。圆内加号（+）在附接到所述命名空间（包）的端部抽出。这个包装的符号在语义上等同于 组合 （使用实心菱形显示）。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1fls9z0y88kj306y054a9w.jpg" alt=""><br>拥有和导入的元素可能具有可见性 ，从而确定它们是否在包外部可用。如果包所拥有的元素具有可见性，则可能只有 公有或私有可见性。受保护的或包的可见性是不允许的。包元素的可见性可以通过在元素的名称之前通过可见性符号来指示（公共的“+”和私有的“ - ”），默认来说可见性是公有的<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1fls9z0yxi7j303w034743.jpg" alt=""></p>
<p>可以打包的元素</p>
<ul>
<li>Type</li>
<li>Classifier (—&gt; Type)</li>
<li>Class (—&gt; Classifier)</li>
<li>Use Case (—&gt; Classifier)</li>
<li>Component (—&gt; Classifier)</li>
<li>Package</li>
<li>Constraint</li>
<li>Dependency</li>
<li>Event</li>
</ul>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsa9yws8jj30aq04wglk.jpg" alt=""></p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsgk692xnj30n60o9gm7.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsgk65nmzj30q40irt91.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsgk694tpj30p00muaaf.jpg" alt=""></p>
]]></content>
      <categories>
        <category>ESAIP</category>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>菜谱-极简微波炉蛋包饭</title>
    <url>/2017/11/22/%E8%8F%9C%E8%B0%B1-%E6%9E%81%E7%AE%80%E5%BE%AE%E6%B3%A2%E7%82%89%E8%9B%8B%E5%8C%85%E9%A5%AD/</url>
    <content><![CDATA[<h1 id="极简微波炉蛋包饭"><a href="#极简微波炉蛋包饭" class="headerlink" title="极简微波炉蛋包饭"></a>极简微波炉蛋包饭</h1><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flrkbw08tqj30p00fmwgm.jpg" alt=""></p>
<blockquote>
<p>本菜谱全部来自于<strong>绵羊料理</strong>。<a href="https://space.bilibili.com/18202105#!/" target="_blank" rel="noopener">点此查看 Up 主空间视频</a><br>本期视频链接：<a href="https://www.bilibili.com/video/av7757659/" target="_blank" rel="noopener">极简微波炉蛋包饭丨绵羊生存料理</a></p>
</blockquote>
<h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><ul>
<li>米饭 200g</li>
<li>火腿 100g</li>
<li>洋葱 1/4个</li>
<li>青椒 半个</li>
<li>番茄酱 1大勺</li>
<li>植物油 1/2大勺</li>
<li>黄油一小块（可选）</li>
<li>蛋包饭蛋皮<ul>
<li>鸡蛋 两个</li>
<li>牛奶 2大勺</li>
<li>糖、盐、黑胡椒</li>
</ul>
</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>青椒去籽、洋葱切去头尾，把青椒、洋葱、火腿切成小丁。</li>
<li>装入容器，加植物油搅拌均匀。</li>
<li>盖上盖子，但是一定不能完全密封，放进微波炉高火3分钟。</li>
<li>取出后加入番茄酱、1/2小勺盐、少许黑胡椒搅拌均匀后，盖起来，高火1分钟。</li>
<li>放入米饭拌匀后，再放进微波炉高火3分钟。</li>
<li>用保鲜膜把米饭包裹，用手捏成椭圆形。</li>
<li>放入饭盒中，将保鲜膜抽掉，摆上一小块黄油。</li>
<li>鸡蛋打散后加牛奶、少许糖和盐拌匀，盖起来，用微波炉高火2分钟。</li>
<li>把做好的鸡蛋盖在米饭上。</li>
<li>可配上用盐水煮熟的西蓝花，挤上番茄酱。</li>
</ol>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2>]]></content>
      <categories>
        <category>菜谱</category>
      </categories>
      <tags>
        <tag>菜谱</tag>
        <tag>绵羊生存料理</tag>
      </tags>
  </entry>
  <entry>
    <title>UML 类图</title>
    <url>/2017/11/22/UML-%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="UML-Class-and-Object-Diagrams"><a href="#UML-Class-and-Object-Diagrams" class="headerlink" title="UML Class and Object Diagrams"></a>UML Class and Object Diagrams</h1><p>类图是现实世界问题领域的抽象对象的结构化、概念化、逻辑化描述。</p>
<h2 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h2><p>UML 中的类大体如下所示，图示分为四个部分</p>
<ul>
<li>顶部为类名</li>
<li>下面一部分用于表述类的属性</li>
<li>第三部分用于表述类的操作方法</li>
<li>底部可选表述外部组件</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqei4dc28j30cz06ejrh.jpg" alt=""><br>类用来表示对象，对象可以是任何有属性和责任的事物</p>
<ul>
<li><code>-</code>指私有 (private) 的成员和方法</li>
<li><code>+</code>指公有 (public) 的成员和方法</li>
<li><code>#</code>指保护 (protected) 的成员和方法</li>
</ul>
<p>对象 (Object) 符号和类符号有相同的部分，唯一的不同是顶部的名称下有下划线</p>
<a id="more"></a>
<h2 id="属性的多重性-Attributes-Multiplicity"><a href="#属性的多重性-Attributes-Multiplicity" class="headerlink" title="属性的多重性 (Attributes Multiplicity)"></a>属性的多重性 (Attributes Multiplicity)</h2><p>一个类属性的多重性指的是当所属的类被实例化时，有多少个实例被创建。假如一个类有四个轮子属性，那么在创建时就会生成四个轮子的实例<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flrixs7zevj309907e0st.jpg" alt=""></p>
<!--
## 关系

### Dependency relationship

两个类之间最弱 (weakest) 的关系是依赖 (Dependency) 关系，类之间的依赖意味着一个类使用了另一个类 ("...uses a...")
![](http://ww1.sinaimg.cn/large/006Ka4GEgy1flrj5w84nsj30d703dq2v.jpg)

不同的依赖关系
![](http://ww1.sinaimg.cn/large/006Ka4GEgy1flrj5web8wj30jg0ef0st.jpg)

如搜索需要使用搜索引擎，类需要引用接口，都是一类依赖关系

### Association relationship

关联 (Association) 关系表示一个类拥有另一个类。由关联关系连接的对象不需要在生命线 (lifeline) 中联系在一起。一个销毁不会影响另一个

可以理解为"...has a...".

Associations are typically read as "...has a...".

### Aggregation and composition

聚合 (Aggregation) 是一种增强版的关联 (Association)，表示所有权，并在生命线中有更紧密的关系。
可以理解为"...owns a..."
![](http://ww1.sinaimg.cn/large/006Ka4GEgy1flrji7j7cuj30da0380so.jpg)

构成()是一种强的二元关系。可以理解为"...is part of..."，当父元素被删除时，子元素也会被删除
![](http://ww1.sinaimg.cn/large/006Ka4GEgy1flrjkroehvj30eq03ddfs.jpg)

### Association class

当两个类之间的关系不是简单的结构联系时，可以使用协助类(Association class)。例如一个个人可能和一个公司之间有一段实现的雇佣关系。需要表述雇佣时间，可以用如下方式。
![](http://ww1.sinaimg.cn/large/006Ka4GEgy1flrjoiiwkfj30de07hmxa.jpg)

### Generalization

泛化(Generalization)关系，经常用来引出不同类之间的共同部分。这种关系的目标是一个普遍的，或不太具体的来源版本
类或接口。
![](http://ww1.sinaimg.cn/large/006Ka4GEgy1flrjrgy970j30ah09g3yo.jpg)
-->
<h2 id="Association-class"><a href="#Association-class" class="headerlink" title="Association class"></a>Association class</h2><p>当两个类之间的关系不是简单的结构联系时，可以使用协助类(Association class)。例如一个个人可能和一个公司之间有一段实现的雇佣关系。需要表述雇佣时间，可以用如下方式。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flrjoiiwkfj30de07hmxa.jpg" alt=""></p>
<h2 id="Abstract-class"><a href="#Abstract-class" class="headerlink" title="Abstract class"></a>Abstract class</h2><p>抽象类(Abstract class)是一个典型的类，通常提供操作签名但是不提供实现，你也可以拥有一个完全不提供操作的抽象类，抽象类对于识别通用功能非常有用<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flrjutotcmj30cn0683yr.jpg" alt=""></p>
<h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>接口(Interface)是一个分类器，定义了属性和方法，但是没有实现可以用接口来</p>
<p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flrjybq1hlj30g60913zz.jpg" alt=""></p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsgivd4nej30js0fc0sy.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsgivf7d7j30pc0c8aa9.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsgivm5lcj30mu0jgt9j.jpg" alt=""></p>
]]></content>
      <categories>
        <category>ESAIP</category>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>UML 时序图</title>
    <url>/2017/11/22/UML-%E6%97%B6%E5%BA%8F%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="UML-Sequence-Diagrams"><a href="#UML-Sequence-Diagrams" class="headerlink" title="UML Sequence Diagrams"></a>UML Sequence Diagrams</h1><p><strong>时序图</strong>用于描述按时间顺序排列的对象之间的<em>交互模式</em>；它按照参与交互的对象所具有的生命线 (Lifeline) 和它们相互发送的消息来显示这些对象。在时序图中包含对象和主角实例，以及说明它们如何交互的消息。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li>对象表示参与交互的对象，每个对象带有一条生命线，对象被激活时，生命线上出现一个长条（会话），表示对象的存在<ul>
<li>普通对象</li>
<li>匿名对象</li>
<li>未声明所属类对象</li>
</ul>
</li>
<li>生命线 (Lifeline) 表示对象的存在，当对象被激活（创建或者被引用）时，生命线上出现会话，表示对象参与了这个会话。</li>
<li>消息 (Message) 由一个对象的生命线指向另一个对象的生命线，如果消息指向空白的生命线，将创建一个新的会话，如果消息指向已有的会话，表示对象延续已有会话。<ul>
<li>简单消息</li>
<li>返回消息：虚线箭头指向左边</li>
<li>同步消息: 箭头为实心黑色三角</li>
<li>异步消息：箭头只有上半部分</li>
</ul>
</li>
<li>活动</li>
<li>状态不变验证 (State invariants)：可以在生命线上用大括号<code>{}</code>放置需要检测的条件，当任何消息到达这个位置下方的时候需要对条件进行检测。</li>
<li>组合片段 (Combined fragments)： 用一个大方框表示的子片段，左上角显示操作符<ul>
<li>alt - 可以添加 else 条件</li>
<li>opt - 表示子片段只有当满足条件时才会执行，当只有一个条件时，alt 类似于 opt</li>
<li>loop - 表示循环</li>
<li>break - break</li>
<li>par - parallel</li>
<li>strict - strict sequencing</li>
<li>seq - weak sequencing</li>
<li>critical - critical region</li>
<li>ignore - ignore</li>
<li>consider - consider</li>
<li>assert - assertion</li>
<li>neg - negative</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsgoqmfw2j30r80jvdg0.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsgoqr2ygj30ku0oqjrt.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsgoqlkwrj30cs0hijrd.jpg" alt=""></p>
]]></content>
      <categories>
        <category>ESAIP</category>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>UML 用例图</title>
    <url>/2017/11/21/UML-%E7%94%A8%E4%BE%8B%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="UML-Use-Case-Diagrams"><a href="#UML-Use-Case-Diagrams" class="headerlink" title="UML Use Case Diagrams"></a>UML Use Case Diagrams</h1><p>用例图 (Use case diagrams) 通常被称为行为图 (behavior diagrams)， 用来描述一些系统可以与系统的一个或多个外部用户（参与者）合作执行的一组动作（用例）。每个用例应该为系统的参与者或其他利益相关者提供一些可观察到的和有价值的结果。</p>
<h2 id="用例主题，Use-Case-Subject"><a href="#用例主题，Use-Case-Subject" class="headerlink" title="用例主题，Use Case Subject"></a>用例主题，Use Case Subject</h2><p>用例的主题 (Subject) 定义并代表与业务 需求收集和分析有关的业务，软件系统，物理系统或设备，子系统， 组件或甚至单一类别的边界 。<br>用 UML 来说，主体是一个 扮演“主体”角色的 分类器。他们没有为主题创建一个单独的特殊类，就像是在演员和用例一样。UML 2.5 指出 UseCase 的主题可能是一个系统或任何其他可能具有行为的元素，例如 Component 或 Class。“可能拥有行为的分类器被称为 行为分类器，但 UML 2.5 抽象语法仍然将主体作为普通的分类器来显示。</p>
<h3 id="用例主题符号"><a href="#用例主题符号" class="headerlink" title="用例主题符号"></a>用例主题符号</h3><p>主题（有时称为系统边界）由矩形表示，主题名称，关联关键字和原型在左上角。 适用于主题的用例位于矩形的内部，角色位于系统边界之外。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqg0iwn8jj306w04gmx0.jpg" alt=""></p>
<a id="more"></a>
<h2 id="UML-Actor"><a href="#UML-Actor" class="headerlink" title="UML Actor"></a>UML Actor</h2><p>Actor 是一种 Behaviored Classifier，指定了一种外部实体代表的特定的角色，与 Subject 产生交互。Actor 不一定是人。也可以使其他的实体例如服务、支付系统。</p>
<p>角色 (Role)，被非正式地用作需要与关联用例建模的主题的特定服务的用户的某种类型，组或特定方面。当外部实体与主体交互时，它扮演着特定角色的角色。这个单一的物理实体可以扮演几个不同的角色，并且一个特定的角色可以由单个或多个不同的实例来扮演。</p>
<h3 id="Actor-之间的关系"><a href="#Actor-之间的关系" class="headerlink" title="Actor 之间的关系"></a>Actor 之间的关系</h3><p>我们可以定义抽象 (abstract ) 或具体 (concrete )Actor，并使用泛化 (generalization) 关系对其进行专门化。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqgd0p0iyj3074063gle.jpg" alt=""></p>
<h2 id="UML-Use-Case"><a href="#UML-Use-Case" class="headerlink" title="UML Use Case"></a>UML Use Case</h2><p>用例 (Use Case) 允许捕获正在设计或考虑的系统的需求，描述这些系统提供的功能，并确定系统对其环境的要求。</p>
<h3 id="Use-Case-符号"><a href="#Use-Case-符号" class="headerlink" title="Use Case 符号"></a>Use Case 符号</h3><p>用例通常显示为一个包含用例名称的椭圆。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqgh6tcupj303w01w743.jpg" alt=""></p>
<p>当存在 Subject 时，Use Case 在视觉上位于系统边界的矩形内。</p>
<p>用例没有标准关键字或刻板印象。用例可以 在名称上方显示自定义原型。作为一个分类器，用例具有 属性。用例属性列表（ 操作 和属性 ）可以在用例名称下方的用例椭圆内的隔离区中显示。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqgj9fty3j305k03d3ya.jpg" alt=""></p>
<p>具有扩展点的用例 可以在用例的标题扩展点中列出。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqgj9gvp7j305003h742.jpg" alt=""></p>
<h3 id="用例泛化"><a href="#用例泛化" class="headerlink" title="用例泛化"></a>用例泛化</h3><p>注：此部分没有官方方法。但 Actor 和用例都可以被泛化</p>
<p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqgqhopzkj30f207fdg1.jpg" alt=""></p>
<h3 id="用例扩展"><a href="#用例扩展" class="headerlink" title="用例扩展"></a>用例扩展</h3><p>Extend 是一个定向关系 ，在通常的补充（可选）扩展用例中定义的行为如何以及何时可以插入到扩展用例中 定义的行为中。</p>
<p>扩展用例本身是有意义的，但是扩展用例的行为是可选行为。扩展用例的本身可以扩展。</p>
<p>扩展关系显示为虚线，从扩展用例指向原本用例的开放箭头。箭头标有关键字«extend»。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqh1dieuzj30as041q2x.jpg" alt=""></p>
<h3 id="用例包含"><a href="#用例包含" class="headerlink" title="用例包含"></a>用例包含</h3><p>用例包括 (Use Case Include) 两个用例之间的定向关系， 用来表明用例被包含到另一个用例中的行为。<br>该包含关系可用于：</p>
<ul>
<li>通过将其分解成几个用例来简化大的用例：一个大的用例可能会有一些行为，可能会被分离到不同的较小的用例中，使用 UML 包含关系将其包含回基本用例中。这个行动的目的是行为模块化，使他们更易于管理。</li>
<li>提取两个或更多用例行为的共同部分。当两个或两个以上的用例有一些共同的行为时，这个共同的部分可以被提取到一个单独的用例中</li>
</ul>
<p>包含用例之间的关系由一个用例指向其包含的小用例，虚线箭头表示。箭头标有关键字«include»。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqgwyb635j30aj08gdg0.jpg" alt=""></p>
<h3 id="用例关系比较"><a href="#用例关系比较" class="headerlink" title="用例关系比较"></a>用例关系比较</h3><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqgyppn3tj30rd0783z9.jpg" alt=""></p>
<h2 id="UML-Association-Between-Actor-and-Use-Case"><a href="#UML-Association-Between-Actor-and-Use-Case" class="headerlink" title="UML Association Between Actor and Use Case"></a>UML Association Between Actor and Use Case</h2><p>每个用例 代表主体 为演员提供的有用功能单元 。一个关联的 Actor 和用例之间表示该 Actor 和用例以某种方式相互作用或相互通信。只有 Actor 和用例之间允许二元关联。一个 Actor 可以被关联到一个或几个用例。用例可能有一个或几个相关的 Actor。</p>
<h3 id="关联结尾的多重性-Multiplicity"><a href="#关联结尾的多重性-Multiplicity" class="headerlink" title="关联结尾的多重性 (Multiplicity)"></a>关联结尾的多重性 (Multiplicity)</h3><p>UML 允许在 actor 和用例之间的关联的一端或两端使用 Multiplicity。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqhfuqf4oj30gh062q2z.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqhfur4yyj30bg08j74g.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqhfup4zgj309f04wt8m.jpg" alt=""></p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsggobu9wj30le0c8mxi.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsggoel8ej30hs0d83yu.jpg" alt=""></p>
]]></content>
      <categories>
        <category>ESAIP</category>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>UML 概述</title>
    <url>/2017/11/21/UML-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p>ESAIP 的课程里有门课叫做 UML，11 月 24 号考试之前没怎么去上过课，这系列笔记算是初学。<br>考试内容是画图理解图例内容之后感觉应该不会很难。<br>笔记内容来自 <a href="https://www.uml-diagrams.org/" target="_blank" rel="noopener">The Unified Modeling Language</a>,<a href="http://www.tutorialspoint.com/uml/" target="_blank" rel="noopener">tutorialspoint</a> 和相关中英文维基，由于国内相关内容较少，不再另找正式的中文翻译，文章内涉及到的英文关键词尽量以原文出现。中文翻译均为自译<br>计划是概述单独开一个页面，之后每（几）个 Diagrams 单独开页面。根据相关 Diagrams 的重要程度决定相关内容。Diagrams 的介绍顺序为 ESAIP 中课程 PDF 内的顺序</p>
</blockquote>
<h1 id="统一建模语言，-UML-Unified-Modeling-Language-概述"><a href="#统一建模语言，-UML-Unified-Modeling-Language-概述" class="headerlink" title="统一建模语言， UML(Unified Modeling Language) 概述"></a>统一建模语言， UML(Unified Modeling Language) 概述</h1><p>在 1997 年 UML 被 Object Management Group (OMG) 接受并发布了 UML v1.1，到如今已经迭代了许多次。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqc6idezqj309q06xwer.jpg" alt=""><br>UML 是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。<br>一图胜千言，UML 就是用图形的方法来实现上述功能。<br>UML 不仅适用于程序设计，同时适用于商业过程。<br>总之 UML 就是用建模来模拟当今所有的复杂环境。</p>
<!--
# 模型

在 UML 系统开发中有三个主要的模型：

- **功能模型**：从用户的角度展示系统的功能，包括用例图。
- **对象模型**：采用对象，属性，操作，关联等概念展示系统的结构和基础，包括类别图、对象图。
- **动态模型**：展现系统的内部行为。包括序列图，活动图，状态图。

区分 UML 模型和 UML 图是非常重要的，UML 图，包括用例图、协作图、活动图、序列图、部署图、构件图、类图、状态图，是模型中信息的图形表达方式，但是 UML 模型独立于 UML 图存在。UML 的当前版本只提供了模型信息的交换，而没有提供图信息的交换。
-->
<p>为了理解 UML 的概念模型，首先我们需要澄清什么是概念模型？以及为什么需要概念模型？</p>
<ul>
<li><p>概念模型可以定义为由概念及其关系构成的模型。</p>
</li>
<li><p>概念模型是绘制 UML 图之前的第一步。它有助于理解现实世界中的实体以及它们如何相互作用。</p>
</li>
</ul>
<p>由于 UML 描述的是实时系统，因此建立一个概念模型并逐步进行是非常重要的。UML 的概念模型可以通过学习以下三个主要元素来掌握 -</p>
<ul>
<li>UML 构建块 (UML building blocks)</li>
<li>链接构建块的规则 (Rules to connect the building blocks)</li>
<li>UML 的通用机制 (Common mechanisms of UML)</li>
</ul>
<a id="more"></a>
<h2 id="UML-building-blocks"><a href="#UML-building-blocks" class="headerlink" title="UML building blocks"></a>UML building blocks</h2><p>UML building blocks 可以被定义为</p>
<ul>
<li>Things, 事物</li>
<li>Relationships, 关系</li>
<li>Diagrams, 图</li>
</ul>
<h3 id="Things-事物"><a href="#Things-事物" class="headerlink" title="Things, 事物"></a>Things, 事物</h3><p>Things 是 UML 最重要的部分，分为</p>
<ul>
<li>Structural, 结构</li>
<li>Behavioral, 行为</li>
<li>Grouping, 分组</li>
<li>Annotational, 注释</li>
</ul>
<h4 id="Structural-Things"><a href="#Structural-Things" class="headerlink" title="Structural Things"></a>Structural Things</h4><p>Structural Things 定义了模型的静态部分。他们代表了物理和概念元素。</p>
<p><strong>类 (Class )</strong> -类表示一组具有类似职责的对象。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqdi8osmyj303f01rt8h.jpg" alt=""></p>
<p><strong>接口 (Interface )</strong> -接口定义了一组操作，它们指定了一个类的责任。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqdi8ooibj303001e0sh.jpg" alt=""></p>
<p><strong>协作 (Collaboration )</strong> -协作定义元素之间的交互。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqdi8p3ikj302301a0gi.jpg" alt=""></p>
<p><strong>用例 (Use case)</strong> -用例代表系统为特定目标执行的一组操作。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqdi8p4nfj3029016a9t.jpg" alt=""></p>
<p><strong>组件 (Component )</strong> -组件描述了系统的物理部分。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqdi8om52j303201ddfl.jpg" alt=""></p>
<p><strong>节点 (Node)</strong> -节点可以定义为运行时存在的物理元素。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqdi8og70j302f02fa9t.jpg" alt=""></p>
<h4 id="Behavioral-Things"><a href="#Behavioral-Things" class="headerlink" title="Behavioral Things"></a>Behavioral Things</h4><p>行为事物由 UML 模型的动态部分组成。</p>
<p><strong>交互 (Interaction)</strong> -交互被定义为一个行为，由一组消息交换元素之间交换，以完成特定的任务。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqdmjkxlbj30300190sh.jpg" alt=""></p>
<p><strong>状态机 (State machine)</strong> -当一个对象在其生命周期中的状态很重要时，状态机非常有用。它定义了对象响应事件所经历的状态顺序。事件是造成状态变化的外部因素<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqe2de7slj303101vdfl.jpg" alt=""></p>
<h4 id="Grouping-Things"><a href="#Grouping-Things" class="headerlink" title="Grouping Things"></a>Grouping Things</h4><p>将事物分组可以被定义为将 UML 模型的元素分组在一起的机制。</p>
<p><strong>包 (Package)</strong> -包是唯一的分组事物，用于收集 structural things 和 behavioral things。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqdmjk55lj30300233y9.jpg" alt=""></p>
<h4 id="Annotational-Things"><a href="#Annotational-Things" class="headerlink" title="Annotational Things"></a>Annotational Things</h4><p>注释事物可以被定义为捕获 UML 模型元素的注释，描述和注释的机制。注释用于呈现 UML 元素的注释，约束等。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqdmjl232j302301f0sh.jpg" alt=""></p>
<h3 id="Relationship"><a href="#Relationship" class="headerlink" title="Relationship"></a>Relationship</h3><p>关系是 UML 的另一个最重要的组成部分。</p>
<h4 id="关联-Association"><a href="#关联-Association" class="headerlink" title="关联 (Association)"></a>关联 (Association)</h4><p>是一种基本的链接，用于链接 UML 模型中的各类元素。同时也表述了多少对象参与其中,它显示了元素是如何相互关联的，这个关联描述了应用程序的功能。如客户和订单，每个订单对应特定的客户，每个客户对应一些特定的订单，再如篮球队员与球队之间的关联（下图所示）。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flslbdtu1ej308z03baa2.jpg" alt=""></p>
<ul>
<li>单向关联</li>
<li>双相关联</li>
<li>自关联</li>
<li>重数性关联：在关联中加入多重性</li>
</ul>
<h4 id="依赖-Dependency"><a href="#依赖-Dependency" class="headerlink" title="依赖 (Dependency)"></a>依赖 (Dependency)</h4><p>是一种在两个元素之间的关系，一个元素发生改变会影响另一个。 在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsl7n3ooej30dw0323yu.jpg" alt=""></p>
<h4 id="泛化-Generalization"><a href="#泛化-Generalization" class="headerlink" title="泛化 (Generalization)"></a>泛化 (Generalization)</h4><p>泛化关系(Generalization)：A是B和C的父类，B,C具有公共类（父类）A，说明A是B,C的一般化（概括，也称泛化）</p>
<p>泛化关系(Generalization)也就是继承关系，也称为“is-a-kind-of”关系，泛化关系用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。在UML中，泛化关系用带空心三角形的直线来表示。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsl9pyc3jj30go06vmz0.jpg" alt=""></p>
<h4 id="聚合-Aggregation"><a href="#聚合-Aggregation" class="headerlink" title="聚合(Aggregation)"></a>聚合(Aggregation)</h4><p>聚合关系(Aggregation) 表示一个整体与部分的关系。通常在定义一个整体类后，再去分析这个整体类的组成结构，从而找出一些成员类，该整体类和成员类之间就形成了聚合 关系。整体与部分可以分离</p>
<p>在聚合关系中，成员类是整体类的一部分，即成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flslexea18j30go02hwff.jpg" alt=""></p>
<h4 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系(Composition)"></a>组合关系(Composition)</h4><p>组合关系(Composition)也表示类之间整体和部分的关系，但是组合关系中部分和整体具有统一的生存期。一旦整体对象不存在，部分对象也将不存在，部分对象与整体对象之 间具有同生共死的关系。</p>
<p>在组合关系中，成员类是整体类的一部分，而且整体类可以控制成员类的生命周期，即成员类的存在依赖于整体类。在UML中，组合关系用带实心菱形的直线表示。</p>
<p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flslgmrfuej30go02amxq.jpg" alt=""></p>
<h4 id="实现-Realization"><a href="#实现-Realization" class="headerlink" title="实现 (Realization)"></a>实现 (Realization)</h4><p>可以被定义为两个元素连接的关系。一个要素描述了一些责任，这个责任没有被执行，另一个则被执行。这种关系存在于接口的情况下。<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flsllnlmhhj30g407o3zu.jpg" alt=""></p>
<h3 id="UML-Diagrams"><a href="#UML-Diagrams" class="headerlink" title="UML Diagrams"></a>UML Diagrams</h3><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flqcsr68pij30go09a3yr.jpg" alt=""></p>
<p>UML 2.2 中一共定义了 14 种图示。为方便了解，可分类成如上所示的结构。</p>
<ul>
<li>结构性图形（Structure diagrams）强调的是系统式的建模：<ul>
<li><strong><a href="http://starxy.cc/2017/11/22/UML-%E7%B1%BB%E5%9B%BE/">类图 (Class DIagram)</a></strong></li>
<li>对象图 (Object Diagram)</li>
<li><strong><a href="http://starxy.cc/2017/11/23/UML-%E5%8C%85%E5%9B%BE/">包图 (Package Diagram)</a></strong></li>
<li><strong>组件图 <a href="http://starxy.cc/2017/11/23/UML-%E7%BB%84%E4%BB%B6%E5%9B%BE/">(Component Diagram)</a></strong></li>
<li><strong><a href="http://starxy.cc/2017/11/23/UML-%E9%83%A8%E7%BD%B2%E5%9B%BE/">部署图 (Deployment Diagram)</a></strong></li>
<li>剖面图 (Profile Diagram)</li>
<li>复合结构图 (Composite Structure Diagram)</li>
</ul>
</li>
<li>行为式图形（Behavior diagrams）强调系统模型中触发的事件：<ul>
<li><strong><a href="http://starxy.cc/2017/11/23/UML-%E6%B4%BB%E5%8A%A8%E5%9B%BE/">活动图 (Activity Diagram)</a></strong></li>
<li><strong><a href="http://starxy.cc/2017/11/23/UML-%E7%8A%B6%E6%80%81%E5%9B%BE/">状态图 (State Machine Diagram)</a></strong></li>
<li><strong><a href="http://starxy.cc/2017/11/21/UML-%E7%94%A8%E4%BE%8B%E5%9B%BE/#more">用例图 (Use Case Diagram)</a></strong></li>
</ul>
</li>
<li>交互性图形（Interaction diagrams），属于行为图形的子集合，强调系统模型中的资料流程：<ul>
<li>通信图 (Communication Diagram)</li>
<li>交互概述图（UML 2.0）(Interaction Overview Diagram)</li>
<li><strong><a href="http://starxy.cc/2017/11/22/UML-%E6%97%B6%E5%BA%8F%E5%9B%BE/">时序图（UML 2.0）(Sequeence Diagram)</a></strong></li>
<li>时间图（UML 2.0）(Timing Diagram)</li>
</ul>
</li>
</ul>
<p>为了要保持工程图的传统，<strong>在您的 UML 图上加注用途、约束、或意图永远无伤大雅</strong>。</p>
<!--
## 基本符号

UML 是图形化语言，所以符号是建模中最重要的元素。

### Class 图例

UML 中的类大体如下所示，图示分为四个部分

- 顶部为类名
- 下面一部分用于表述类的属性
- 第三部分用于表述类的操作方法
- 底部可选表述外部组件

![](http://ww1.sinaimg.cn/large/006Ka4GEgy1flqei4dc28j30cz06ejrh.jpg)
类用来表示对象，对象可以是任何有属性和责任的事物

### Object 图例

对象符号和类符号有相同的部分，唯一的不同是顶部的名称下有下划线
![](http://ww1.sinaimg.cn/large/006Ka4GEgy1flqek2fndaj306v04tjrb.jpg)
对象是类的具体实例，与类有相同的用法

### Interface 图例

接口由一个圆圈表示，下方书写接口名称。
![](http://ww1.sinaimg.cn/large/006Ka4GEgy1flqem46iyvj308h04odfo.jpg)
接口用来描述未实现的方法，具体类似于 Java 的接口

### Collaboration 图例

Collaboration 由一个虚线画的椭圆表示，名称写在椭圆内部
![](http://ww1.sinaimg.cn/large/006Ka4GEgy1flqep31c9wj30an06yweg.jpg)
Collaboration represents responsibilities. Generally, responsibilities are in a group.

### Use Case 图例

用例图例由一个实线画的椭圆表示，名称写在椭圆内部
![](http://ww1.sinaimg.cn/large/006Ka4GEgy1flqertwx7nj30am05pjrc.jpg)

### Actor 图例
-->]]></content>
      <categories>
        <category>ESAIP</category>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>菜谱-香辣土豆牛肉饭</title>
    <url>/2017/11/14/%E8%8F%9C%E8%B0%B1-%E9%A6%99%E8%BE%A3%E5%9C%9F%E8%B1%86%E7%89%9B%E8%82%89%E9%A5%AD/</url>
    <content><![CDATA[<h1 id="香辣土豆牛肉饭"><a href="#香辣土豆牛肉饭" class="headerlink" title="香辣土豆牛肉饭"></a>香辣土豆牛肉饭</h1><p><img src="http://ww1.sinaimg.cn/mw690/006Ka4GEgy1fli9ia1td8j31hc0xcwo9.jpg" alt=""></p>
<blockquote>
<p>本菜谱全部来自于<strong>绵羊料理</strong>。<a href="https://space.bilibili.com/18202105#!/" target="_blank" rel="noopener">点此查看 Up 主空间视频</a><br>本期视频链接：<a href="https://www.bilibili.com/video/av9849362/" target="_blank" rel="noopener">不开火！香辣土豆牛肉饭便当丨绵羊生存料理</a></p>
</blockquote>
<h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><ul>
<li>咸牛肉罐头 200g （除羊肉罐头外其他均可）</li>
<li>大土豆半个 （切成小丁）</li>
<li>洋葱半个 （切成小丁）</li>
<li>葱、香菜 （装饰用）</li>
<li>小红椒 (非朝天椒)</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>土豆放入容器中，盖起来（留孔），微波炉里高温 4分钟</li>
<li>半小勺盐让土豆入味，搅拌均匀后，盖起来（留孔），高温 1分钟</li>
<li>此时土豆绵软，盛出备用</li>
<li>加入洋葱，半大勺油，搅拌均匀，盖起来（留孔），微波炉高温 2分钟</li>
<li>放入土豆，加入200g 肉罐头，放入小红椒，撒些黑胡椒，搅拌均匀</li>
<li>不加盖，微波炉高火 2分钟</li>
</ol>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>开火版做法：</p>
<ol>
<li>在水里多加点盐把土豆煮软入味，捞出沥干。</li>
<li>锅里热油炒洋葱。</li>
<li>加土豆牛肉一起炒，加红辣椒和黑胡椒翻炒一会，出锅！</li>
</ol>
]]></content>
      <categories>
        <category>菜谱</category>
      </categories>
      <tags>
        <tag>菜谱</tag>
        <tag>绵羊生存料理</tag>
      </tags>
  </entry>
  <entry>
    <title>菜谱-懒人肉酱</title>
    <url>/2017/11/14/%E8%8F%9C%E8%B0%B1-%E6%87%92%E4%BA%BA%E8%82%89%E9%85%B1/</url>
    <content><![CDATA[<h1 id="懒人肉酱"><a href="#懒人肉酱" class="headerlink" title="懒人肉酱"></a>懒人肉酱</h1><p><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1fli8ny3ufgj30p00fmn2j.jpg" alt=""></p>
<blockquote>
<p>本菜谱全部来自于<strong>绵羊料理</strong>。<a href="https://space.bilibili.com/18202105#!/" target="_blank" rel="noopener">点此查看 Up 主空间视频</a><br>本期视频链接：<a href="https://www.bilibili.com/video/av15284710/" target="_blank" rel="noopener">多功能懒人肉酱，保你宅家半年肚子不饿丨绵羊生存料理</a></p>
</blockquote>
<h2 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h2><ul>
<li>猪肉 400g</li>
<li>豆瓣酱 4小勺</li>
<li>大蒜 5瓣</li>
<li>老姜 1块</li>
<li>芝麻油 4大勺</li>
<li>酱汁<ul>
<li>水 150ml</li>
<li>酱油 3大勺</li>
<li>料酒 3大勺</li>
<li>糖 4小勺</li>
<li>香辣酱 1小勺 （可选）</li>
</ul>
</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>姜蒜弄碎，切成沫</li>
<li>小火芝麻油（香油）加热，放入姜蒜沫炒香</li>
<li>倒入猪肉馅，炒至变色</li>
<li>加入豆瓣酱和酱汁，转中火拌炒均匀</li>
<li>大火收汁，水分蒸发到只剩油汁</li>
<li>离火</li>
</ol>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>分装4份，<strong>冷冻</strong>保存能放半年</p>
<p>猪肉变色：<br><img src="http://ww1.sinaimg.cn/large/006Ka4GEgy1flrk7q7d2zj3099057n03.jpg" alt=""></p>
]]></content>
      <categories>
        <category>菜谱</category>
      </categories>
      <tags>
        <tag>菜谱</tag>
        <tag>绵羊生存料理</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路算法</title>
    <url>/2017/03/20/%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="Dijkstra-Heap"><a href="#Dijkstra-Heap" class="headerlink" title="Dijkstra+Heap"></a>Dijkstra+Heap</h1><ul>
<li>用优先队列实现堆。对算法进行优化<br>$T(n) = O(E+VlgV)$</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> dist;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> d,u;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">const</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> HeapNode&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d &gt; a.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n,m; <span class="comment">// 点，边数</span></span><br><span class="line"><span class="keyword">int</span> d[maxn]; <span class="comment">//从起点到终点的最短距离</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123; <span class="comment">// 求s到所有点的最短距离</span></span><br><span class="line">	priority_queue&lt;HeapNode&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) d[i] = INF;</span><br><span class="line">	<span class="comment">//while(!q.empty()) q.pop();清空队列</span></span><br><span class="line">	d[s] = <span class="number">0</span>;</span><br><span class="line">	q.push(HeapNode&#123;d[s],s&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		HeapNode tmp = q.top(); q.pop();</span><br><span class="line">		<span class="keyword">int</span> now = tmp.u;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;G[now].size();i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = G[now][i].v;</span><br><span class="line">			<span class="keyword">if</span>(d[v] &gt; d[now] + G[now][i].dist)&#123;</span><br><span class="line">				d[v] = d[now] + G[now][i].dist;</span><br><span class="line">				q.push(HeapNode&#123;d[v],v&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>自己写的记录节点的代码。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> dist;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> d,u;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">const</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> HeapNode&amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d &gt; a.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n,m; <span class="comment">// 点，边数</span></span><br><span class="line"><span class="keyword">int</span> d[maxn]; <span class="comment">//从起点到终点的最短距离</span></span><br><span class="line"><span class="keyword">int</span> pre[maxn]; <span class="comment">// 记录当前顶点的 前一个顶点</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123; <span class="comment">// 求s到所有点的最短距离</span></span><br><span class="line">	priority_queue&lt;HeapNode&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123; d[i] = INF; &#125;</span><br><span class="line">	<span class="comment">//while(!q.empty()) q.pop();清空队列</span></span><br><span class="line">	d[s] = <span class="number">0</span>;</span><br><span class="line">	q.push(HeapNode&#123;d[s],s&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">		HeapNode tmp = q.top(); q.pop();</span><br><span class="line">		<span class="keyword">int</span> now = tmp.u;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;G[now].size();i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = G[now][i].v;</span><br><span class="line">			<span class="keyword">if</span>(d[v] &gt; d[now] + G[now][i].dist)&#123;</span><br><span class="line">				d[v] = d[now] + G[now][i].dist;</span><br><span class="line">				pre[v] = now;</span><br><span class="line">				q.push(HeapNode&#123;d[v],v&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++) &#123; G[i].clear(); pre[i] = <span class="number">-1</span>;&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> x,y,z;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">			G[x].push_back(Edge&#123;y,z&#125;);</span><br><span class="line">			G[y].push_back(Edge&#123;x,z&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> s,t;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s&gt;&gt;t;</span><br><span class="line">		dijkstra(s);</span><br><span class="line">		<span class="keyword">if</span>(d[t] == INF) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,d[t]);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; p; <span class="comment">//输出最短路径</span></span><br><span class="line">		<span class="keyword">int</span> prev = pre[t];</span><br><span class="line">		p.push(t);</span><br><span class="line">		<span class="keyword">while</span>(prev!=s)&#123;</span><br><span class="line">			p.push(prev);</span><br><span class="line">			prev = pre[prev];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!p.empty()) &#123; <span class="built_in">cout</span> &lt;&lt; p.top() &lt;&lt; <span class="string">" "</span>; p.pop();&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h1><ul>
<li>Dijkstra和SPFA可用于1e5的边和1e5的点。推荐用Dijkstra</li>
<li>SPFA + 负环判断</li>
<li>$T(n) = O(kE) $在最坏的情况下，$T(n) = O(VE)$</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> v,dist; <span class="comment">//dist存储距离即时间。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> inq[maxn];</span><br><span class="line"><span class="keyword">int</span> dt[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn]; <span class="comment">// 每个点的入队次数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;maxn;i++)&#123;inq[i] = <span class="number">0</span>; dt[i] = INF; cnt[i] = <span class="number">0</span>;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	inq[s] = <span class="number">1</span>;</span><br><span class="line">	dt[s] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!Q.empty()) Q.pop();	<span class="comment">//清空Q</span></span><br><span class="line">	Q.push(s);</span><br><span class="line">	cnt[s] = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(!Q.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> now = Q.front();Q.pop();</span><br><span class="line">		inq[now] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;G[now].size();i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = G[now][i].v;</span><br><span class="line">			<span class="keyword">if</span>(dt[v] &gt; dt[now]+G[now][i].dist)&#123;</span><br><span class="line">				dt[v] = dt[now]+G[now][i].dist;</span><br><span class="line">				<span class="keyword">if</span>(inq[v])<span class="keyword">continue</span>;</span><br><span class="line">				inq[v] = <span class="number">1</span>;</span><br><span class="line">				Q.push(v);</span><br><span class="line">				<span class="keyword">if</span>(++cnt[v] &gt; n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="floyd"><a href="#floyd" class="headerlink" title="floyd"></a>floyd</h1><ul>
<li>动态规划，稠密图效果最佳</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] &gt; g[i][k] + g[k][j]) g[i][j] = g[i][k] + g[k][j]</span><br></pre></td></tr></table></figure>
<h1 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman-ford"></a>bellman-ford</h1><ul>
<li>bellman-ford算法的重要应用是判负环，如果迭代$n-1$次后还可以进行松弛操作，说明一定有负环存在，如果采用队列实现，当一个点进队了$n$次，即可判断有负环存在。<ul>
<li>$T(n) = O(VE)$</li>
</ul>
</li>
</ul>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul>
<li>Dijkstra：适用于权值为非负的图的单源最短路径，用斐波那契堆的复杂度O(E+VlgV)</li>
<li>BellmanFord：适用于权值有负值的图的单源最短路径，并且能够检测负圈，复杂度O(VE)</li>
<li>SPFA：适用于权值有负值，且没有负圈的图的单源最短路径，论文中的复杂度O(kE)，k为每个节点进入Queue的次数，且k一般&lt;=2，但此处的复杂度证明是有问题的，其实SPFA的最坏情况应该是O(VE).</li>
<li>Floyd：每对节点之间的最短路径。</li>
<li>(1)当权值为非负时，用Dijkstra。</li>
<li>(2)当权值有负值，且没有负圈，则用SPFA，SPFA能检测负圈，但是不能输出负圈。</li>
<li>(3)当权值有负值，而且可能存在负圈，则用BellmanFord，能够检测并输出负圈。</li>
<li><p>(4)SPFA检测负环：当存在一个点入队大于等于V次，则有负环，后面有证明。</p>
</li>
<li><p>SPFA算法在负边权图上可以完全取代Bellman-ford算法，另外在稀疏图中也表现良好。但是在非负边权图中，为了避免最坏情况的出现，通常使用效率更加稳定的Dijkstra算法，以及它的使用堆优化的版本。通常的SPFA算法在一类网格图中的表现不尽如人意。</p>
</li>
<li>SPFA的算法时间效率是不稳定的，即它对于不同的图所需要的时间有很大的差别。在最好情形下，每一个节点都只入队一次，则算法实际上变为广度优先遍历，其时间复杂度仅为O(E)。另一方面，存在这样的例子，使得每一个节点都被入队(V-1)次，此时算法退化为Bellman-ford算法，其时间复杂度为O(VE)。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2017/03/20/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<ul>
<li>一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。</li>
</ul>
<h1 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h1><p>邻接矩阵:$O(v^2)$                 邻接表:$O(elog_2v)$</p>
<ul>
<li>思路：每次选取已构成的最小生成树的点在图上所连接的最小的边 <strong>使用优先队列</strong> </li>
</ul>
<p><strong>【描述】</strong></p>
<ul>
<li>原图中，顶点集合 $V$边集合$E$，设定$V<em>{new} = { x }$，其中$x$为$V$中任意一顶点，$E</em>{new} = { }$</li>
<li>重复下列操作直到$V_{new} = V$.<ul>
<li>在集合$E$中选取权值最小的边$ \langle u , v \rangle$，其中u为集合$V<em>{new}$中的元素，而$v$不在$V</em>{new}$集合当中，并且$v∈V$</li>
<li>将$v$加入集合$V<em>{new}$中，将$ \langle u , v \rangle$边加入集合$E</em>{new}$中</li>
</ul>
</li>
<li>集合$E<em>{new},V</em>{new}$即为生成的最小树</li>
</ul>
<a id="more"></a>
<p><strong>【模版】</strong></p>
<ul>
<li>邻接表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> +<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> cost;</span><br><span class="line">	edge(<span class="keyword">int</span> tt,<span class="keyword">int</span> cc):to(tt),cost (cc)&#123;&#125;</span><br><span class="line">	edge()&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> cost &gt; b.cost;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G[maxn];</span><br><span class="line">priority_queue&lt;edge&gt; que;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">//生成n个点的最小生成树</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="keyword">while</span>(!que.empty()) que.pop();</span><br><span class="line">	vis[<span class="number">1</span>] = <span class="number">1</span>;		<span class="comment">//注意题目中点的标号从1开始</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;G[<span class="number">1</span>].size();i++) que.push(G[<span class="number">1</span>][i]);</span><br><span class="line">	<span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">		edge e = que.top();que.pop();</span><br><span class="line">		<span class="keyword">if</span>(vis[e.to]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[e.to] = <span class="number">1</span>;</span><br><span class="line">		res += e.cost;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;G[e.to].size();i++)</span><br><span class="line">			que.push(G[e.to][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt &lt; n<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>邻接矩阵</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2011</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> lowc[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> cost[][maxn], <span class="keyword">int</span> n)</span></span>&#123; <span class="comment">//点0~n-1</span></span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	vis[<span class="number">0</span>]= ture;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)lowc[i] = cost[<span class="number">0</span>][i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> minc = INF;</span><br><span class="line">		<span class="keyword">int</span> p = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!vis[j] &amp;&amp; minc&gt;lowc[j])&#123;</span><br><span class="line">				minc = lowc[j];</span><br><span class="line">				p = j;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(minc == INF) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//原图不连通</span></span><br><span class="line">			ans+minc;</span><br><span class="line">			vis[p] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(!vis[j] &amp;&amp; lowc[j] &gt; cost[p][j]) lowc[j] = cost[p][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h1><p>$T(n) = ElogE$</p>
<ul>
<li>思路：每次选出最小的不构成环的边。</li>
</ul>
<p><strong>【描述】</strong><br>1).记$G$中有$v$个顶点，$e$个边</p>
<p>2).新建图$G<em>{new}$，$G</em>{new}$中拥有原图中相同的$e$个顶点，但没有边</p>
<p>3).将原图$G$中所有$e$个边按权值从小到大排序</p>
<p>4).循环：从权值最小的边开始遍历每条边 直至图$G$中所有的节点都在同一个连通分量中  <strong>使用并查集来维护</strong></p>
<ul>
<li><p>if 这条边连接的两个节点于图$G_{new}$中不在同一个连通分量中</p>
</li>
<li><p>添加这条边到图$G_{new}$中</p>
</li>
</ul>
<p>【模版】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> +<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,from;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> cost;</span><br><span class="line">&#125; E[maxn * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.cost &lt; b.cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">		f[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[x] == x)<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> f[x] = Find(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Find(a) == Find(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	f[Find(a)] = Find(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//传入点数</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;	<span class="comment">//计算加入边的个数</span></span><br><span class="line">	sort(E,E+m,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(same(E[i].from,E[i].to)) <span class="keyword">continue</span>;</span><br><span class="line">		merge(E[i].from,E[i].to);</span><br><span class="line">		res += E[i].cost;</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt &lt; n<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//不连通</span></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2017/03/20/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>拓扑排序是对<strong>有向无圈图(DAG)</strong>顶点的一种排序，它使得如果存在u,v的有向路径，那么满足序中u在v前。拓扑排序就是由一种偏序(partical order)得到一个全序(称为拓扑有序(topological order))。偏序是满足自反性，反对称性，传递性的序。<br>拓补排序的思路很简单，就是每次任意找一个入度为0的点输出，并把这个点以及与这个点相关的边删除。实际算法中，用一个队列实现。</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ol>
<li>把所有入度=0的点入队Q。</li>
<li>若队Q非空，则点u出队，输出u；否则转4。</li>
<li>把所有与点u相关的边(u,v)删除，若此过程中有点v的入度变为0，则把v入队Q，转2。</li>
<li>若出队点数&lt;N，则有圈；否则输出结果。</li>
</ol>
<p>算法复杂度: $O(v+e)$。</p>
<a id="more"></a>
<h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to,cost;</span><br><span class="line">	Node(<span class="keyword">int</span> tt, <span class="keyword">int</span> cc):to(tt),cost(cc)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m; </span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> ind[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toplogy_sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;<span class="keyword">while</span>(!que.empty()) que.pop();</span><br><span class="line">	<span class="keyword">while</span>(!out.empty()) out.pop();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;	<span class="comment">//结点编号从1开始</span></span><br><span class="line">		<span class="keyword">if</span>(ind[i] == <span class="number">0</span>) que.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">		<span class="keyword">int</span> now = que.front();que.pop();out.push(now);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;G[now].size();i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> v = G[now][i].to;</span><br><span class="line">			ind[v]--;</span><br><span class="line">			<span class="keyword">if</span>(ind[v] == <span class="number">0</span>) &#123;</span><br><span class="line">				que.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(out.size() &lt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂算法</title>
    <url>/2017/03/20/%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="最简单的整数幂取模"><a href="#最简单的整数幂取模" class="headerlink" title="最简单的整数幂取模"></a>最简单的整数幂取模</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=b;i++)&#123;</span><br><span class="line">		ans = ans*a%m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 我们知道，$a \times b \% m$可以转化为$( ( a \% m) \times b ) \% m$，用这种方法处理可以解决$a \times b$过大的情况，但是时间复杂度依旧是$O(n)$，当$b$很大的情况，依旧会超时。</p>
<h1 id="整数快速幂"><a href="#整数快速幂" class="headerlink" title="整数快速幂"></a>整数快速幂</h1><blockquote>
<p>对于求$a^b%m$的问题，当$a,b$很大的情况，直接求解不太可能。</p>
</blockquote>
<p>这里利用二分的思想来解决可以达到$O(log_2n)$<br><a id="more"></a></p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ul>
<li>首先我们可以把$b$按二进制展开，$b = b<em>n2^n + b</em>{n-1}2^{n-1}+ b_{n-2}2^{n-2}+ …+b_1 \times 2 + b_0$，其中$b_i(0 \leq i \leq n)$为$0$或$1$，那么<script type="math/tex; mode=display">a^b = a^{ b_n2^n + b_{n-1}2^{n-1}+ b_{n-2}2^{n-2}+ ...+b_1 \times 2 + b_0} = a^{b_n2^n}a^{b_{n-1}2^{n-1}} \cdot ... \cdot a^{b_1 \times 2}a^{b_0}</script>对于$b_i = 0$的情况不用处理，对于$b_i = 1$，利用$a^{2i} = (a^{2i+1})^2$再利用前面的结论，可以递推计算出$a^{2i}$，之后把满足$b_i = 1$的$a^{2i}\%m$按照之前的算法撑起来就得到结果<h2 id="快速幂算法实现"><a href="#快速幂算法实现" class="headerlink" title="快速幂算法实现"></a>快速幂算法实现</h2></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(b &amp; <span class="number">1</span>) <span class="keyword">return</span> a*quick_pow(a,b<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> t = quick_pow(a,b/<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">return</span> t*t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> base  = a;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>) result *= base;</span><br><span class="line">		base *= base;</span><br><span class="line">		b &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速幂取模算法实现"><a href="#快速幂取模算法实现" class="headerlink" title="快速幂取模算法实现"></a>快速幂取模算法实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PowMod</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> base = a%c;</span><br><span class="line">	<span class="keyword">while</span>(b) &#123;</span><br><span class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>) result = (result*baes %c);</span><br><span class="line">		base = (base * base)%c;</span><br><span class="line">		b &gt;&gt; = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>RMQ&amp;LCA</title>
    <url>/2017/03/20/RMQ-LCA/</url>
    <content><![CDATA[<h1 id="RMQ-Range-Minimum-Maximum-Query"><a href="#RMQ-Range-Minimum-Maximum-Query" class="headerlink" title="RMQ (Range Minimum/Maximum Query)"></a>RMQ (Range Minimum/Maximum Query)</h1><p>对于一个序列，求区间$[L,R]$的区间中最大/最小的元素<br><strong>预处理Sparse-Table</strong></p>
<ul>
<li>设数组$d(i,j)$表示从$i$位置开始连续$2^j$个数之间的最大值<ul>
<li>那么，对于$j = 0,d(i,0) = a[i]$</li>
<li>对于$j \neq 0$ $d(i,j) = max( d(i,j-1),d(i + 2^{j-1},j-1) )$</li>
</ul>
</li>
</ul>
<p>注意$2^j \leq n$即$d$数组的个数不会超过$nlogn$，故预处理所花费的时间为$O(nlogn)$<br><strong>查询操作</strong></p>
<ul>
<li>令$k = \lfloor log_2 (R-L+1) \rfloor$</li>
<li>则区间$[L,R]$的最值即为$max( d(L,k),d(R-2^k+1,k) )$<a id="more"></a>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initRMQ</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) d[i][<span class="number">0</span>] = a[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;i + (<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span> &lt; n;j++)</span><br><span class="line">			d[i][j] = min(d[i][j<span class="number">-1</span>],d[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RMQ</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;(k+<span class="number">1</span>)) &lt;= R-l+<span class="number">1</span>) k++;</span><br><span class="line">	<span class="keyword">return</span> min(d[L][k],d[R-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="LCA（Least-Common-Ancestors）"><a href="#LCA（Least-Common-Ancestors）" class="headerlink" title="LCA（Least Common Ancestors）"></a>LCA（Least Common Ancestors）</h1>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2017/03/20/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<ul>
<li>N 个不同的元素分布在若干个互不相交集合中，需要进行以下3个操作：<ul>
<li><ol>
<li>合并两个集合</li>
</ol>
</li>
<li><ol>
<li>查询一个元素在哪个集合 </li>
</ol>
</li>
<li><ol>
<li>查询两个元素是否属于同一集合</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="采用树结构表示集合"><a href="#采用树结构表示集合" class="headerlink" title="采用树结构表示集合"></a>采用树结构表示集合</h1><ul>
<li><code>GET_PAR( )</code>的时间复杂度一般为 $T(n)&lt;=4$<a id="more"></a>
</li>
</ul>
<h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">		father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_par</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x == father[x]) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> father[x] = get_par(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> get_par(a) == get_par(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		father[get_par(a)] = get_par(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组(Binary Indexed Tree,BIT)</title>
    <url>/2017/03/20/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><code>lowbit(x) = x&amp;-x</code></p>
<ul>
<li>BIT中，每一层的$lowbit$相同，$lowbit$越大越靠近根节点，对于节点$i$如果他是左子节点，那么他的父节点为$i+lowbit(i)$，如果为右子节点，那么他的父节点为$i-lowbit(i)$</li>
<li>构造辅助数组 <script type="math/tex; mode=display">C_i =  A_{i-lowbit(i)+1} + A_{i-lowbit(i)+2} +... +A_i</script></li>
</ul>
<p>有了$C_i$<br>对于所要求的前缀和$S_i$ 操作<br>对于$A_i$元素修改操作</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		ret += C[x];</span><br><span class="line">		x-=lowbit(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x&lt;=n) &#123;</span><br><span class="line">		C[x] += d;</span><br><span class="line">		x += lowbit(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度均为$O(logn)$ 预处理的方法是先把A 和 C 数组清空执行n次add操作，总时间复杂度为$O(nlogn)$</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树(segment tree)</title>
    <url>/2017/03/20/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<p>RMQ只对给定数组进行查询操作，如果要求加入修改操作，<code>update()</code>，如果继续使用RMQ、Sparse-Table算法，每次更新都要重新计算$d$数组，时间花费非常大。线段树意义在此。</p>
<h1 id="1、点修改"><a href="#1、点修改" class="headerlink" title="1、点修改"></a>1、点修改</h1><p><strong> 支持操作</strong>：</p>
<ul>
<li><code>Update(x, b)</code>：把$A_x$修改为$v$</li>
<li><p><code>Query(L, R)</code>：计算$min { A<em>L, A</em>{L+1}, …, A_R } $<br><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdteyw9k6wj30is0e4dge.jpg" alt=""></p>
</li>
<li><p>如图，表示$[1,9]$区间对应的线段树，每个非叶子结点都有两个子树，分别对应左半，右半。</p>
</li>
<li>从上到下，从左到右给所有结点编号为，$1,2,3,4,…,$，则<strong>编号为</strong> $i$<strong>的结点左右结点编号为</strong>$2i$<strong>和</strong>$wi+1$。</li>
<li>如果区间长度为$2^h$。不难发现，第$i$层有$2^i$个结点，，每个结点对应一个长度为$2^{h-i}$的区间，最大层编号为$h$，结点总数为$1+2+4+8+…+2^h=2^{h+1}-1$，略小于区间长度的两倍，当整个区间长度不是2的整数倍，虽然叶子不全在同一层，但树的最大层编号和节电总数仍然满足上述结论。</li>
</ul>
<a id="more"></a>
<p><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdtezmvsmpj308w04rwen.jpg" alt=""></p>
<p> <strong>假设需要维护区间最小值信息</strong></p>
<ul>
<li>可以在每个结点上几率该线段中所有元素的最小值，比如在$[5,8]$的结点里保存元素，$5,6,7,8$的最小值，即$min{ A_5,A_6,A_7,A_8 }$。在程序中，可以用数组$minv$保存这个信息，$minv[3] = min{ A_5,A_6,A_7,A_8 }$</li>
<li>因为每层最多只有两个结点继续延伸，因此“查询边界”不超过$2h$个，$h$为线段树的最大编号，也就是把查询区间分成了不超过$2h$个的不相交线段的并集，</li>
<li>如图$[2,5] = [2] + [3,4] + [5]$，之后凡是遇到类似的区间分解，把分解得到的各个区间叫做<strong>边界区间</strong>，</li>
<li>更新结点时，只需要更新线段$[i,i]$对应的结点，然后更新它对应的祖先结点。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="2、区间修改"><a href="#2、区间修改" class="headerlink" title="2、区间修改"></a>2、区间修改</h1>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2017/03/20/%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<h1 id="背包相关问题"><a href="#背包相关问题" class="headerlink" title="背包相关问题"></a>背包相关问题</h1><h2 id="最优装载问题"><a href="#最优装载问题" class="headerlink" title="最优装载问题"></a>最优装载问题</h2><p>给出$n$个物体，第$i$个物体的重量为$w_i$。选择尽可能多的物品，使得总重量不超过$C$<br><strong>【分析】</strong></p>
<ul>
<li>只关心物品数量，则最优的解为每次只取最轻的物品，即为最优解。</li>
</ul>
<h2 id="部分背包问题"><a href="#部分背包问题" class="headerlink" title="部分背包问题"></a>部分背包问题</h2><p>给出$n$个物品，第$i$个重量为$w_i$，价值为$v_i$。在重量不超过$C$的情况下让价值尽可能高，每个物体可取走一部分，按比例计算价值。<br><strong>【分析】</strong></p>
<ul>
<li>相比最优装载问题，这里增加了价值，所以由于可以取走一部分物品，综合考虑，优先选择“性价比”最高的物品，直到使重量正好为$C$<br><em>注意：除了最后一个外，其余的物品要么不取要么全拿走。</em><a id="more"></a>
<h2 id="乘船问题"><a href="#乘船问题" class="headerlink" title="乘船问题"></a>乘船问题</h2>有$n$个人，第$i$个重量为$w_i$，每艘船的最大载重量均为$C$，且最多只能乘坐两人，用最少的船装载所有人。<br><strong>【分析】</strong></li>
<li>考虑最轻的人，如果没人可以与他同船，则唯一方案是每人一艘船，否则，安排可以与其同船的人中最重的人。贪心策略：让眼前的浪费减少</li>
</ul>
<h1 id="区间相关问题"><a href="#区间相关问题" class="headerlink" title="区间相关问题"></a>区间相关问题</h1><h2 id="选择不相交区间"><a href="#选择不相交区间" class="headerlink" title="选择不相交区间"></a>选择不相交区间</h2><p>数轴上有$n$个开区间$(a_i,b_i)$。选择尽可能多个区间，使得这些区间两两没有公共点。<br><strong>【分析】</strong></p>
<ul>
<li>首先明确如果存在两个区间包含关系，即区间$x$完全包含区间$y$。那么，很明显选择$x$是不明智的。</li>
<li>接下来，按照$b_i$从小到大给区间排序，<strong><em>贪心策略是：一定要选择第一个区间</em></strong><ul>
<li>为什么？在区间按照$ b<em>i \leq b</em>{i+1}$排序的状况下，考虑两种情况</li>
<li><strong>情况1: $a<em>i &gt; a</em>{i+1}$</strong>已经提到，区间$i$包含$i+1$的情况，一定不会选择区间$i+1$。</li>
<li><strong>情况2: </strong>排除了情况1，一定有$a<em>i \leq a</em>{i+1}$，如图$(b)$所示。如果区间2和区间1完全不相交，那么没有影响，否则区间1和区间2只能选一个。如过不选区间2，黑色部分是没有影响的，区间1的有效部分变成灰色，被区间2，3包含，由刚才结论，区间2，3，是不能选的，以此类推，不能因为选择任何区间而放弃其他区间，因此选择区间1 是正确的。<br><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdta0lnuqsj308v036746.jpg" alt=""></li>
</ul>
</li>
</ul>
<h2 id="区间选点问题"><a href="#区间选点问题" class="headerlink" title="区间选点问题"></a>区间选点问题</h2><p>数轴上有$n$个闭区间$[a_i,b_i]$。取尽可能少的点，使得每个区间内都至少有一个点。<br><strong>【分析】</strong></p>
<ul>
<li>如果区间$i$内已经有一个点被取到，则此区间已被满足，讨论区间包含的情况：小区间满足时大区间一定被满足，区间包含的情况下， 大区间不用被考虑。</li>
<li>把所有区间按照$b$从小到大排序，若$b$相同，则按照$a$从大到小排序，这样的话如果出现区间包含的情况，小区间一定排在前面，<strong><em>贪心策略是，对于第一个区间，取最右的点</em></strong>如图。<br><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdta0ljnhkj308w02yq2u.jpg" alt=""></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//POJ1328 区间选点部分代码</span></span><br><span class="line"><span class="keyword">double</span> tmp = island[<span class="number">0</span>].right;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp &lt; island[i].left) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        tmp = island[i].right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间覆盖问题"><a href="#区间覆盖问题" class="headerlink" title="区间覆盖问题"></a>区间覆盖问题</h2><p>数轴上有$n$个闭区间$[a_i,b_i]$。取尽可能少的区间，覆盖指定线段$[s,t]$。<br><strong>【分析】</strong></p>
<ul>
<li>仍然是区间包含和排序扫描</li>
<li>首先是预处理，将给定每个区间上，在线段$[s,t]$外的部分都预先被切除掉，这部分存在是没有影响的，</li>
<li>相互包含的情况下显然小的部分是不会被考虑的。</li>
<li>预处理之后，将区间按照$a$从小到大排列，如果区间1的起点不是$s$则显然无解，之后的区间的$a$更要大于区间1，否则选择起点在$s$的最长区间，选择此区间$[a_i,b_i]$后，新的起点应设置为$b_i$，并且忽略所有区间在$b_i$之前的部分。如图，$s$为当前有效起点，则应该选择区间2.</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdta0lopzij308w03ndfq.jpg" alt=""></p>
<h1 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h1><p>假设某文件中只有6种字符：a, b, c, d, e, f，可以用3个二进制位来表示，如表8-2所示（表8-2～表8-4中，频率的单位均为“千次”）。<br><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdta0lki97j30jr03ljrj.jpg" alt=""><br>这样，一共需要<code>(45+13+12+16+9+5)*3=300</code>千比特（即二进制的位）。第二种方法是采用变长编码，如表8-3所示。<br><img src="ttps://ws1.sinaimg.cn/large/006Ka4GEly1fdta0lk1b6j30j803ct8u.jpg" alt=""><br>总长度为<code>145+3*13+3*12+3*16+4*9+4*5=224</code>千比特，比定长码短。读者可能会说：还可以更短，如表8-4所示。<br><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdta0lketuj30jt03ljrj.jpg" alt=""><br>总长度只有<code>1*(45+13)+2*(12+16+9+5)=142</code>千比特，不是更短吗？可惜，这样的编码方案是有问题的。如果收到了001，那么究竟是<code>aab、cb，</code>还是<code>ad</code>？换句话说，这样的编码有歧义，因为其中一个字符的编码是另一个码的<strong>前缀（prefix）</strong>。表8-3所示的码没有这样的情况，任何一个编码都不是另一个的前缀。这里把满足这样性质的编码称为<strong>前缀码（Prefix Code）</strong>。下面正式叙述编码问题。</p>
<h4 id="最优编码问题"><a href="#最优编码问题" class="headerlink" title="最优编码问题"></a>最优编码问题</h4><p>给出$n$个字符的频率$c_i$，给每个字符赋予一个01编码串，使得任意一个字符的编码不是另一个的前缀码，而且编码后的总长度尽量小。<br><strong>【分析】</strong></p>
<ul>
<li><p>对于前缀码，存在结论：任何一个前缀码都可以表示成<strong>每个非叶子节点恰巧有两个子节点的二叉树</strong>，如图所示，每个非叶子节点和其左子节点的边上标1，与右子节点的边上标2，则每个叶子对应一个字符，编码为从根节点到该节点的路径的01序列<br><img src="" alt=""></p>
<ul>
<li>证明需要两个结论</li>
<li><strong>结论1：</strong>$n$个叶子的二叉树一定对应一个前缀码，如果编码<code>a</code>为编码<code>b</code>的前缀，则<code>a</code>所对应的节点一定为<code>b</code>的祖先，而两个叶子节点不会形成祖先关系。</li>
<li><strong>结论2:</strong> 最优前缀码一定可以写成二叉树。逐个字符构造即可。每拿到一个编码，都可 以构造出从根到叶子的一条路径，沿着已有结点走，创建不存在的结点。这样得到的二叉树 不可能有单子结点，因为如果存在，只要用这个子结点代替父结点，得到的仍然是前缀码， 且总长度更短。</li>
</ul>
</li>
<li><p>接下来的问题就是：<strong>如何构建一颗最优的编码树</strong>。</p>
</li>
<li><strong>Huffeman算法：</strong>把每个字符看作一个单节点子树放在一个树集合中，每棵子树的权值等于相应字符的频率，每次取权值最小的两棵子树合成一颗新树，重新放到集合中新树的权值等于两子树权值之和。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>基本算法</tag>
      </tags>
  </entry>
  <entry>
    <title>linux中的硬件与硬盘的划分</title>
    <url>/2017/03/18/linux%E4%B8%AD%E7%9A%84%E7%A1%AC%E4%BB%B6%E4%B8%8E%E7%A1%AC%E7%9B%98%E7%9A%84%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<blockquote>
<p>鸟哥在此节之前讲述了<a href="http://linux.vbird.org/linux_basic/0110whatislinux.php#whatislinux" target="_blank" rel="noopener">Linux的发展</a>，具体可以去鸟哥官方网站浏览。</p>
</blockquote>
<h1 id="各种设备在Linux中的文件名"><a href="#各种设备在Linux中的文件名" class="headerlink" title="各种设备在Linux中的文件名"></a>各种设备在Linux中的文件名</h1><ul>
<li>对于Linux来说，所有设备都被视作文件，举例来说SATA总线硬盘在linux中的文件名为<code>/dev/sd[a-d]</code>，下面列出常见的硬件与其文件名。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>设备</th>
<th>设备在Linux中的文件名</th>
</tr>
</thead>
<tbody>
<tr>
<td>SCSI/SATA/USB硬盘/U盘</td>
<td>/dev/sd[a-p]</td>
</tr>
<tr>
<td>VirtI/O界面</td>
<td>/dev/vd[a-p] (用於虛擬機器內)</td>
</tr>
<tr>
<td>软盘</td>
<td>/dev/fd[0-1]</td>
</tr>
<tr>
<td>打印机</td>
<td>/dev/lp[0-2] (25針印表機)<br>/dev/usb/lp[0-15] (USB 介面)</td>
</tr>
<tr>
<td>鼠标</td>
<td>/dev/input/mouse[0-15] (通用)<br>/dev/psaux (PS/2界面)<br>/dev/mouse (當前滑鼠)</td>
</tr>
<tr>
<td>CDROM/DVDROM</td>
<td>/dev/scd[0-1] (通用)<br>/dev/sr[0-1] (通用，CentOS 較常見)<br>/dev/cdrom (當前 CDROM)</td>
</tr>
<tr>
<td>磁带机</td>
<td>/dev/ht0 (IDE 界面)<br>/dev/st0 (SATA/SCSI界面)<br>/dev/tape (當前磁帶)</td>
</tr>
<tr>
<td>IDE硬盘</td>
<td>/dev/hd[a-d]（旧式系统才有）</td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<ul>
<li>更多Linux内核支持的硬件文件名参考如下文档： <a href="https://www.kernel.org/doc/Documentation/devices.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/devices.txt</a></li>
</ul>
<h1 id="硬盘划分"><a href="#硬盘划分" class="headerlink" title="硬盘划分"></a>硬盘划分</h1><p>对于目前来说，硬盘分区有MBR和GPT两种分区结构，现在分别来介绍。</p>
<h2 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h2><p>主引导记录（Master Boot Record，缩写：MBR），又叫做<strong>主引导扇区</strong>，是电脑开机后访问硬盘时所必须要读取的首个扇区，它在硬盘上的三维地址为（柱面，磁头，扇区）＝（0，0，1）。在深入讨论主引导扇区内部结构的时候，有时也将其开头的446字节内容特指为“主引导记录”（MBR），其后是4个16字节的“磁盘分区表”（DPT），以及2字节的结束标志（55AA）。对于那些扇区为512位组的磁盘，MBR分区表不支持容量大于2.2TB（2.2×1012字节）的分区。<br><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdta0lpao4j30e609wwf6.jpg" alt=""></p>
<h3 id="MBR组成"><a href="#MBR组成" class="headerlink" title="MBR组成"></a>MBR组成</h3><ul>
<li>MBR由<strong>启动代码，硬盘分区表，结束标识符</strong>三部分组成</li>
<li><strong>启动代码</strong>：主引导记录最开头是第一阶段引导代码。其中的硬盘引导程序的主要作用是检查分区表是否正确并且在系统硬件完成自检以后将控制权交给硬盘上的引导程序（如GNU GRUB）。它不依赖任何操作系统，而且启动代码也是可以改变的，从而能够实现多系统引导。</li>
<li><strong>硬盘分区表</strong>，占主引导扇区的64个字节，如上表从<strong>偏移01BEH</strong> 到 <strong>偏移01FDH</strong> ，可以描述四个分区的信息。每个分区信息占16个字节，具体含义如下。</li>
<li><strong>偏移</strong>可以类比C中指针，只是一个相对值，我们不知道这个量对应的起始0是从哪里开始的，所以叫做偏移。</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdta0lp3itj30e20budh6.jpg" alt=""></p>
<ul>
<li>如果某一分区在硬盘分区表的信息如下：<code>80 01 01 00 0B FE BF FC 3F 00 00 00 7E 86 BB 00</code>则我们可以看到，最前面的”80”是一个分区的激活标志，表示系统可引导[1]；”01 01 00”表示分区开始的磁头号为1，开始的扇区号为1，开始的柱面号为0；”0B”表示分区的系统类型是FAT32，其他比较常用的有04（FAT16）、07（NTFS）；”FE BF FC”表示分区结束的磁头号为254，分区结束的扇区号为63、分区结束的柱面号为764；”3F 00 00 00”表示首扇区的相对扇区号为63（小端序）；”7E 86 BB 00”表示总扇区数为12289662（小端序）。</li>
<li><strong>结束标志字55，AA</strong>（偏移1FEH－偏移1FFH）最后两个字节，是检验主引导记录是否有效的标志。</li>
</ul>
<h3 id="MBR读取流程"><a href="#MBR读取流程" class="headerlink" title="MBR读取流程"></a>MBR读取流程</h3><ol>
<li>BIOS 加电自检（Power On Self Test — POST）。BIOS执行内存地址为FFFF:0000H处的跳转指令，跳转到固化在ROM中的自检程序处，对系统硬件（包括内存）进行检查。</li>
<li>读取主引导记录（MBR）。当BIOS检查到硬件正常并与CMOS中的设置相符后，按照CMOS中对启动设备的设置顺序检测可用的启动设备。BIOS将相应启动设备的第一个扇区（也就是MBR扇区）读入内存地址为0000:7C00H处。</li>
<li>检查0000:7CFEH-0000:7CFFH（MBR的结束标志位）是否等于55AAH，若不等于则转去尝试其他启动设备，如果没有启动设备满足要求则显示”NO ROM BASIC”然后死机。</li>
<li>当检测到有启动设备满足要求后，BIOS将控制权交给相应启动设备。启动设备的MBR将自己复制到0000:0600H处，然后继续执行。</li>
<li>根据MBR中的引导代码启动引导程序。</li>
</ol>
<h3 id="主引导记录与硬盘分区"><a href="#主引导记录与硬盘分区" class="headerlink" title="主引导记录与硬盘分区"></a>主引导记录与硬盘分区</h3><ul>
<li>由上述信息我们得知，MBR分区表只有64字节而每个分区信息需要16个字节，所以对于MBR型分区结构的硬盘，最多只能识别4个主要<strong>分区（Primary partition）</strong>，所以对于MBR分区结构来说，想要得到更多的分区，就需要<strong>扩展分区了</strong>，扩展分区是主分区的一种，但是理论上可以划分出无数个<strong>逻辑分区</strong>。</li>
<li>扩展分区中逻辑驱动器的引导记录是链式的。每一个逻辑分区都有一个和MBR结构类似的<strong>扩展引导记录（EBR）</strong>，其分区表的<em>第一项指向该逻辑分区本身的引导扇区，第二项指向下一个逻辑驱动器的EBR</em>，分区表第三、第四项没有用到。</li>
<li>注意<ul>
<li>对于Windows默认来说，一个主分区划分给系统分区，剩下的全部划分为逻辑分区</li>
<li>逻辑分区最多有一个。</li>
<li>在linux系统中，硬盘分区命名为<code>sda1 - sda4/hda1-hda4</code>，逻辑分区必须从5开始。</li>
<li>在MBR分区表中，一个分区最大容量为2.2T。</li>
</ul>
</li>
</ul>
<h2 id="GPT，GUID-Partition-Table"><a href="#GPT，GUID-Partition-Table" class="headerlink" title="GPT，GUID Partition Table"></a>GPT，GUID Partition Table</h2><p><strong>全局唯一标识分区表（GUID Partition Table，缩写：GPT）</strong>是一个实体硬盘的分区表的结构布局的标准。它是可扩展固件接口（EFI）标准（被Intel用于替代个人计算机的BIOS）的一部分，被用于替代BIOS系统中的一32bits来存储逻辑块地址和大小信息的主引导记录（MBR）分区表。</p>
<p>GTP采用<strong>逻辑块分区(Logical Block Address, LBA)</strong>来代替早期的<strong>柱面-磁头-扇区（英语：Cylinder-head-sector，简称为CHS）</strong>数据寻址方式。传统MBR信息存储于LBA 0，GPT头存储于LBA 1，接下来才是分区表本身。例如4位Windows操作系统使用16,384字节（或32扇区）作为GPT分区表，接下来的LBA 34是硬盘上第一个分区的开始。并且减少分区表损坏的风险，GPT在硬盘最后保存了一份分区表的副本。<br>整个GTP结构如下图<br><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdtabbeypvj309w0dsgm9.jpg" alt=""></p>
<ul>
<li>LBA0（传统MBR）<ul>
<li>在GPT分区表的最开头，处于兼容性考虑仍然存储了一份传统的MBR，用来防止不支持GPT的硬盘管理工具错误识别并破坏硬盘中的数据，这个MBR也叫做保护MBR。在支持从GPT启动的操作系统中，这里也用于存储第一阶段的启动代码。在这个MBR中，只有一个标识为0xEE的分区，以此来表示这块硬盘使用GPT分区表。不能识别GPT硬盘的操作系统通常会识别出一个未知类型的分区，并且拒绝对硬盘进行操作，除非用户特别要求删除这个分区。这就避免了意外删除分区的危险。</li>
</ul>
</li>
<li><p>LAB1（GPT分区表头）</p>
<ul>
<li>分区表头定义了硬盘的可用空间以及组成分区表的项的大小和数量。在使用64位Windows Server 2003的机器上，最多可以创建128个分区，即分区表中保留了128个项，其中每个都是128字节。（EFI标准要求分区表最小要有16,384字节，即128个分区项的大小）</li>
<li>头还记录了这块硬盘的GUID，记录了分区表头本身的位置和大小（位置总是在LBA 1）以及备份分区表头和分区表的位置和大小（在硬盘的最后）。它还储存着它本身和分区表的CRC32校验。固件、引导程序和操作系统在启动时可以根据这个校验值来判断分区表是否出错，如果出错了，可以使用软件从硬盘最后的备份GPT中恢复整个分区表，如果备份GPT也校验错误，硬盘将不可使用。所以GPT硬盘的分区表不可以直接使用16进制编辑器修改。</li>
</ul>
</li>
<li><p>LAB2-33（实际区表项）</p>
<ul>
<li>从LBA2开始，每个LBA可以记录四个分区记录，正如上所说总共有4*32个分区记录,每笔记录占用128字节</li>
<li>GPT分区表使用简单而直接的方式表示分区。一个分区表项的前16字节是分区类型GUID。例如，EFI系统分区的GUID类型是{C12A7328-F81F-11D2-BA4B-00A0C93EC93B}。接下来的16字节是该分区唯一的GUID（这个GUID指的是该分区本身，而之前的GUID指的是该分区的类型）。再接下来是分区起始和末尾的64位LBA编号，以及分区的名字和属性。<br><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdta0lk20wj30d5074aai.jpg" alt=""></li>
<li>由于64字节来记录开始结束LBA编号，所以每个分区的容量扩大到<code>264 * 512bytes = 263 * 1Kbytes = 233*TB = 8 ZB</code></li>
</ul>
</li>
</ul>
<p>注意，对于Linux来说，磁盘管理工具<code>fdisk</code>和启动管理工具<code>grub 1</code>并不识别GPT分区格式，需要采用<code>gdisk,parted,grub2</code></p>
<h1 id="BIOS-与-UEFI"><a href="#BIOS-与-UEFI" class="headerlink" title="BIOS 与 UEFI"></a>BIOS 与 UEFI</h1><h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><p>BIOS（Basic Input/Output System的缩写、中文：基本输入输出系统），在IBM PC兼容系统上，是一种业界标准的固件接口。<br>未完。<br><a href="https://en.wikipedia.org/wiki/BIOS" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/BIOS</a><br><a href="https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏程序员相关书籍推荐</title>
    <url>/2017/03/16/%E6%B8%B8%E6%88%8F%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<p>游戏程序员相关书籍推荐，整合 by miloyip<br>原链接见水印<br>长图，慎点<br><a href="https://miloyip.github.io/game-programmer/game-programmer-zh-cn.pdf" target="_blank" rel="noopener">PDF版</a><br><a id="more"></a><br><img src="http://www.qlcoder.com//uploads/ddec77b6b4/148967609581332.jpg" alt=""></p>
]]></content>
      <categories>
        <category>学习书籍</category>
      </categories>
      <tags>
        <tag>书籍推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础学习-计算机操作系统概论</title>
    <url>/2017/03/13/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>笔记基于<a href="http://linux.vbird.org/linux_basic/" target="_blank" rel="noopener">《鸟哥的linux私房菜 基础篇》</a> 原网站为繁体中文，有些术语可能在翻译上出现错误，请注意。</p>
</blockquote>
<h1 id="计算机概论"><a href="#计算机概论" class="headerlink" title="计算机概论"></a>计算机概论</h1><h2 id="个人计算机架构和接口"><a href="#个人计算机架构和接口" class="headerlink" title="个人计算机架构和接口"></a>个人计算机架构和接口</h2><ul>
<li><p>下图为2015年的一款Intel主板架构<img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdta914yz7j30go0dywi3.jpg" alt=""></p>
</li>
<li><p>早期主板上的芯片组分为两个桥接器来控制各组件的通信，<strong>北桥负责连接速度较快的CPU、内存、显卡等组件</strong>，<strong>南桥负责速度较慢的周边接口，硬盘、USB、网卡等</strong>，北桥称为系统总线，南桥成为输入输出总线。</p>
</li>
<li><p>不过由于北桥最最重要的就是CPU与内存之间的桥接，现如今的主板为了提高内存与CPU之间的传输效率大都将内存控制器整合到CPU内部，所以现在的主板上大都找不到北桥。</p>
</li>
<li><p>CPU的<strong>倍频</strong>和<strong>外频</strong></p>
<ul>
<li>外频是指CPU与外部组件进行传输运算的速度，倍频是CPU内部用来加速CPU工作性能的一个倍数</li>
<li>一般超频指的是外频，倍频是被厂商固定死的。</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li><p>32位和64位</p>
<ul>
<li>北桥所支持的频率称为<strong>前端总线速度(Front Side Bus, FSB)</strong>，而每次传送的位数则为<strong>总线宽度</strong>，总线宽频为：<strong>FSB * 总线宽度</strong>，即每秒钟可传送的最大数据量。</li>
<li>对于CPU，每次能处理的数据量称为<strong>字组大小(word size)</strong>，字组大小根据CPU的设计而有32位与64位。我们现在所称的计算机32 或 64 就是根据CPU的字组大小来说的。因为CPU的解析的数据量有限，所以32位的CPU最多支持4GB的内存</li>
</ul>
</li>
<li><p>CPU等级</p>
<ul>
<li>由于x86架构的CPU在1993年之后针脚设计不统一，为了规范CPU的不同种类设计了CPU等级。</li>
<li>Intel Pentium MMX 与 AMD K6 年代的CPU为i586</li>
<li>Intel Celeron 与 AMD Athlon(K7) 年代之后的x86CPU称为i686</li>
<li>目前的64位CPU统一称为x86_64</li>
</ul>
</li>
<li><p>超线程</p>
<ul>
<li>在每个CPU内部将暂存器分成两部分，让程序分别使用这两部分暂存器。</li>
</ul>
</li>
<li><p>内存<strong>双通道设计</strong></p>
<ul>
<li>目前的总线宽度最高为64位，为了加大这个宽度，芯片组厂商将两个内存整合在一起两条内存可达到128位。</li>
</ul>
</li>
<li><p>DDR3/DDR3L<br>  -为了节省更多的电力，新的制程中降低了内存的操作电压，DDR3标准电压为1.5V，而DDR3L仅需1.35V，即支持DDR3L的主板定支持DDR3，而支持DDR3的主板不一定支持DDR3L</p>
</li>
<li><p>只读存储器(ROM)</p>
<ul>
<li>主板上的组件具有参数，这些参数具有可调整性，各项参数值就被记录到主板上一个<strong>CMOS</strong>的芯片上，这个芯片需要主板上的一个电池来供电。</li>
<li>CMOS数据更新需要<strong>BIOS (Basic Input Output System)</strong>来读取更新，而BIOS是写死在主板上的一个芯片上，这个芯片在没有通电时也能记录数据，叫做<strong>只读存储器(ROM)</strong></li>
<li>但因为BIOS的大小和复杂程度随时间不断增加，而且硬件的更新速度加快，令BIOS也必须不断更新以支持新硬件，于是BIOS就改为存储在EEPROM或者闪存中，让用户可以轻易更新BIOS。</li>
</ul>
</li>
<li><p>硬盘</p>
<ul>
<li>硬盘是由<strong>圆形磁碟盘、机械手臂、 磁碟读取头与主轴马达</strong>所组成的<br><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdta8qb0x7j30cx0bmt9t.jpg" alt=""></li>
<li>而磁盘碟上的数据如上图表示，整个磁碟盘上有多个同心圆绘制出的圆形图，而由圆心以放射状的方式分割出磁碟的最小储存单位，那就是<strong>磁区(Sector)</strong>， 在物理组成分面，<strong>每个磁区大小为512Bytes</strong>，这个值是不会改变的。但是最近的硬盘因为需求容量越来越大，出现了磁区容量高达4Kbyte的设计。而磁区组成一个圆就成为<strong>磁轨(track)</strong>， 如果是在多碟的硬盘上面，在所有磁碟盘上面的同一个磁轨可以组成一个<strong>磁柱(Cylinder)</strong>，也成为柱面， 磁柱也是一般我们分割硬盘时的最小单位了。</li>
</ul>
</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li>操作系统内核（Kernel）<ul>
<li>操作系统内核主要提供管控硬件方面的能力，存取硬盘，网络功能，CPU资源取得等，并且<strong>内核程序放置到内存的特定区块中受到保护，从开机开始一直常驻内存中</strong></li>
<li><strong>系统调用</strong>由操作系统提供的可以被内核调用的接口。方便程序员与内核进行通讯，将硬件资源进一步利用。</li>
</ul>
</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdta84x430g309d07xjrd.gif" alt=""></p>
<ul>
<li>内核功能<ul>
<li>系统调用接口</li>
<li>程序管理</li>
<li>内存管理</li>
<li>文件系统管理</li>
<li>设备驱动</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图最佳完美匹配</title>
    <url>/2017/03/12/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E4%BD%B3%E5%AE%8C%E7%BE%8E%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<blockquote>
<p>死磕了几天，还是不太明白，把各个地方别人写的东西拿来总结下。</p>
</blockquote>
<p>假设有一个完全二分图$G$，每条边有一个权值（可以为负）。Kuhn-Munkres算法就是求权值和最大的完美匹配的算法。</p>
<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><ul>
<li><strong>完备匹配</strong>：设$G= <V_1,V_2,E >$为二部图，$|V_1|≤|V_2|$，$M$为$G$中一个最大匹配，且$|M|＝|V_1|$，则称$M$为$V_1$到$V_2$的完备匹配。</li>
<li><strong>完美匹配</strong>：在上述定义中，若$|V_2|＝|V_1|$，则完备匹配即为完美匹配</li>
<li><strong>可行性顶标</strong>：是一个节点函数$l$，使得对于任意的弧$(x,y)$。存在$l(x)+l(y)&gt;=w(x,y)$。</li>
<li><strong>相等子图</strong>：是$G$的生成子图，包含所有点，但是只包含满足$l(x)+l(y) = w(x,y)$的所有边。</li>
<li><strong>结论</strong>：<em>如果相等子图有完美匹配，则该匹配是原图的最大权匹配。</em></li>
</ul>
<a id="more"></a>
<p>根据上述的结论，KM算法的关键就是，<strong><em>寻找好的可行顶标，使相等子图有完美匹配。</em></strong></p>
<h1 id="KM算法"><a href="#KM算法" class="headerlink" title="KM算法"></a>KM算法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>任意构造一个可行顶标（比如，$Y$结点顶标为$0$，$X$结点的顶标为它出发所有边的最大值），然后求相等子图的最大匹配，如果存在完美匹配，算法终止，否则修改顶标使得相等子图的边变多，就有更大机会存在完美匹配。<br>如果当前的相等子图没有完美匹配，即对于某个顶点$X$，我们找不到一条从它出发的交错路，这时我们获得了一条交错树，他的叶子结点全部都为$X$顶点。我们把交错树中$X$顶点的顶标全部都减去某个值$d$，$Y$的顶标全部都加上这个值$d$那么：</p>
<ol>
<li>两端都在交错树中的边$(x,y)$，$l(x)+l(y)$的值没有变化。也就是说，它原来属于相等子图，现在仍属于相等子图。</li>
<li>两端都不在交错树中的边$(x,y)$，$l(x)$和$l(y)$都没有变化。也就是说，它原来属于（或不属于）相等子图，现在仍属于（或不属于）相等子图。</li>
<li>$X$端不在交错树中，$Y$端在交错树中的边$(x,y)$，它的$l(x)+l(y)$的值有所增大。它原来不属于相等子图，现在仍不属于相等子图。</li>
<li>$X$端在交错树中，$Y$端不在交错树中的边$(x,y)$，它的$l(x)+l(y)$的值有所减小。也就说，它原来不属于相等子图，现在可能进入了相等子图，因而使相等子图得到了扩大。</li>
</ol>
<p>分析这四个过程可知，为了使$l(x)+l(y)&gt;=w[x,y]$始终成立，且至少有一条边进入相等子图，$d$应该等于：$Min { l(x)+l(y)-w[i,j] | x 在交错树中，j 不在交错树中 }$<br>以上就是KM算法的朴素实现，时间复杂度为$O(n^4)$——需要找$O(n)$次增广路，每次增广最多需要修改$O(n)$次顶标，每次修改顶标时由于要枚举边来求d值，复杂度为$O(n^2)$。实际上KM算法的复杂度是可以做到$O(n^3)$的。我们给每个$Y$顶点一个“松弛量”函数<code>slack</code>，每次开始找增广路时初始化为无穷大。在寻找增广路的过程中，检查边$(x,y)$时，如果它不在相等子图中，则让<code>slack(j)</code>变成原值与$l(x)+l(y)-w[x,y]$的较小值。这样，在修改顶标时，取所有不在交错树中的$Y$顶点的<code>slack</code>值中的最小值作为$d$值即可。但还要注意一点：修改顶标后，要把所有的不在交错树中的$Y$顶点的<code>slack</code>值都减去$d$。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="相关结论"><a href="#相关结论" class="headerlink" title="相关结论"></a>相关结论</h1>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM算法概览</title>
    <url>/2017/03/08/ACM%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<p>大图右键图片新标签页打开查看。<br>内容根据POJ题目分类生成，采用Xmind生成导出</p>
<p><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdta0lprb4j30pa13rjtf.jpg" alt=""></p>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP</title>
    <url>/2017/03/07/KMP/</url>
    <content><![CDATA[<p>KMP算法是一种改进的字符串匹配算法，关键是<strong>利用失配后的信息来减少模式串与主串的匹配次数</strong>，具体实现为一个<code>next()</code>函数，函数本身包含了模版串的匹配信息，KMP算法的时间复杂度为<strong>O(m+n)</strong></p>
<a id="more"></a>
<h1 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h1><p>下面考虑字符串匹配的过程，给出一个文本串和模版串，如下图<br><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdta3kfcm8j30ge042a9x.jpg" alt=""></p>
<p>按照朴素匹配算法的思想，文本串与模版串第一个字符不同，即失配，这时让模版串右移，与文本串第二个字符尝试匹配……<br><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdta6akkh5j30g803ejr9.jpg" alt=""></p>
<p>这时文本串中的字符与模版串中的第一个字符相同，我们继续比较文本串下一个和模式串的第二字符，直到再次失配……<br><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdta6mcblgj30g103ma9x.jpg" alt=""></p>
<p>按照朴素匹配的思想，这时失配之后我们要将模版串右移一位继续重复上述过程，然而KMP算法的思想是，当空格与D不匹配时，我们是可以从模版串上得知，文本串空格之前一定为<code>ABCDAB</code>，并且继续尝试匹配的话，至少右移4位才有可能再次匹配，KMP算法就是通过<code>next()</code>函数预处理模版串，来预先找出失配边，进而优化匹配次数。</p>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFail</span><span class="params">(<span class="keyword">char</span> *P, <span class="keyword">int</span> *f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">strlen</span>(P);</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>; f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;m;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = f[i];</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; P[i] != P[j]) j = f[j]; <span class="comment">//失配</span></span><br><span class="line">        f[i+<span class="number">1</span>] = P[i] == P[j]?j+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> *T, <span class="keyword">char</span> *P, <span class="keyword">int</span> *f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//T为文本串，P为模版串，f为状态转移表</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(T),m = <span class="built_in">strlen</span>(P);</span><br><span class="line">    getFail(P,f);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;        <span class="comment">//当前结点编号，初始为0号节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;    <span class="comment">//文本串当前指针</span></span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; P[j] != T[i]) j = f[j]; <span class="comment">//顺着失配边走，直到可以匹配</span></span><br><span class="line">        <span class="keyword">if</span>(p[j == T[i]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j == m) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i-m+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie</title>
    <url>/2017/03/07/trie/</url>
    <content><![CDATA[<ol>
<li>Trie也称作前缀树，来保存一个字符串集合。</li>
<li>核心思想是<strong>空间换时间</strong> <em>利用字符串的公共前缀来降低时间开销以达到节省时间的目的</em>。</li>
<li>优点是：最大限度减少无谓字符的比较，查询效率比哈希高。</li>
<li>缺点是：Trie树的内存消耗非常大，利用左儿子右兄弟的建树方法可以减少空间上的消耗。</li>
</ol>
<h1 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h1><ol>
<li>根结点不包含字符，除此之外的每个结点包含一个字符。</li>
<li>从根结点到某一结点，路径上的结点字符连接起来，为该点对应的字符串。</li>
<li>每个结点所有子结点包含的字符都不相同。</li>
<li>一棵m度的trie树要么为空，要么为m棵n度的trie树构成。</li>
</ol>
<a id="more"></a>
<h1 id="trie树的相关操作"><a href="#trie树的相关操作" class="headerlink" title="trie树的相关操作"></a>trie树的相关操作</h1><h2 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h2><p>对于一个字符串，从根结点开始，沿着各个字符对应树中的结点分支往下走，直到单词遍历完，给最后字符结点标记，表示该字符串插入到trie树中。</p>
<h3 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h3><p>从根结点开始，按照字符串的字符顺序向下遍历trie树，直到某个结点标记不存在或者字符串遍历完，若最后的结点被标记则所查找的字符串存在，否则不存在。</p>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> ch[maxnode][sigma_size];</span><br><span class="line">	<span class="keyword">int</span> val[maxnode];	<span class="comment">//附加信息，表示该结点是否为单词结点</span></span><br><span class="line">	<span class="keyword">int</span> sz;		<span class="comment">//结点总数</span></span><br><span class="line">	Trie() &#123;sz = <span class="number">1</span>; <span class="built_in">memset</span>(ch[<span class="number">0</span>],<span class="number">0</span>,<span class="keyword">sizeof</span>(ch[<span class="number">0</span>])); &#125; <span class="comment">//初始时只有一个根结点</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;<span class="keyword">return</span> c -  <span class="string">'a'</span>;&#125; <span class="comment">//字符c的编号</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//插入字符串s，附加信息为v</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u = <span class="number">0</span>,n = <span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> c = idx(s[i]);</span><br><span class="line">			<span class="keyword">if</span>(!ch[u][c]) &#123;		<span class="comment">//结点不存在</span></span><br><span class="line">				<span class="built_in">memset</span>(ch[sz],<span class="number">0</span>,<span class="keyword">sizeof</span>(ch[sz]));</span><br><span class="line">				val[sz] = <span class="number">0</span>; 	<span class="comment">//中间结点的附加信息为 0</span></span><br><span class="line">				ch[u][c] = sz++;	<span class="comment">//新建结点</span></span><br><span class="line">			&#125;</span><br><span class="line">			u = ch[u][c];</span><br><span class="line">		&#125;</span><br><span class="line">		val[u] = v;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u = <span class="number">0</span>,n = <span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> c = idx(s[i]);</span><br><span class="line">			<span class="keyword">if</span>(!ch[u][c] ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			u = ch[u][c];</span><br><span class="line">			<span class="keyword">if</span>(i == n<span class="number">-1</span> &amp;&amp; val[u] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图最大匹配</title>
    <url>/2017/03/06/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><ul>
<li><strong>二分图</strong>：如果图中的点可以分为两组，图中的边都连接两组中的各一个点，那么这个图为二分图。等价定义：不含有奇数条边的环</li>
<li><strong>匹配</strong>：一个匹配是一个集合，其中任意两条边都没有公共顶点。</li>
<li><strong>最大匹配</strong>：一个图中的所有匹配中，含有匹配边数最多的匹配为这个图的最大匹配。</li>
<li><strong>完美匹配</strong>：一个图的某个匹配中所有顶点都为匹配点，则该匹配为完美匹配。</li>
</ul>
<a id="more"></a>
<h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><p><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdtadbaj6nj3070059q32.jpg" alt=""></p>
<p>如图所示，如果某一对男孩和女孩之间有相连的边，代表他们彼此喜欢。是否能让所有的男孩和女孩两两配对，使得每对都互相喜欢，这就是<strong>完美匹配</strong>问题；最多有多少对男女孩可以配对，这就是<strong>最大匹配</strong>问题</p>
<h1 id="增广路算法"><a href="#增广路算法" class="headerlink" title="增广路算法"></a>增广路算法</h1><h2 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li><strong>交替路</strong>：从一个未匹配点出发，依次经过非匹配边，匹配边，非匹配边，匹配边……所形成的路径为交替路</li>
<li><strong>增广路</strong>：从一个为匹配点出发，走交替路，如果途径另一个为匹配点，则该路成为增广路。</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdtads6ua0j304j04ut8u.jpg" alt=""></p>
<p>该图的一条增广路如下：<br><img src="https://ws1.sinaimg.cn/large/006Ka4GEly1fdtae28qncj307y01yq2u.jpg" alt=""></p>
<ul>
<li>增广路重要特点：非匹配边比匹配边多出一条，因此增广路的意义是<strong>改进匹配</strong>，只要将增广路中的匹配边和非匹配边身份交换，该匹配的匹配边就会加一。（中间的匹配节点不存在与其他相连的匹配边，所以不会破坏匹配的性质）</li>
<li>不停地寻找增广路来增加匹配边，找不到增广路时便是达到最大匹配，这就是匈牙利算法的原理。</li>
<li>一个匹配是最大匹配的充分必要条件是不存在增广路。</li>
<li><strong>匈牙利树</strong>：一般由BFS构造，从一个未匹配点出发进行BFS，限制是必须走交替路，直到不能扩展为止。</li>
<li>匈牙利树要求所有的叶子节点均为匹配点。</li>
</ul>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">1</span>;y&lt;=v1;y++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">map</span>[x][y] &amp;&amp; !visit[y])&#123;</span><br><span class="line">			visit[y] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(link[y] = <span class="number">0</span> || dfs(link[y])) &#123;</span><br><span class="line">				link[y] = x;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>;x&lt;=v2;x++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line">		<span class="keyword">if</span>(dfs(x)) ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ul>
<li>POJ3041 利用最小点覆盖数 = 最大匹配数结论求解<h1 id="相关结论"><a href="#相关结论" class="headerlink" title="相关结论"></a>相关结论</h1></li>
</ul>
<ul>
<li><p><strong>最小点覆盖数：</strong>选取最少的点，使任意一条边至少有一个端点被选择</p>
</li>
<li><p><strong>最大独立数：</strong>选取最多的点，使任意所选两点均不相连</p>
</li>
<li><p><strong>最小路径覆盖数：</strong>对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）。</p>
</li>
<li><p>定理1：最大匹配数 = 最小点覆盖数（这是 Konig 定理）</p>
</li>
<li><p>定理2：最大匹配数 = 最大独立数</p>
</li>
<li><p>定理3：最小路径覆盖数 = 顶点数 - 最大匹配数</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2017/03/05/hello-world/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>开始用Hexo + 腾讯云vps 作为个人博客，主要写平常练习的算法竞赛题。</p>
</blockquote>]]></content>
  </entry>
</search>
